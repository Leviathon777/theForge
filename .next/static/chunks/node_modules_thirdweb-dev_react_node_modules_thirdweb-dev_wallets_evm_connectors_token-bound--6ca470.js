"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["node_modules_thirdweb-dev_react_node_modules_thirdweb-dev_wallets_evm_connectors_token-bound--6ca470"],{

/***/ "./node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/dist/http-rpc-client-0a079e80.browser.esm.js":
/*!**************************************************************************************************************************!*\
  !*** ./node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/dist/http-rpc-client-0a079e80.browser.esm.js ***!
  \**************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"D\": function() { return /* binding */ DEBUG; },\n/* harmony export */   \"H\": function() { return /* binding */ HttpRpcClient; },\n/* harmony export */   \"g\": function() { return /* binding */ getUserOpHashV06; },\n/* harmony export */   \"h\": function() { return /* binding */ hexlifyUserOp; },\n/* harmony export */   \"r\": function() { return /* binding */ randomNonce; }\n/* harmony export */ });\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ethers */ \"./node_modules/ethers/lib.esm/index.js\");\n/* harmony import */ var _url_a45219bd_browser_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./url-a45219bd.browser.esm.js */ \"./node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/dist/url-a45219bd.browser.esm.js\");\n/* harmony import */ var _headers_733a8199_browser_esm_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./headers-733a8199.browser.esm.js */ \"./node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/dist/headers-733a8199.browser.esm.js\");\n/* harmony import */ var _utils_f58e7acc_browser_esm_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils-f58e7acc.browser.esm.js */ \"./node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/dist/utils-f58e7acc.browser.esm.js\");\n\n\n\n\n\nasync function hexlifyUserOp(\n// TODO: types\nop) {\n  const userOp = await ethers__WEBPACK_IMPORTED_MODULE_0__.utils.resolveProperties(op);\n  return Object.keys(userOp).map(key => {\n    let val = userOp[key];\n    if (typeof val !== \"string\" || !val.startsWith(\"0x\")) {\n      val = ethers__WEBPACK_IMPORTED_MODULE_0__.utils.hexValue(val);\n    }\n    return [key, val];\n  }).reduce((set, _ref) => {\n    let [k, v] = _ref;\n    return {\n      ...set,\n      [k]: v\n    };\n  }, {});\n}\n\n// v0.6 userOpHash calculation\nasync function getUserOpHashV06(userOp, entryPoint, chainId) {\n  const op = await ethers__WEBPACK_IMPORTED_MODULE_0__.utils.resolveProperties(userOp);\n  const hashedUserOp = {\n    sender: op.sender,\n    nonce: op.nonce,\n    initCodeHash: ethers__WEBPACK_IMPORTED_MODULE_0__.utils.keccak256(op.initCode),\n    callDataHash: ethers__WEBPACK_IMPORTED_MODULE_0__.utils.keccak256(op.callData),\n    callGasLimit: op.callGasLimit,\n    verificationGasLimit: op.verificationGasLimit,\n    preVerificationGas: op.preVerificationGas,\n    maxFeePerGas: op.maxFeePerGas,\n    maxPriorityFeePerGas: op.maxPriorityFeePerGas,\n    paymasterAndDataHash: ethers__WEBPACK_IMPORTED_MODULE_0__.utils.keccak256(op.paymasterAndData)\n  };\n  const userOpType = {\n    components: [{\n      type: \"address\",\n      name: \"sender\"\n    }, {\n      type: \"uint256\",\n      name: \"nonce\"\n    }, {\n      type: \"bytes32\",\n      name: \"initCodeHash\"\n    }, {\n      type: \"bytes32\",\n      name: \"callDataHash\"\n    }, {\n      type: \"uint256\",\n      name: \"callGasLimit\"\n    }, {\n      type: \"uint256\",\n      name: \"verificationGasLimit\"\n    }, {\n      type: \"uint256\",\n      name: \"preVerificationGas\"\n    }, {\n      type: \"uint256\",\n      name: \"maxFeePerGas\"\n    }, {\n      type: \"uint256\",\n      name: \"maxPriorityFeePerGas\"\n    }, {\n      type: \"bytes32\",\n      name: \"paymasterAndDataHash\"\n    }],\n    name: \"hashedUserOp\",\n    type: \"tuple\"\n  };\n  const encoded = ethers__WEBPACK_IMPORTED_MODULE_0__.utils.defaultAbiCoder.encode([userOpType], [{\n    ...hashedUserOp\n  }]);\n  // remove leading word (total length) and trailing word (zero-length signature)\n\n  const userOpHash = ethers__WEBPACK_IMPORTED_MODULE_0__.utils.keccak256(encoded);\n  const enc = ethers__WEBPACK_IMPORTED_MODULE_0__.utils.defaultAbiCoder.encode([\"bytes32\", \"address\", \"uint256\"], [userOpHash, entryPoint, chainId]);\n  return ethers__WEBPACK_IMPORTED_MODULE_0__.utils.keccak256(enc);\n}\nconst generateRandomUint192 = () => {\n  const rand1 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand2 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand3 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand4 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand5 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand6 = BigInt(Math.floor(Math.random() * 0x100000000));\n  return rand1 << BigInt(160) | rand2 << BigInt(128) | rand3 << BigInt(96) | rand4 << BigInt(64) | rand5 << BigInt(32) | rand6;\n};\nconst randomNonce = () => {\n  let hexString = generateRandomUint192().toString(16);\n  if (hexString.length % 2 !== 0) {\n    hexString = \"0\" + hexString;\n  }\n  hexString = \"0x\" + hexString;\n  return ethers__WEBPACK_IMPORTED_MODULE_0__.BigNumber.from(ethers__WEBPACK_IMPORTED_MODULE_0__.utils.concat([hexString, \"0x0000000000000000\"]));\n};\n\nconst DEBUG = false; // TODO set as public flag\n\nclass HttpRpcClient {\n  constructor(bundlerUrl, entryPointAddress, chainId, clientId, secretKey) {\n    this.bundlerUrl = bundlerUrl;\n    this.entryPointAddress = entryPointAddress;\n    this.chainId = chainId;\n    const headers = {};\n    if ((0,_url_a45219bd_browser_esm_js__WEBPACK_IMPORTED_MODULE_1__.i)(this.bundlerUrl)) {\n      const bundleId = typeof globalThis !== \"undefined\" && \"APP_BUNDLE_ID\" in globalThis ? globalThis.APP_BUNDLE_ID : undefined;\n      if (secretKey) {\n        headers[\"x-secret-key\"] = secretKey;\n      } else if (clientId) {\n        headers[\"x-client-id\"] = clientId;\n        if (bundleId) {\n          headers[\"x-bundle-id\"] = bundleId;\n        }\n      }\n\n      // Dashboard token\n      if (typeof globalThis !== \"undefined\" && \"TW_AUTH_TOKEN\" in globalThis && typeof globalThis.TW_AUTH_TOKEN === \"string\") {\n        headers[\"authorization\"] = `Bearer ${globalThis.TW_AUTH_TOKEN}`;\n      }\n\n      // CLI token\n      if (typeof globalThis !== \"undefined\" && \"TW_CLI_AUTH_TOKEN\" in globalThis && typeof globalThis.TW_CLI_AUTH_TOKEN === \"string\") {\n        headers[\"authorization\"] = `Bearer ${globalThis.TW_CLI_AUTH_TOKEN}`;\n        headers[\"x-authorize-wallet\"] = \"true\";\n      }\n      (0,_headers_733a8199_browser_esm_js__WEBPACK_IMPORTED_MODULE_2__.s)(headers);\n    }\n    this.userOpJsonRpcProvider = new ethers__WEBPACK_IMPORTED_MODULE_0__.providers.StaticJsonRpcProvider({\n      url: this.bundlerUrl,\n      headers\n    }, {\n      name: \"Connected bundler network\",\n      chainId\n    });\n    this.initializing = this.validateChainId();\n  }\n  async validateChainId() {\n    if (await (0,_utils_f58e7acc_browser_esm_js__WEBPACK_IMPORTED_MODULE_3__.e)(this.chainId)) {\n      return;\n    }\n    // validate chainId is in sync with expected chainid\n    const chain = await this.userOpJsonRpcProvider.send(\"eth_chainId\", []);\n    const bundlerChain = parseInt(chain);\n    if (bundlerChain !== this.chainId) {\n      throw new Error(`bundler ${this.bundlerUrl} is on chainId ${bundlerChain}, but provider is on chainId ${this.chainId}`);\n    }\n  }\n\n  /**\n   * send a UserOperation to the bundler\n   * @param userOp1 - The UserOperation to send\n   * @returns userOpHash the id of this operation, for getUserOperationTransaction\n   */\n  async sendUserOpToBundler(userOp1) {\n    await this.initializing;\n    const hexifiedUserOp = await hexlifyUserOp(userOp1);\n    const jsonRequestData = [hexifiedUserOp, this.entryPointAddress];\n    await this.printUserOperation(\"eth_sendUserOperation\", jsonRequestData);\n    return await this.userOpJsonRpcProvider.send(\"eth_sendUserOperation\", [hexifiedUserOp, this.entryPointAddress]);\n  }\n  async estimateUserOpGas(userOp) {\n    await this.initializing;\n    const hexifiedUserOp = await hexlifyUserOp(userOp);\n    const jsonRequestData = [hexifiedUserOp, this.entryPointAddress];\n    await this.printUserOperation(\"eth_estimateUserOperationGas\", jsonRequestData);\n    const data = await this.userOpJsonRpcProvider.send(\"eth_estimateUserOperationGas\", [hexifiedUserOp, this.entryPointAddress]);\n    // adds gas buffer to callGasLimit to account for ManagedAccountFactory delegate calls\n    return {\n      preVerificationGas: ethers__WEBPACK_IMPORTED_MODULE_0__.BigNumber.from(data.preVerificationGas),\n      verificationGas: ethers__WEBPACK_IMPORTED_MODULE_0__.BigNumber.from(data.verificationGas),\n      verificationGasLimit: ethers__WEBPACK_IMPORTED_MODULE_0__.BigNumber.from(data.verificationGasLimit),\n      callGasLimit: ethers__WEBPACK_IMPORTED_MODULE_0__.BigNumber.from(data.callGasLimit).add(_utils_f58e7acc_browser_esm_js__WEBPACK_IMPORTED_MODULE_3__.M)\n    };\n  }\n  async getUserOperationGasPrice() {\n    await this.initializing;\n    return await this.userOpJsonRpcProvider.send(\"thirdweb_getUserOperationGasPrice\", []);\n  }\n  async getUserOperationReceipt(userOpHash) {\n    await this.initializing;\n    return await this.userOpJsonRpcProvider.send(\"eth_getUserOperationReceipt\", [userOpHash]);\n  }\n  async zkPaymasterData(transactionInput) {\n    await this.initializing;\n    return await this.userOpJsonRpcProvider.send(\"zk_paymasterData\", [await hexlifyUserOp({\n      ...transactionInput,\n      gas: transactionInput.gasLimit\n    })]);\n  }\n  async zkBroadcastTransaction(transactionInput) {\n    await this.initializing;\n    return await this.userOpJsonRpcProvider.send(\"zk_broadcastTransaction\", [transactionInput]);\n  }\n  async printUserOperation(method, _ref) {\n    {\n      return;\n    }\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRoaXJkd2ViLWRldi9yZWFjdC9ub2RlX21vZHVsZXMvQHRoaXJkd2ViLWRldi93YWxsZXRzL2Rpc3QvaHR0cC1ycGMtY2xpZW50LTBhMDc5ZTgwLmJyb3dzZXIuZXNtLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFxRDtBQUNRO0FBQ2dCO0FBQ3lCOztBQUV0RztBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMkRBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0RBQWM7QUFDMUI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQiwyREFBdUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1EQUFlO0FBQ2pDLGtCQUFrQixtREFBZTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG1EQUFlO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdFQUE0QjtBQUM5QztBQUNBLEdBQUc7QUFDSDs7QUFFQSxxQkFBcUIsbURBQWU7QUFDcEMsY0FBYyxnRUFBNEI7QUFDMUMsU0FBUyxtREFBZTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsa0RBQWMsQ0FBQyxnREFBWTtBQUNwQzs7QUFFQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0RBQU87QUFDZjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDLHlCQUF5QjtBQUN0RTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDLDZCQUE2QjtBQUMxRTtBQUNBO0FBQ0EsTUFBTSxtRUFBbUI7QUFDekI7QUFDQSxxQ0FBcUMsbUVBQStCO0FBQ3BFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlFQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxpQkFBaUIsZ0JBQWdCLGFBQWEsK0JBQStCLGFBQWE7QUFDM0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtEQUFjO0FBQ3hDLHVCQUF1QixrREFBYztBQUNyQyw0QkFBNEIsa0RBQWM7QUFDMUMsb0JBQW9CLGtEQUFjLHdCQUF3Qiw2REFBMEI7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXVHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AdGhpcmR3ZWItZGV2L3JlYWN0L25vZGVfbW9kdWxlcy9AdGhpcmR3ZWItZGV2L3dhbGxldHMvZGlzdC9odHRwLXJwYy1jbGllbnQtMGEwNzllODAuYnJvd3Nlci5lc20uanM/Y2YxOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1dGlscywgQmlnTnVtYmVyLCBwcm92aWRlcnMgfSBmcm9tICdldGhlcnMnO1xuaW1wb3J0IHsgaSBhcyBpc1R3VXJsIH0gZnJvbSAnLi91cmwtYTQ1MjE5YmQuYnJvd3Nlci5lc20uanMnO1xuaW1wb3J0IHsgcyBhcyBzZXRBbmFseXRpY3NIZWFkZXJzIH0gZnJvbSAnLi9oZWFkZXJzLTczM2E4MTk5LmJyb3dzZXIuZXNtLmpzJztcbmltcG9ydCB7IGUgYXMgaXNaa1N5bmNDaGFpbiwgTSBhcyBNQU5BR0VEX0FDQ09VTlRfR0FTX0JVRkZFUiB9IGZyb20gJy4vdXRpbHMtZjU4ZTdhY2MuYnJvd3Nlci5lc20uanMnO1xuXG5hc3luYyBmdW5jdGlvbiBoZXhsaWZ5VXNlck9wKFxuLy8gVE9ETzogdHlwZXNcbm9wKSB7XG4gIGNvbnN0IHVzZXJPcCA9IGF3YWl0IHV0aWxzLnJlc29sdmVQcm9wZXJ0aWVzKG9wKTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHVzZXJPcCkubWFwKGtleSA9PiB7XG4gICAgbGV0IHZhbCA9IHVzZXJPcFtrZXldO1xuICAgIGlmICh0eXBlb2YgdmFsICE9PSBcInN0cmluZ1wiIHx8ICF2YWwuc3RhcnRzV2l0aChcIjB4XCIpKSB7XG4gICAgICB2YWwgPSB1dGlscy5oZXhWYWx1ZSh2YWwpO1xuICAgIH1cbiAgICByZXR1cm4gW2tleSwgdmFsXTtcbiAgfSkucmVkdWNlKChzZXQsIF9yZWYpID0+IHtcbiAgICBsZXQgW2ssIHZdID0gX3JlZjtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc2V0LFxuICAgICAgW2tdOiB2XG4gICAgfTtcbiAgfSwge30pO1xufVxuXG4vLyB2MC42IHVzZXJPcEhhc2ggY2FsY3VsYXRpb25cbmFzeW5jIGZ1bmN0aW9uIGdldFVzZXJPcEhhc2hWMDYodXNlck9wLCBlbnRyeVBvaW50LCBjaGFpbklkKSB7XG4gIGNvbnN0IG9wID0gYXdhaXQgdXRpbHMucmVzb2x2ZVByb3BlcnRpZXModXNlck9wKTtcbiAgY29uc3QgaGFzaGVkVXNlck9wID0ge1xuICAgIHNlbmRlcjogb3Auc2VuZGVyLFxuICAgIG5vbmNlOiBvcC5ub25jZSxcbiAgICBpbml0Q29kZUhhc2g6IHV0aWxzLmtlY2NhazI1NihvcC5pbml0Q29kZSksXG4gICAgY2FsbERhdGFIYXNoOiB1dGlscy5rZWNjYWsyNTYob3AuY2FsbERhdGEpLFxuICAgIGNhbGxHYXNMaW1pdDogb3AuY2FsbEdhc0xpbWl0LFxuICAgIHZlcmlmaWNhdGlvbkdhc0xpbWl0OiBvcC52ZXJpZmljYXRpb25HYXNMaW1pdCxcbiAgICBwcmVWZXJpZmljYXRpb25HYXM6IG9wLnByZVZlcmlmaWNhdGlvbkdhcyxcbiAgICBtYXhGZWVQZXJHYXM6IG9wLm1heEZlZVBlckdhcyxcbiAgICBtYXhQcmlvcml0eUZlZVBlckdhczogb3AubWF4UHJpb3JpdHlGZWVQZXJHYXMsXG4gICAgcGF5bWFzdGVyQW5kRGF0YUhhc2g6IHV0aWxzLmtlY2NhazI1NihvcC5wYXltYXN0ZXJBbmREYXRhKVxuICB9O1xuICBjb25zdCB1c2VyT3BUeXBlID0ge1xuICAgIGNvbXBvbmVudHM6IFt7XG4gICAgICB0eXBlOiBcImFkZHJlc3NcIixcbiAgICAgIG5hbWU6IFwic2VuZGVyXCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcInVpbnQyNTZcIixcbiAgICAgIG5hbWU6IFwibm9uY2VcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiYnl0ZXMzMlwiLFxuICAgICAgbmFtZTogXCJpbml0Q29kZUhhc2hcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwiYnl0ZXMzMlwiLFxuICAgICAgbmFtZTogXCJjYWxsRGF0YUhhc2hcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwidWludDI1NlwiLFxuICAgICAgbmFtZTogXCJjYWxsR2FzTGltaXRcIlxuICAgIH0sIHtcbiAgICAgIHR5cGU6IFwidWludDI1NlwiLFxuICAgICAgbmFtZTogXCJ2ZXJpZmljYXRpb25HYXNMaW1pdFwiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICBuYW1lOiBcInByZVZlcmlmaWNhdGlvbkdhc1wiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICBuYW1lOiBcIm1heEZlZVBlckdhc1wiXG4gICAgfSwge1xuICAgICAgdHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICBuYW1lOiBcIm1heFByaW9yaXR5RmVlUGVyR2FzXCJcbiAgICB9LCB7XG4gICAgICB0eXBlOiBcImJ5dGVzMzJcIixcbiAgICAgIG5hbWU6IFwicGF5bWFzdGVyQW5kRGF0YUhhc2hcIlxuICAgIH1dLFxuICAgIG5hbWU6IFwiaGFzaGVkVXNlck9wXCIsXG4gICAgdHlwZTogXCJ0dXBsZVwiXG4gIH07XG4gIGNvbnN0IGVuY29kZWQgPSB1dGlscy5kZWZhdWx0QWJpQ29kZXIuZW5jb2RlKFt1c2VyT3BUeXBlXSwgW3tcbiAgICAuLi5oYXNoZWRVc2VyT3BcbiAgfV0pO1xuICAvLyByZW1vdmUgbGVhZGluZyB3b3JkICh0b3RhbCBsZW5ndGgpIGFuZCB0cmFpbGluZyB3b3JkICh6ZXJvLWxlbmd0aCBzaWduYXR1cmUpXG5cbiAgY29uc3QgdXNlck9wSGFzaCA9IHV0aWxzLmtlY2NhazI1NihlbmNvZGVkKTtcbiAgY29uc3QgZW5jID0gdXRpbHMuZGVmYXVsdEFiaUNvZGVyLmVuY29kZShbXCJieXRlczMyXCIsIFwiYWRkcmVzc1wiLCBcInVpbnQyNTZcIl0sIFt1c2VyT3BIYXNoLCBlbnRyeVBvaW50LCBjaGFpbklkXSk7XG4gIHJldHVybiB1dGlscy5rZWNjYWsyNTYoZW5jKTtcbn1cbmNvbnN0IGdlbmVyYXRlUmFuZG9tVWludDE5MiA9ICgpID0+IHtcbiAgY29uc3QgcmFuZDEgPSBCaWdJbnQoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwMDApKTtcbiAgY29uc3QgcmFuZDIgPSBCaWdJbnQoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwMDApKTtcbiAgY29uc3QgcmFuZDMgPSBCaWdJbnQoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwMDApKTtcbiAgY29uc3QgcmFuZDQgPSBCaWdJbnQoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwMDApKTtcbiAgY29uc3QgcmFuZDUgPSBCaWdJbnQoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwMDApKTtcbiAgY29uc3QgcmFuZDYgPSBCaWdJbnQoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwMDApKTtcbiAgcmV0dXJuIHJhbmQxIDw8IEJpZ0ludCgxNjApIHwgcmFuZDIgPDwgQmlnSW50KDEyOCkgfCByYW5kMyA8PCBCaWdJbnQoOTYpIHwgcmFuZDQgPDwgQmlnSW50KDY0KSB8IHJhbmQ1IDw8IEJpZ0ludCgzMikgfCByYW5kNjtcbn07XG5jb25zdCByYW5kb21Ob25jZSA9ICgpID0+IHtcbiAgbGV0IGhleFN0cmluZyA9IGdlbmVyYXRlUmFuZG9tVWludDE5MigpLnRvU3RyaW5nKDE2KTtcbiAgaWYgKGhleFN0cmluZy5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgaGV4U3RyaW5nID0gXCIwXCIgKyBoZXhTdHJpbmc7XG4gIH1cbiAgaGV4U3RyaW5nID0gXCIweFwiICsgaGV4U3RyaW5nO1xuICByZXR1cm4gQmlnTnVtYmVyLmZyb20odXRpbHMuY29uY2F0KFtoZXhTdHJpbmcsIFwiMHgwMDAwMDAwMDAwMDAwMDAwXCJdKSk7XG59O1xuXG5jb25zdCBERUJVRyA9IGZhbHNlOyAvLyBUT0RPIHNldCBhcyBwdWJsaWMgZmxhZ1xuXG5jbGFzcyBIdHRwUnBjQ2xpZW50IHtcbiAgY29uc3RydWN0b3IoYnVuZGxlclVybCwgZW50cnlQb2ludEFkZHJlc3MsIGNoYWluSWQsIGNsaWVudElkLCBzZWNyZXRLZXkpIHtcbiAgICB0aGlzLmJ1bmRsZXJVcmwgPSBidW5kbGVyVXJsO1xuICAgIHRoaXMuZW50cnlQb2ludEFkZHJlc3MgPSBlbnRyeVBvaW50QWRkcmVzcztcbiAgICB0aGlzLmNoYWluSWQgPSBjaGFpbklkO1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgICBpZiAoaXNUd1VybCh0aGlzLmJ1bmRsZXJVcmwpKSB7XG4gICAgICBjb25zdCBidW5kbGVJZCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiICYmIFwiQVBQX0JVTkRMRV9JRFwiIGluIGdsb2JhbFRoaXMgPyBnbG9iYWxUaGlzLkFQUF9CVU5ETEVfSUQgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAoc2VjcmV0S2V5KSB7XG4gICAgICAgIGhlYWRlcnNbXCJ4LXNlY3JldC1rZXlcIl0gPSBzZWNyZXRLZXk7XG4gICAgICB9IGVsc2UgaWYgKGNsaWVudElkKSB7XG4gICAgICAgIGhlYWRlcnNbXCJ4LWNsaWVudC1pZFwiXSA9IGNsaWVudElkO1xuICAgICAgICBpZiAoYnVuZGxlSWQpIHtcbiAgICAgICAgICBoZWFkZXJzW1wieC1idW5kbGUtaWRcIl0gPSBidW5kbGVJZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBEYXNoYm9hcmQgdG9rZW5cbiAgICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBcIlRXX0FVVEhfVE9LRU5cIiBpbiBnbG9iYWxUaGlzICYmIHR5cGVvZiBnbG9iYWxUaGlzLlRXX0FVVEhfVE9LRU4gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaGVhZGVyc1tcImF1dGhvcml6YXRpb25cIl0gPSBgQmVhcmVyICR7Z2xvYmFsVGhpcy5UV19BVVRIX1RPS0VOfWA7XG4gICAgICB9XG5cbiAgICAgIC8vIENMSSB0b2tlblxuICAgICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiICYmIFwiVFdfQ0xJX0FVVEhfVE9LRU5cIiBpbiBnbG9iYWxUaGlzICYmIHR5cGVvZiBnbG9iYWxUaGlzLlRXX0NMSV9BVVRIX1RPS0VOID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGhlYWRlcnNbXCJhdXRob3JpemF0aW9uXCJdID0gYEJlYXJlciAke2dsb2JhbFRoaXMuVFdfQ0xJX0FVVEhfVE9LRU59YDtcbiAgICAgICAgaGVhZGVyc1tcIngtYXV0aG9yaXplLXdhbGxldFwiXSA9IFwidHJ1ZVwiO1xuICAgICAgfVxuICAgICAgc2V0QW5hbHl0aWNzSGVhZGVycyhoZWFkZXJzKTtcbiAgICB9XG4gICAgdGhpcy51c2VyT3BKc29uUnBjUHJvdmlkZXIgPSBuZXcgcHJvdmlkZXJzLlN0YXRpY0pzb25ScGNQcm92aWRlcih7XG4gICAgICB1cmw6IHRoaXMuYnVuZGxlclVybCxcbiAgICAgIGhlYWRlcnNcbiAgICB9LCB7XG4gICAgICBuYW1lOiBcIkNvbm5lY3RlZCBidW5kbGVyIG5ldHdvcmtcIixcbiAgICAgIGNoYWluSWRcbiAgICB9KTtcbiAgICB0aGlzLmluaXRpYWxpemluZyA9IHRoaXMudmFsaWRhdGVDaGFpbklkKCk7XG4gIH1cbiAgYXN5bmMgdmFsaWRhdGVDaGFpbklkKCkge1xuICAgIGlmIChhd2FpdCBpc1prU3luY0NoYWluKHRoaXMuY2hhaW5JZCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gdmFsaWRhdGUgY2hhaW5JZCBpcyBpbiBzeW5jIHdpdGggZXhwZWN0ZWQgY2hhaW5pZFxuICAgIGNvbnN0IGNoYWluID0gYXdhaXQgdGhpcy51c2VyT3BKc29uUnBjUHJvdmlkZXIuc2VuZChcImV0aF9jaGFpbklkXCIsIFtdKTtcbiAgICBjb25zdCBidW5kbGVyQ2hhaW4gPSBwYXJzZUludChjaGFpbik7XG4gICAgaWYgKGJ1bmRsZXJDaGFpbiAhPT0gdGhpcy5jaGFpbklkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGJ1bmRsZXIgJHt0aGlzLmJ1bmRsZXJVcmx9IGlzIG9uIGNoYWluSWQgJHtidW5kbGVyQ2hhaW59LCBidXQgcHJvdmlkZXIgaXMgb24gY2hhaW5JZCAke3RoaXMuY2hhaW5JZH1gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogc2VuZCBhIFVzZXJPcGVyYXRpb24gdG8gdGhlIGJ1bmRsZXJcbiAgICogQHBhcmFtIHVzZXJPcDEgLSBUaGUgVXNlck9wZXJhdGlvbiB0byBzZW5kXG4gICAqIEByZXR1cm5zIHVzZXJPcEhhc2ggdGhlIGlkIG9mIHRoaXMgb3BlcmF0aW9uLCBmb3IgZ2V0VXNlck9wZXJhdGlvblRyYW5zYWN0aW9uXG4gICAqL1xuICBhc3luYyBzZW5kVXNlck9wVG9CdW5kbGVyKHVzZXJPcDEpIHtcbiAgICBhd2FpdCB0aGlzLmluaXRpYWxpemluZztcbiAgICBjb25zdCBoZXhpZmllZFVzZXJPcCA9IGF3YWl0IGhleGxpZnlVc2VyT3AodXNlck9wMSk7XG4gICAgY29uc3QganNvblJlcXVlc3REYXRhID0gW2hleGlmaWVkVXNlck9wLCB0aGlzLmVudHJ5UG9pbnRBZGRyZXNzXTtcbiAgICBhd2FpdCB0aGlzLnByaW50VXNlck9wZXJhdGlvbihcImV0aF9zZW5kVXNlck9wZXJhdGlvblwiLCBqc29uUmVxdWVzdERhdGEpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnVzZXJPcEpzb25ScGNQcm92aWRlci5zZW5kKFwiZXRoX3NlbmRVc2VyT3BlcmF0aW9uXCIsIFtoZXhpZmllZFVzZXJPcCwgdGhpcy5lbnRyeVBvaW50QWRkcmVzc10pO1xuICB9XG4gIGFzeW5jIGVzdGltYXRlVXNlck9wR2FzKHVzZXJPcCkge1xuICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6aW5nO1xuICAgIGNvbnN0IGhleGlmaWVkVXNlck9wID0gYXdhaXQgaGV4bGlmeVVzZXJPcCh1c2VyT3ApO1xuICAgIGNvbnN0IGpzb25SZXF1ZXN0RGF0YSA9IFtoZXhpZmllZFVzZXJPcCwgdGhpcy5lbnRyeVBvaW50QWRkcmVzc107XG4gICAgYXdhaXQgdGhpcy5wcmludFVzZXJPcGVyYXRpb24oXCJldGhfZXN0aW1hdGVVc2VyT3BlcmF0aW9uR2FzXCIsIGpzb25SZXF1ZXN0RGF0YSk7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMudXNlck9wSnNvblJwY1Byb3ZpZGVyLnNlbmQoXCJldGhfZXN0aW1hdGVVc2VyT3BlcmF0aW9uR2FzXCIsIFtoZXhpZmllZFVzZXJPcCwgdGhpcy5lbnRyeVBvaW50QWRkcmVzc10pO1xuICAgIC8vIGFkZHMgZ2FzIGJ1ZmZlciB0byBjYWxsR2FzTGltaXQgdG8gYWNjb3VudCBmb3IgTWFuYWdlZEFjY291bnRGYWN0b3J5IGRlbGVnYXRlIGNhbGxzXG4gICAgcmV0dXJuIHtcbiAgICAgIHByZVZlcmlmaWNhdGlvbkdhczogQmlnTnVtYmVyLmZyb20oZGF0YS5wcmVWZXJpZmljYXRpb25HYXMpLFxuICAgICAgdmVyaWZpY2F0aW9uR2FzOiBCaWdOdW1iZXIuZnJvbShkYXRhLnZlcmlmaWNhdGlvbkdhcyksXG4gICAgICB2ZXJpZmljYXRpb25HYXNMaW1pdDogQmlnTnVtYmVyLmZyb20oZGF0YS52ZXJpZmljYXRpb25HYXNMaW1pdCksXG4gICAgICBjYWxsR2FzTGltaXQ6IEJpZ051bWJlci5mcm9tKGRhdGEuY2FsbEdhc0xpbWl0KS5hZGQoTUFOQUdFRF9BQ0NPVU5UX0dBU19CVUZGRVIpXG4gICAgfTtcbiAgfVxuICBhc3luYyBnZXRVc2VyT3BlcmF0aW9uR2FzUHJpY2UoKSB7XG4gICAgYXdhaXQgdGhpcy5pbml0aWFsaXppbmc7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMudXNlck9wSnNvblJwY1Byb3ZpZGVyLnNlbmQoXCJ0aGlyZHdlYl9nZXRVc2VyT3BlcmF0aW9uR2FzUHJpY2VcIiwgW10pO1xuICB9XG4gIGFzeW5jIGdldFVzZXJPcGVyYXRpb25SZWNlaXB0KHVzZXJPcEhhc2gpIHtcbiAgICBhd2FpdCB0aGlzLmluaXRpYWxpemluZztcbiAgICByZXR1cm4gYXdhaXQgdGhpcy51c2VyT3BKc29uUnBjUHJvdmlkZXIuc2VuZChcImV0aF9nZXRVc2VyT3BlcmF0aW9uUmVjZWlwdFwiLCBbdXNlck9wSGFzaF0pO1xuICB9XG4gIGFzeW5jIHprUGF5bWFzdGVyRGF0YSh0cmFuc2FjdGlvbklucHV0KSB7XG4gICAgYXdhaXQgdGhpcy5pbml0aWFsaXppbmc7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMudXNlck9wSnNvblJwY1Byb3ZpZGVyLnNlbmQoXCJ6a19wYXltYXN0ZXJEYXRhXCIsIFthd2FpdCBoZXhsaWZ5VXNlck9wKHtcbiAgICAgIC4uLnRyYW5zYWN0aW9uSW5wdXQsXG4gICAgICBnYXM6IHRyYW5zYWN0aW9uSW5wdXQuZ2FzTGltaXRcbiAgICB9KV0pO1xuICB9XG4gIGFzeW5jIHprQnJvYWRjYXN0VHJhbnNhY3Rpb24odHJhbnNhY3Rpb25JbnB1dCkge1xuICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6aW5nO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnVzZXJPcEpzb25ScGNQcm92aWRlci5zZW5kKFwiemtfYnJvYWRjYXN0VHJhbnNhY3Rpb25cIiwgW3RyYW5zYWN0aW9uSW5wdXRdKTtcbiAgfVxuICBhc3luYyBwcmludFVzZXJPcGVyYXRpb24obWV0aG9kLCBfcmVmKSB7XG4gICAge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgeyBERUJVRyBhcyBELCBIdHRwUnBjQ2xpZW50IGFzIEgsIGdldFVzZXJPcEhhc2hWMDYgYXMgZywgaGV4bGlmeVVzZXJPcCBhcyBoLCByYW5kb21Ob25jZSBhcyByIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/dist/http-rpc-client-0a079e80.browser.esm.js\n"));

/***/ }),

/***/ "./node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/evm/connectors/smart-wallet/dist/thirdweb-dev-wallets-evm-connectors-smart-wallet.browser.esm.js":
/*!******************************************************************************************************************************************************************************!*\
  !*** ./node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/evm/connectors/smart-wallet/dist/thirdweb-dev-wallets-evm-connectors-smart-wallet.browser.esm.js ***!
  \******************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SmartWalletConnector\": function() { return /* binding */ SmartWalletConnector; }\n/* harmony export */ });\n/* harmony import */ var _dist_connector_05689d68_browser_esm_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../../../dist/connector-05689d68.browser.esm.js */ \"./node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/dist/connector-05689d68.browser.esm.js\");\n/* harmony import */ var _dist_http_rpc_client_0a079e80_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../../dist/http-rpc-client-0a079e80.browser.esm.js */ \"./node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/dist/http-rpc-client-0a079e80.browser.esm.js\");\n/* harmony import */ var _dist_url_a45219bd_browser_esm_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../dist/url-a45219bd.browser.esm.js */ \"./node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/dist/url-a45219bd.browser.esm.js\");\n/* harmony import */ var _dist_headers_733a8199_browser_esm_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../dist/headers-733a8199.browser.esm.js */ \"./node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/dist/headers-733a8199.browser.esm.js\");\n/* harmony import */ var _account_abstraction_contracts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @account-abstraction/contracts */ \"./node_modules/@account-abstraction/contracts/dist/index.js\");\n/* harmony import */ var _account_abstraction_contracts__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_account_abstraction_contracts__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ethers */ \"./node_modules/ethers/lib.esm/index.js\");\n/* harmony import */ var _dist_defineProperty_350fc508_browser_esm_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../dist/defineProperty-350fc508.browser.esm.js */ \"./node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/dist/defineProperty-350fc508.browser.esm.js\");\n/* harmony import */ var _thirdweb_dev_sdk__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @thirdweb-dev/sdk */ \"./node_modules/@thirdweb-dev/sdk/dist/thirdweb-dev-sdk.browser.esm.js\");\n/* harmony import */ var _wallets_abstract_dist_thirdweb_dev_wallets_evm_wallets_abstract_browser_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../wallets/abstract/dist/thirdweb-dev-wallets-evm-wallets-abstract.browser.esm.js */ \"./node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/evm/wallets/abstract/dist/thirdweb-dev-wallets-evm-wallets-abstract.browser.esm.js\");\n/* harmony import */ var _dist_utils_f58e7acc_browser_esm_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../../dist/utils-f58e7acc.browser.esm.js */ \"./node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/dist/utils-f58e7acc.browser.esm.js\");\n/* harmony import */ var _thirdweb_dev_chains__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @thirdweb-dev/chains */ \"./node_modules/@thirdweb-dev/chains/dist/thirdweb-dev-chains.esm.js\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! eventemitter3 */ \"./node_modules/@thirdweb-dev/react/node_modules/eventemitter3/index.mjs\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @internal\n */\n\n/**\n * @internal\n */\n\n/**\n * an API to external a UserOperation with paymaster info\n */\nclass PaymasterAPI {}\n\nclass VerifyingPaymasterAPI extends PaymasterAPI {\n  constructor(paymasterUrl, entryPoint, clientId, secretKey) {\n    super();\n    this.paymasterUrl = paymasterUrl;\n    this.entryPoint = entryPoint;\n    this.clientId = clientId;\n    this.secretKey = secretKey;\n  }\n  async getPaymasterAndData(userOp) {\n    const headers = {\n      \"Content-Type\": \"application/json\"\n    };\n    if ((0,_dist_url_a45219bd_browser_esm_js__WEBPACK_IMPORTED_MODULE_3__.i)(this.paymasterUrl)) {\n      if (this.secretKey && this.clientId) {\n        throw new Error(\"Cannot use both secret key and client ID. Please use secretKey for server-side applications and clientId for client-side applications.\");\n      }\n      if (this.secretKey) {\n        headers[\"x-secret-key\"] = this.secretKey;\n      } else if (this.clientId) {\n        headers[\"x-client-id\"] = this.clientId;\n        const bundleId = typeof globalThis !== \"undefined\" && \"APP_BUNDLE_ID\" in globalThis ? globalThis.APP_BUNDLE_ID : undefined;\n        if (bundleId) {\n          headers[\"x-bundle-id\"] = bundleId;\n        }\n      }\n\n      // Dashboard token.\n      if (typeof globalThis !== \"undefined\" && \"TW_AUTH_TOKEN\" in globalThis && typeof globalThis.TW_AUTH_TOKEN === \"string\") {\n        headers[\"authorization\"] = `Bearer ${globalThis.TW_AUTH_TOKEN}`;\n      }\n\n      // CLI token.\n      if (typeof globalThis !== \"undefined\" && \"TW_CLI_AUTH_TOKEN\" in globalThis && typeof globalThis.TW_CLI_AUTH_TOKEN === \"string\") {\n        headers[\"authorization\"] = `Bearer ${globalThis.TW_CLI_AUTH_TOKEN}`;\n        headers[\"x-authorize-wallet\"] = \"true\";\n      }\n      (0,_dist_headers_733a8199_browser_esm_js__WEBPACK_IMPORTED_MODULE_4__.s)(headers);\n    }\n\n    // Ask the paymaster to sign the transaction and return a valid paymasterAndData value.\n    const response = await fetch(this.paymasterUrl, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify({\n        jsonrpc: \"2.0\",\n        id: 1,\n        method: \"pm_sponsorUserOperation\",\n        params: [await (0,_dist_http_rpc_client_0a079e80_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__.h)(userOp), this.entryPoint]\n      })\n    });\n    const res = await response.json();\n    if (!response.ok) {\n      const error = res.error || response.statusText;\n      const code = res.code || \"UNKNOWN\";\n      throw new Error(`Paymaster error: ${error}\nStatus: ${response.status}\nCode: ${code}`);\n    }\n    if (_dist_http_rpc_client_0a079e80_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__.D) {\n      console.debug(\"Paymaster result:\", res);\n    }\n    if (res.result) {\n      // some paymasters return a string, some return an object with more data\n      if (typeof res.result === \"string\") {\n        return {\n          paymasterAndData: res.result\n        };\n      } else {\n        return res.result;\n      }\n    } else {\n      const error = res.error?.message || res.error || response.statusText || \"unknown error\";\n      throw new Error(`Paymaster error from ${this.paymasterUrl}: ${error}`);\n    }\n  }\n}\nconst getVerifyingPaymaster = (paymasterUrl, entryPoint, clientId, secretKey) => new VerifyingPaymasterAPI(paymasterUrl, entryPoint, clientId, secretKey);\n\n/**\n * This class encapsulates Ethers.js listener function and necessary UserOperation details to\n * discover a TransactionReceipt for the operation.\n *\n * TODO refactor this to a simple event listener on the entry point\n */\nclass UserOperationEventListener {\n  constructor(resolve, reject, entryPoint, sender, userOpHash, nonce, timeout) {\n    this.resolve = resolve;\n    this.reject = reject;\n    this.entryPoint = entryPoint;\n    this.sender = sender;\n    this.userOpHash = userOpHash;\n    this.nonce = nonce;\n    this.timeout = timeout;\n    (0,_dist_defineProperty_350fc508_browser_esm_js__WEBPACK_IMPORTED_MODULE_6__._)(this, \"resolved\", false);\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    this.boundLisener = this.listenerCallback.bind(this);\n  }\n  start() {\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    const filter = this.entryPoint.filters.UserOperationEvent(this.userOpHash);\n    // listener takes time... first query directly:\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    setTimeout(async () => {\n      const res = await this.entryPoint.queryFilter(filter, -10); // look at last 10 blocks\n      if (res.length > 0) {\n        void this.listenerCallback(res[0]);\n      } else {\n        this.entryPoint.once(filter, this.boundLisener);\n      }\n    }, 100);\n  }\n  stop() {\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    this.entryPoint.off(\"UserOperationEvent\", this.boundLisener);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  async listenerCallback() {\n    for (var _len = arguments.length, param = new Array(_len), _key = 0; _key < _len; _key++) {\n      param[_key] = arguments[_key];\n    }\n    // TODO clean this up..\n    // eslint-disable-next-line prefer-rest-params\n    const event = arguments[arguments.length - 1];\n    if (!event.args) {\n      console.error(\"got event without args\", event);\n      return;\n    }\n    // TODO: can this happen? we register to event by userOpHash..\n    if (event.args.userOpHash !== this.userOpHash) {\n      console.log(`== event with wrong userOpHash: sender/nonce: event.${event.args.sender}@${event.args.nonce.toString()}!= userOp.${this.sender}@${parseInt(this.nonce?.toString())}`);\n      return;\n    }\n    const transactionReceipt = await event.getTransactionReceipt();\n\n    // before returning the receipt, update the status from the event.\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n    if (!event.args.success) {\n      await this.extractFailureReason(transactionReceipt);\n    }\n    this.stop();\n    this.resolve(transactionReceipt);\n    this.resolved = true;\n  }\n  async extractFailureReason(receipt) {\n    receipt.status = 0;\n    const revertReasonEvents = await this.entryPoint.queryFilter(this.entryPoint.filters.UserOperationRevertReason(this.userOpHash, this.sender), receipt.blockHash);\n    if (revertReasonEvents[0]) {\n      let message = revertReasonEvents[0].args.revertReason;\n      if (message.startsWith(\"0x08c379a0\")) {\n        // Error(string)\n        message = ethers__WEBPACK_IMPORTED_MODULE_7__.utils.defaultAbiCoder.decode([\"string\"], \"0x\" + message.substring(10)).toString();\n      }\n      this.reject(new Error(`UserOp failed with reason: ${message}`));\n    }\n  }\n}\n\nclass ERC4337EthersSigner extends ethers__WEBPACK_IMPORTED_MODULE_7__.Signer {\n  // TODO: we have 'erc4337provider', remove shared dependencies or avoid two-way reference\n  constructor(config, originalSigner, erc4337provider, httpRpcClient, smartAccountAPI) {\n    super();\n    ethers__WEBPACK_IMPORTED_MODULE_7__.utils.defineReadOnly(this, \"provider\", erc4337provider);\n    this.config = config;\n    this.originalSigner = originalSigner;\n    this.erc4337provider = erc4337provider;\n    this.httpRpcClient = httpRpcClient;\n    this.smartAccountAPI = smartAccountAPI;\n    this.approving = false;\n  }\n  // This one is called by Contract. It signs the request and passes in to Provider to be sent.\n  async sendTransaction(transaction, options) {\n    if (!this.approving) {\n      this.approving = true;\n      const tx = await this.smartAccountAPI.createApproveTx();\n      if (tx) {\n        await (await this.sendTransaction(tx)).wait();\n      }\n      this.approving = false;\n    }\n    const tx = await ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.utils.resolveProperties(transaction);\n    await this.verifyAllNecessaryFields(tx);\n    const multidimensionalNonce = (0,_dist_http_rpc_client_0a079e80_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__.r)();\n    const unsigned = await this.smartAccountAPI.createUnsignedUserOp(this.httpRpcClient, {\n      target: tx.to || \"\",\n      data: tx.data?.toString() || \"0x\",\n      value: tx.value,\n      gasLimit: tx.gasLimit,\n      nonce: multidimensionalNonce,\n      maxFeePerGas: tx.maxFeePerGas,\n      maxPriorityFeePerGas: tx.maxPriorityFeePerGas\n    }, options);\n    const userOperation = await this.smartAccountAPI.signUserOp(unsigned);\n    const transactionResponse = await this.erc4337provider.constructUserOpTransactionResponse(userOperation);\n    try {\n      await this.httpRpcClient.sendUserOpToBundler(userOperation);\n    } catch (error) {\n      throw this.unwrapError(error);\n    }\n    // TODO: handle errors - transaction that is \"rejected\" by bundler is _not likely_ to ever resolve its \"wait()\"\n    return transactionResponse;\n  }\n  unwrapError(errorIn) {\n    try {\n      let errorMsg = \"Unknown Error\";\n      if (errorIn.error) {\n        errorMsg = `The bundler has failed to include UserOperation in a batch: ${errorIn.error}`;\n      } else if (errorIn.body && typeof errorIn.body === \"string\") {\n        const errorBody = JSON.parse(errorIn.body);\n        const errorStatus = errorIn.status || \"UNKNOWN\";\n        const errorCode = errorBody?.code || \"UNKNOWN\";\n        let failedOpMessage = errorBody?.error?.message || errorBody?.error?.data || errorBody?.error || errorIn.reason;\n        if (failedOpMessage?.includes(\"FailedOp\")) {\n          let paymasterInfo = \"\";\n          // TODO: better error extraction methods will be needed\n          const matched = failedOpMessage.match(/FailedOp\\((.*)\\)/);\n          if (matched) {\n            const split = matched[1].split(\",\");\n            paymasterInfo = `(paymaster address: ${split[1]})`;\n            failedOpMessage = split[2];\n          }\n          errorMsg = `The bundler has failed to include UserOperation in a batch: ${failedOpMessage} ${paymasterInfo}`;\n        } else {\n          errorMsg = `RPC error: ${failedOpMessage}\nStatus: ${errorStatus}\nCode: ${errorCode}`;\n        }\n      }\n      const error = new Error(errorMsg);\n      error.stack = errorIn.stack;\n      return error;\n    } catch (error) {}\n    return errorIn;\n  }\n  async verifyAllNecessaryFields(transactionRequest) {\n    if (!transactionRequest.to) {\n      throw new Error(\"Missing call target\");\n    }\n    if (!transactionRequest.data && !transactionRequest.value) {\n      // TBD: banning no-op UserOps seems to make sense on provider level\n      throw new Error(\"Missing call data or value\");\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  connect(provider) {\n    throw new Error(\"changing providers is not supported\");\n  }\n  async getAddress() {\n    if (!this.address) {\n      this.address = await this.erc4337provider.getSenderAccountAddress();\n    }\n    return this.address;\n  }\n\n  /**\n   * Sign a message and return the signature\n   */\n  async signMessage(message) {\n    // Deploy smart wallet if needed\n    const isNotDeployed = await this.smartAccountAPI.checkAccountPhantom();\n    if (isNotDeployed) {\n      console.log(\"Account contract not deployed yet. Deploying account before signing message\");\n      const tx = await this.sendTransaction({\n        to: await this.getAddress(),\n        data: \"0x\"\n      });\n      await tx.wait();\n    }\n    const [chainId, address] = await Promise.all([this.getChainId(), this.getAddress()]);\n    const originalMsgHash = ethers__WEBPACK_IMPORTED_MODULE_7__.utils.hashMessage(message);\n    let factorySupports712;\n    let signature;\n    const rpcUrl = (0,_wallets_abstract_dist_thirdweb_dev_wallets_evm_wallets_abstract_browser_esm_js__WEBPACK_IMPORTED_MODULE_1__.chainIdToThirdwebRpc)(chainId, this.config.clientId);\n    const headers = {};\n    if ((0,_dist_url_a45219bd_browser_esm_js__WEBPACK_IMPORTED_MODULE_3__.i)(rpcUrl)) {\n      const bundleId = typeof globalThis !== \"undefined\" && \"APP_BUNDLE_ID\" in globalThis ? globalThis.APP_BUNDLE_ID : undefined;\n      if (this.config.secretKey) {\n        headers[\"x-secret-key\"] = this.config.secretKey;\n      } else if (this.config.clientId) {\n        headers[\"x-client-id\"] = this.config.clientId;\n        if (bundleId) {\n          headers[\"x-bundle-id\"] = bundleId;\n        }\n      }\n\n      // Dashboard token\n      if (typeof globalThis !== \"undefined\" && \"TW_AUTH_TOKEN\" in globalThis && typeof globalThis.TW_AUTH_TOKEN === \"string\") {\n        headers[\"authorization\"] = `Bearer ${globalThis.TW_AUTH_TOKEN}`;\n      }\n\n      // CLI token\n      if (typeof globalThis !== \"undefined\" && \"TW_CLI_AUTH_TOKEN\" in globalThis && typeof globalThis.TW_CLI_AUTH_TOKEN === \"string\") {\n        headers[\"authorization\"] = `Bearer ${globalThis.TW_CLI_AUTH_TOKEN}`;\n        headers[\"x-authorize-wallet\"] = \"true\";\n      }\n      (0,_dist_headers_733a8199_browser_esm_js__WEBPACK_IMPORTED_MODULE_4__.s)(headers);\n    }\n    try {\n      const provider = new ethers__WEBPACK_IMPORTED_MODULE_7__.providers.StaticJsonRpcProvider({\n        url: rpcUrl,\n        headers\n      }, chainId);\n      const walletContract = new ethers__WEBPACK_IMPORTED_MODULE_7__.Contract(address, [\"function getMessageHash(bytes32 _hash) public view returns (bytes32)\"], provider);\n      // if this fails it's a pre 712 factory\n      await walletContract.getMessageHash(originalMsgHash);\n      factorySupports712 = true;\n    } catch {\n      factorySupports712 = false;\n    }\n    if (factorySupports712) {\n      const result = await (0,_thirdweb_dev_sdk__WEBPACK_IMPORTED_MODULE_8__.signTypedDataInternal)(this, {\n        name: \"Account\",\n        version: \"1\",\n        chainId,\n        verifyingContract: address\n      }, {\n        AccountMessage: [{\n          name: \"message\",\n          type: \"bytes\"\n        }]\n      }, {\n        message: ethers__WEBPACK_IMPORTED_MODULE_7__.utils.defaultAbiCoder.encode([\"bytes32\"], [originalMsgHash])\n      });\n      signature = result.signature;\n    } else {\n      signature = await this.originalSigner.signMessage(message);\n    }\n    const isValid = await (0,_dist_utils_f58e7acc_browser_esm_js__WEBPACK_IMPORTED_MODULE_9__.c)(message, signature, address, chainId, this.config.clientId, this.config.secretKey);\n    if (isValid) {\n      return signature;\n    } else {\n      throw new Error(\"Unable to verify signature on smart account, please make sure the smart account is deployed and the signature is valid.\");\n    }\n  }\n  async signTransaction(transaction, options) {\n    const tx = await ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.utils.resolveProperties(transaction);\n    await this.verifyAllNecessaryFields(tx);\n    const multidimensionalNonce = (0,_dist_http_rpc_client_0a079e80_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__.r)();\n    const unsigned = await this.smartAccountAPI.createUnsignedUserOp(this.httpRpcClient, {\n      target: tx.to || \"\",\n      data: tx.data?.toString() || \"0x\",\n      value: tx.value,\n      gasLimit: tx.gasLimit,\n      nonce: multidimensionalNonce\n    }, options);\n    const userOperation = await this.smartAccountAPI.signUserOp(unsigned);\n    const userOpString = JSON.stringify(await (0,_dist_http_rpc_client_0a079e80_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__.h)(userOperation));\n    return userOpString;\n  }\n}\n\nclass ERC4337EthersProvider extends ethers__WEBPACK_IMPORTED_MODULE_7__.providers.BaseProvider {\n  constructor(chainId, config, originalSigner, originalProvider, httpRpcClient, entryPoint, smartAccountAPI) {\n    super({\n      name: \"ERC-4337 Custom Network\",\n      chainId\n    });\n    this.chainId = chainId;\n    this.config = config;\n    this.originalSigner = originalSigner;\n    this.originalProvider = originalProvider;\n    this.httpRpcClient = httpRpcClient;\n    this.entryPoint = entryPoint;\n    this.smartAccountAPI = smartAccountAPI;\n    this.signer = new ERC4337EthersSigner(config, originalSigner, this, httpRpcClient, smartAccountAPI);\n  }\n  getSigner() {\n    return this.signer;\n  }\n  async perform(method, params) {\n    if (method === \"sendTransaction\" || method === \"getTransactionReceipt\") {\n      // TODO: do we need 'perform' method to be available at all?\n      // there is nobody out there to use it for ERC-4337 methods yet, we have nothing to override in fact.\n      throw new Error(\"Should not get here. Investigate.\");\n    }\n    if (method === \"estimateGas\") {\n      // gas estimation does nothing at this layer, sendTransaction will do the gas estimation for the userOp\n      return ethers__WEBPACK_IMPORTED_MODULE_7__.BigNumber.from(500000);\n    }\n    return await this.originalProvider.perform(method, params);\n  }\n  async getTransaction(transactionHash) {\n    // TODO\n    return await super.getTransaction(transactionHash);\n  }\n  async getTransactionReceipt(transactionHash) {\n    const userOpHash = await transactionHash;\n    const sender = await this.getSenderAccountAddress();\n    return await new Promise((resolve, reject) => {\n      new UserOperationEventListener(resolve, reject, this.entryPoint, sender, userOpHash).start();\n    });\n  }\n  async getSenderAccountAddress() {\n    return await this.smartAccountAPI.getAccountAddress();\n  }\n  async waitForTransaction(transactionHash, confirmations, timeout) {\n    const sender = await this.getSenderAccountAddress();\n    return await new Promise((resolve, reject) => {\n      const listener = new UserOperationEventListener(resolve, reject, this.entryPoint, sender, transactionHash, undefined, timeout);\n      listener.start();\n    });\n  }\n\n  // fabricate a response in a format usable by ethers users...\n  async constructUserOpTransactionResponse(userOp1) {\n    const userOp = await ethers__WEBPACK_IMPORTED_MODULE_7__.utils.resolveProperties(userOp1);\n    const userOpHash = await this.smartAccountAPI.getUserOpHash(userOp);\n    return {\n      hash: userOpHash,\n      confirmations: 0,\n      from: userOp.sender,\n      nonce: 0,\n      // not the real nonce, but good enough for this purpose\n      gasLimit: ethers__WEBPACK_IMPORTED_MODULE_7__.BigNumber.from(userOp.callGasLimit),\n      // ??\n      value: ethers__WEBPACK_IMPORTED_MODULE_7__.BigNumber.from(0),\n      data: ethers__WEBPACK_IMPORTED_MODULE_7__.utils.hexValue(userOp.callData),\n      // should extract the actual called method from this \"execFromEntryPoint()\" call\n      chainId: this.chainId,\n      wait: async confirmations => {\n        const transactionReceipt = await this.smartAccountAPI.getUserOpReceipt(this.httpRpcClient, userOpHash);\n        if (userOp.initCode.length !== 0) {\n          // checking if the wallet has been deployed by the transaction; it must be if we are here\n          await this.smartAccountAPI.checkAccountPhantom();\n        }\n        return transactionReceipt;\n      }\n    };\n  }\n  async detectNetwork() {\n    return this.originalProvider.detectNetwork();\n  }\n}\n\n/**\n * wrap an existing provider to tunnel requests through Account Abstraction.\n * @param originalProvider - The normal provider\n * @param config - see {@link ClientConfig} for more info\n * @param originalSigner - use this signer as the owner. of this wallet. By default, use the provider's signer\n */\nfunction create4337Provider(config, accountApi, originalProvider, chainId) {\n  const entryPoint = _account_abstraction_contracts__WEBPACK_IMPORTED_MODULE_0__.EntryPoint__factory.connect(config.entryPointAddress, originalProvider);\n  const httpRpcClient = new _dist_http_rpc_client_0a079e80_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__.H(config.bundlerUrl, config.entryPointAddress, chainId, config.clientId, config.secretKey);\n  return new ERC4337EthersProvider(chainId, config, config.localSigner, originalProvider, httpRpcClient, entryPoint, accountApi);\n}\n\nconst DUMMY_SIGNATURE = \"0xfffffffffffffffffffffffffffffff0000000000000000000000000000000007aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1c\";\n\n/**\n * Base class for all Smart Wallet ERC-4337 Clients to implement.\n * Subclass should inherit 5 methods to support a specific wallet contract:\n *\n * - getAccountInitCode - return the value to put into the \"initCode\" field, if the account is not yet deployed. should create the account instance using a factory contract.\n * - getNonce - return current account's nonce value\n * - encodeExecute - encode the call from entryPoint through our account to the target contract.\n * - signUserOpHash - sign the hash of a UserOp.\n *\n * The user can use the following APIs:\n * - createUnsignedUserOp - given \"target\" and \"calldata\", fill userOp to perform that operation from the account.\n * - createSignedUserOp - helper to call the above createUnsignedUserOp, and then extract the userOpHash and sign it\n */\nclass BaseAccountAPI {\n  // entryPoint connected to \"zero\" address. allowed to make static calls (e.g. to getSenderAddress)\n\n  /**\n   * base constructor.\n   * subclass SHOULD add parameters that define the owner (signer) of this wallet\n   */\n  constructor(params) {\n    (0,_dist_defineProperty_350fc508_browser_esm_js__WEBPACK_IMPORTED_MODULE_6__._)(this, \"isPhantom\", true);\n    this.provider = params.provider;\n    this.entryPointAddress = params.entryPointAddress;\n    this.accountAddress = params.accountAddress;\n    this.paymasterAPI = params.paymasterAPI;\n    this.gasless = params.gasless;\n    this.erc20PaymasterAddress = params.erc20PaymasterAddress;\n    this.erc20TokenAddress = params.erc20TokenAddress;\n\n    // factory \"connect\" define the contract address. the contract \"connect\" defines the \"from\" address.\n    this.entryPointView = _account_abstraction_contracts__WEBPACK_IMPORTED_MODULE_0__.EntryPoint__factory.connect(params.entryPointAddress, params.provider).connect(ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.constants.AddressZero);\n  }\n\n  /**\n   * return the value to put into the \"initCode\" field, if the contract is not yet deployed.\n   * this value holds the \"factory\" address, followed by this account's information\n   */\n\n  /**\n   * return current account's nonce.\n   */\n\n  /**\n   * encode the call from entryPoint through our account to the target contract.\n   * @param target - The target contract address\n   * @param value - The value to send to the target contract\n   * @param data - The calldata to send to the target contract\n   */\n\n  /**\n   * sign a userOp's hash (userOpHash).\n   * @param userOpHash - The hash to sign\n   */\n\n  /**\n   * calculate the account address even before it is deployed\n   */\n\n  /**\n   * check if the contract is already deployed.\n   */\n  async checkAccountPhantom() {\n    if (!this.isPhantom) {\n      // already deployed. no need to check anymore.\n      return this.isPhantom;\n    }\n    const senderAddressCode = await this.provider.getCode(this.getAccountAddress());\n    if (senderAddressCode.length > 2) {\n      this.isPhantom = false;\n    }\n    return this.isPhantom;\n  }\n  /**\n   * return initCode value to into the UserOp.\n   * (either deployment code, or empty hex if contract already deployed)\n   */\n  async getInitCode() {\n    if (await this.checkAccountPhantom()) {\n      return await this.getAccountInitCode();\n    }\n    return \"0x\";\n  }\n\n  /**\n   * return maximum gas used for verification.\n   * NOTE: createUnsignedUserOp will add to this value the cost of creation, if the contract is not yet created.\n   */\n  async getVerificationGasLimit() {\n    return 100000;\n  }\n\n  /**\n   * return userOpHash for signing.\n   * This value matches entryPoint.getUserOpHash (calculated off-chain, to avoid a view call)\n   * @param userOp - userOperation, (signature field ignored)\n   */\n  async getUserOpHash(userOp) {\n    const chainId = await this.provider.getNetwork().then(net => net.chainId);\n    return (0,_dist_http_rpc_client_0a079e80_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__.g)(userOp, this.entryPointAddress, chainId);\n  }\n\n  /**\n   * return the account's address.\n   * this value is valid even before deploying the contract.\n   */\n  async getAccountAddress() {\n    if (!this.senderAddress) {\n      if (this.accountAddress) {\n        this.senderAddress = this.accountAddress;\n      } else {\n        this.senderAddress = await this.getCounterFactualAddress();\n      }\n    }\n    return this.senderAddress;\n  }\n  async estimateCreationGas(initCode) {\n    if (!initCode || initCode === \"0x\") {\n      return 0;\n    }\n    const deployerAddress = initCode.substring(0, 42);\n    const deployerCallData = \"0x\" + initCode.substring(42);\n    return await this.provider.estimateGas({\n      to: deployerAddress,\n      data: deployerCallData\n    });\n  }\n  async createUnsignedUserOp(httpRpcClient, info, options) {\n    let {\n      maxFeePerGas,\n      maxPriorityFeePerGas\n    } = info;\n    // get fees from bundler if available\n    if ((0,_dist_url_a45219bd_browser_esm_js__WEBPACK_IMPORTED_MODULE_3__.i)(httpRpcClient.bundlerUrl)) {\n      const bundlerFeeData = await httpRpcClient.getUserOperationGasPrice();\n      maxFeePerGas = ethers__WEBPACK_IMPORTED_MODULE_7__.BigNumber.from(bundlerFeeData.maxFeePerGas);\n      maxPriorityFeePerGas = ethers__WEBPACK_IMPORTED_MODULE_7__.BigNumber.from(bundlerFeeData.maxPriorityFeePerGas);\n    } else {\n      // if bundler is not available, try to get fees from the network if not passed explicitly\n      if (!maxFeePerGas || !maxPriorityFeePerGas) {\n        const feeData = await (0,_thirdweb_dev_sdk__WEBPACK_IMPORTED_MODULE_8__.getDynamicFeeData)(this.provider);\n        if (!maxPriorityFeePerGas) {\n          maxPriorityFeePerGas = feeData.maxPriorityFeePerGas ?? undefined;\n        }\n        if (!maxFeePerGas) {\n          maxFeePerGas = feeData.maxFeePerGas ?? undefined;\n          const network = await this.provider.getNetwork();\n          const chainId = network.chainId;\n          if (chainId === _thirdweb_dev_chains__WEBPACK_IMPORTED_MODULE_10__.Celo.chainId || chainId === _thirdweb_dev_chains__WEBPACK_IMPORTED_MODULE_10__.CeloAlfajoresTestnet.chainId || chainId === _thirdweb_dev_chains__WEBPACK_IMPORTED_MODULE_10__.CeloBaklavaTestnet.chainId) {\n            maxPriorityFeePerGas = maxFeePerGas;\n          }\n        }\n      }\n    }\n    if (!maxFeePerGas || !maxPriorityFeePerGas) {\n      throw new Error(\"maxFeePerGas or maxPriorityFeePerGas could not be calculated, please pass them explicitely\");\n    }\n    const [sender, nonce] = await Promise.all([this.getAccountAddress(), info.nonce ? Promise.resolve(info.nonce) : this.getNonce()]);\n    const initCode = await this.getInitCode();\n    const value = parseNumber(info.value) ?? ethers__WEBPACK_IMPORTED_MODULE_7__.BigNumber.from(0);\n    const callData = options?.batchData ? info.data : await this.prepareExecute(info.target, value, info.data).then(async tx => {\n      if (!info.gasLimit) {\n        // estimate gas on the inner transactions to simulate\n        // bundler would not revert otherwise\n        await this.provider.estimateGas({\n          from: sender,\n          to: info.target,\n          data: info.data,\n          value: value\n        });\n      }\n      return tx.encode();\n    });\n    const partialOp = {\n      sender,\n      nonce,\n      initCode,\n      callData,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      callGasLimit: ethers__WEBPACK_IMPORTED_MODULE_7__.BigNumber.from(1000000),\n      verificationGasLimit: ethers__WEBPACK_IMPORTED_MODULE_7__.BigNumber.from(1000000),\n      preVerificationGas: ethers__WEBPACK_IMPORTED_MODULE_7__.BigNumber.from(1000000),\n      paymasterAndData: \"0x\",\n      signature: DUMMY_SIGNATURE\n    };\n\n    // paymaster data + maybe used for estimation as well\n    const gasless = options?.gasless !== undefined ? options.gasless : this.gasless;\n    const useErc20Paymaster = this.erc20PaymasterAddress && this.erc20TokenAddress && (await this.isAccountApproved());\n    if (useErc20Paymaster) {\n      partialOp.paymasterAndData = this.erc20PaymasterAddress;\n      let estimates;\n      try {\n        estimates = await httpRpcClient.estimateUserOpGas(partialOp);\n      } catch (error) {\n        throw this.unwrapBundlerError(error);\n      }\n      partialOp.callGasLimit = estimates.callGasLimit;\n      partialOp.verificationGasLimit = estimates.verificationGasLimit;\n      partialOp.preVerificationGas = estimates.preVerificationGas;\n    } else if (gasless) {\n      const paymasterResult = await this.paymasterAPI.getPaymasterAndData(partialOp);\n      const paymasterAndData = paymasterResult.paymasterAndData;\n      if (paymasterAndData && paymasterAndData !== \"0x\") {\n        partialOp.paymasterAndData = paymasterAndData;\n      }\n      // paymaster can have the gas limits in the response\n      if (paymasterResult.callGasLimit && paymasterResult.verificationGasLimit && paymasterResult.preVerificationGas) {\n        partialOp.callGasLimit = ethers__WEBPACK_IMPORTED_MODULE_7__.BigNumber.from(paymasterResult.callGasLimit);\n        partialOp.verificationGasLimit = ethers__WEBPACK_IMPORTED_MODULE_7__.BigNumber.from(paymasterResult.verificationGasLimit);\n        partialOp.preVerificationGas = ethers__WEBPACK_IMPORTED_MODULE_7__.BigNumber.from(paymasterResult.preVerificationGas);\n      } else {\n        // otherwise fallback to bundler for gas limits\n        let estimates;\n        try {\n          estimates = await httpRpcClient.estimateUserOpGas(partialOp);\n        } catch (error) {\n          throw this.unwrapBundlerError(error);\n        }\n        partialOp.callGasLimit = estimates.callGasLimit;\n        partialOp.verificationGasLimit = estimates.verificationGasLimit;\n        partialOp.preVerificationGas = estimates.preVerificationGas;\n        // need paymaster to re-sign after estimates\n        if (paymasterAndData && paymasterAndData !== \"0x\") {\n          const paymasterResult2 = await this.paymasterAPI.getPaymasterAndData(partialOp);\n          if (paymasterResult2.paymasterAndData && paymasterResult2.paymasterAndData !== \"0x\") {\n            partialOp.paymasterAndData = paymasterResult2.paymasterAndData;\n          }\n        }\n      }\n    } else {\n      // query bundler for gas limits\n      let estimates;\n      try {\n        estimates = await httpRpcClient.estimateUserOpGas(partialOp);\n      } catch (error) {\n        throw this.unwrapBundlerError(error);\n      }\n      partialOp.callGasLimit = estimates.callGasLimit;\n      partialOp.verificationGasLimit = estimates.verificationGasLimit;\n      partialOp.preVerificationGas = estimates.preVerificationGas;\n    }\n    return {\n      ...partialOp,\n      signature: \"\"\n    };\n  }\n\n  /**\n   * Sign the filled userOp.\n   * @param userOp - The UserOperation to sign (with signature field ignored)\n   */\n  async signUserOp(userOp) {\n    const userOpHash = await this.getUserOpHash(userOp);\n    const signature = await this.signUserOpHash(userOpHash);\n    return {\n      ...userOp,\n      signature\n    };\n  }\n\n  /**\n   * get the transaction that has this userOpHash mined, or throws if not found\n   * @param userOpHash - returned by sendUserOpToBundler (or by getUserOpHash..)\n   * @param timeout - stop waiting after this timeout\n   * @param interval - time to wait between polls.\n   * @returns The transaction receipt, or an error if timed out.\n   */\n  async getUserOpReceipt(httpRpcClient, userOpHash) {\n    let timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 120000;\n    let interval = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1000;\n    const endtime = Date.now() + timeout;\n    while (Date.now() < endtime) {\n      const userOpReceipt = await httpRpcClient.getUserOperationReceipt(userOpHash);\n      if (userOpReceipt) {\n        // avoid desync with current provider state\n        return await this.provider.waitForTransaction(userOpReceipt.receipt.transactionHash);\n      }\n      await new Promise(resolve => setTimeout(resolve, interval));\n    }\n    throw new Error(\"Timeout waiting for userOp to be mined\");\n  }\n  unwrapBundlerError(error) {\n    const message = error?.error?.message || error.error || error.message || error;\n    return new Error(message);\n  }\n}\nfunction parseNumber(a) {\n  if (!a || a === \"\") {\n    return null;\n  }\n  return ethers__WEBPACK_IMPORTED_MODULE_7__.BigNumber.from(a.toString());\n}\n\nclass AccountAPI extends BaseAccountAPI {\n  constructor(params, originalProvider) {\n    super({\n      ...params,\n      provider: originalProvider\n    });\n    this.params = params;\n    // Technically dont need the signer here, but we need to encode/estimate gas with it so a signer is required\n    // We don't want to use the localSigner directly since it might be connected to another chain\n    // so we just use the public hardhat pkey instead\n    this.sdk = _thirdweb_dev_sdk__WEBPACK_IMPORTED_MODULE_8__.ThirdwebSDK.fromPrivateKey(_thirdweb_dev_sdk__WEBPACK_IMPORTED_MODULE_8__.LOCAL_NODE_PKEY, params.chain, {\n      clientId: params.clientId,\n      secretKey: params.secretKey,\n      // @ts-expect-error expected chain type error\n      supportedChains: typeof params.chain === \"object\" ? [params.chain] : undefined\n    });\n  }\n  async getChainId() {\n    return await this.provider.getNetwork().then(n => n.chainId);\n  }\n  async getAccountContract() {\n    if (!this.accountContract) {\n      if (this.params.accountInfo?.abi) {\n        this.accountContract = await this.sdk.getContract(await this.getAccountAddress(), this.params.accountInfo.abi);\n      } else {\n        this.accountContract = await this.sdk.getContract(await this.getAccountAddress(), _dist_utils_f58e7acc_browser_esm_js__WEBPACK_IMPORTED_MODULE_9__.A);\n      }\n    }\n    return this.accountContract;\n  }\n  async getAccountInitCode() {\n    const factory = await this.getFactoryContract();\n    const localSigner = await this.params.localSigner.getAddress();\n    const tx = await this.params.factoryInfo.createAccount(factory, localSigner);\n    return ethers__WEBPACK_IMPORTED_MODULE_7__.utils.hexConcat([factory.getAddress(), tx.encode()]);\n  }\n  async getFactoryContract() {\n    if (this.factoryContract) {\n      return this.factoryContract;\n    }\n    if (this.params.factoryInfo?.abi) {\n      this.factoryContract = await this.sdk.getContract(this.params.factoryAddress, this.params.factoryInfo.abi);\n    } else {\n      this.factoryContract = await this.sdk.getContract(this.params.factoryAddress);\n    }\n    return this.factoryContract;\n  }\n  async getCounterFactualAddress() {\n    if (this.params.accountAddress) {\n      return this.params.accountAddress;\n    }\n    const factory = await this.getFactoryContract();\n    const localSigner = await this.params.localSigner.getAddress();\n    return this.params.factoryInfo.getAccountAddress(factory, localSigner);\n  }\n  async getNonce() {\n    if (await this.checkAccountPhantom()) {\n      return ethers__WEBPACK_IMPORTED_MODULE_7__.BigNumber.from(0);\n    }\n    const accountContract = await this.getAccountContract();\n    return this.params.accountInfo.getNonce(accountContract);\n  }\n  async prepareExecute(target, value, data) {\n    const accountContract = await this.getAccountContract();\n    return this.params.accountInfo.execute(accountContract, target, value, data);\n  }\n  async prepareExecuteBatch(targets, values, datas) {\n    const accountContract = await this.getAccountContract();\n    return accountContract.prepare(\"executeBatch\", [targets, values, datas]);\n  }\n  async signUserOpHash(userOpHash) {\n    return await this.params.localSigner.signMessage(ethers__WEBPACK_IMPORTED_MODULE_7__.utils.arrayify(userOpHash));\n  }\n  async isAcountDeployed() {\n    return !(await this.checkAccountPhantom());\n  }\n  async isAccountApproved() {\n    if (!this.params.erc20PaymasterAddress || !this.params.erc20TokenAddress) {\n      return true;\n    }\n    const swAddress = await this.getCounterFactualAddress();\n    const ERC20Abi = (await __webpack_require__.e(/*! import() */ \"node_modules_thirdweb-dev_react_node_modules_thirdweb-dev_contracts-js_dist_abis_IERC20_json\").then(__webpack_require__.t.bind(__webpack_require__, /*! @thirdweb-dev/contracts-js/dist/abis/IERC20.json */ \"./node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC20.json\", 19))).default;\n    const erc20Token = await this.sdk.getContract(this.params.erc20TokenAddress, ERC20Abi);\n    const allowance = await erc20Token.call(\"allowance\", [swAddress, this.params.erc20PaymasterAddress]);\n    return allowance.gte(ethers__WEBPACK_IMPORTED_MODULE_7__.BigNumber.from(2).pow(96).sub(1));\n  }\n  async createApproveTx() {\n    if (await this.isAccountApproved()) {\n      return undefined;\n    }\n    const amountToApprove = ethers__WEBPACK_IMPORTED_MODULE_7__.BigNumber.from(2).pow(96).sub(1);\n    const ethersSigner = new ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.Wallet(_thirdweb_dev_sdk__WEBPACK_IMPORTED_MODULE_8__.LOCAL_NODE_PKEY, this.provider);\n    const erc20Contract = new ethers__WEBPACK_IMPORTED_MODULE_7__.Contract(this.params.erc20TokenAddress, [\"function approve(address spender, uint256 amount) public returns (bool)\"], ethersSigner);\n    const tx = {\n      to: this.params.erc20TokenAddress,\n      from: await this.getAccountAddress(),\n      value: 0,\n      data: erc20Contract.interface.encodeFunctionData(\"approve\", [this.params.erc20PaymasterAddress, amountToApprove])\n    };\n    return tx;\n  }\n}\n\nclass SmartWalletConnector extends _dist_connector_05689d68_browser_esm_js__WEBPACK_IMPORTED_MODULE_11__.C {\n  constructor(config) {\n    super();\n    this.config = config;\n  }\n  async initialize(params) {\n    const config = this.config;\n    const originalProvider = (0,_thirdweb_dev_sdk__WEBPACK_IMPORTED_MODULE_8__.getChainProvider)(config.chain, {\n      clientId: config.clientId,\n      secretKey: config.secretKey\n    });\n    this.chainId = (await originalProvider.getNetwork()).chainId;\n    const bundlerUrl = this.config.bundlerUrl || `https://${this.chainId}.bundler.thirdweb.com`;\n    const paymasterUrl = this.config.paymasterUrl || `https://${this.chainId}.bundler.thirdweb.com`;\n    const entryPointAddress = config.entryPointAddress || _dist_utils_f58e7acc_browser_esm_js__WEBPACK_IMPORTED_MODULE_9__.f;\n    const localSigner = await params.personalWallet.getSigner();\n    const providerConfig = {\n      chain: config.chain,\n      localSigner,\n      entryPointAddress,\n      bundlerUrl,\n      paymasterAPI: this.config.paymasterAPI ? this.config.paymasterAPI : getVerifyingPaymaster(paymasterUrl, entryPointAddress, this.config.clientId, this.config.secretKey),\n      gasless: config.gasless,\n      factoryAddress: config.factoryAddress || _dist_utils_f58e7acc_browser_esm_js__WEBPACK_IMPORTED_MODULE_9__.D,\n      accountAddress: params.accountAddress,\n      factoryInfo: {\n        createAccount: config.factoryInfo?.createAccount || this.defaultFactoryInfo().createAccount,\n        getAccountAddress: config.factoryInfo?.getAccountAddress || this.defaultFactoryInfo().getAccountAddress,\n        abi: config.factoryInfo?.abi\n      },\n      accountInfo: {\n        execute: config.accountInfo?.execute || this.defaultAccountInfo().execute,\n        getNonce: config.accountInfo?.getNonce || this.defaultAccountInfo().getNonce,\n        abi: config.accountInfo?.abi\n      },\n      clientId: config.clientId,\n      secretKey: config.secretKey,\n      erc20PaymasterAddress: config.erc20PaymasterAddress,\n      erc20TokenAddress: config.erc20TokenAddress\n    };\n    this.personalWallet = params.personalWallet;\n    const accountApi = new AccountAPI(providerConfig, originalProvider);\n    this.aaProvider = create4337Provider(providerConfig, accountApi, originalProvider, this.chainId);\n    this.accountApi = accountApi;\n  }\n  async connect(connectionArgs) {\n    await this.initialize(connectionArgs);\n    return await this.getAddress();\n  }\n  getProvider() {\n    if (!this.aaProvider) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    return Promise.resolve(this.aaProvider);\n  }\n  async getSigner() {\n    if (!this.aaProvider) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    return Promise.resolve(this.aaProvider.getSigner());\n  }\n  async getAddress() {\n    const signer = await this.getSigner();\n    return signer.getAddress();\n  }\n  async isConnected() {\n    try {\n      const address = await this.getAddress();\n      return !!address;\n    } catch (e) {\n      return false;\n    }\n  }\n  async disconnect() {\n    this.personalWallet = undefined;\n    this.aaProvider = undefined;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  async switchChain(chainId) {\n    const provider = await this.getProvider();\n    const currentChainId = (await provider.getNetwork()).chainId;\n    if (currentChainId !== chainId) {\n      // only throw if actually trying to switch chains\n      throw new Error(\"Not supported.\");\n    }\n  }\n  setupListeners() {\n    return Promise.resolve();\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  updateChains(chains) {}\n\n  /**\n   * Check whether the connected signer can execute a given transaction using the smart wallet.\n   * @param transaction - The transaction to execute using the smart wallet.\n   * @returns whether the connected signer can execute the transaction using the smart wallet.\n   */\n  async hasPermissionToExecute(transaction) {\n    const accountContract = await this.getAccountContract();\n    const signer = await this.getSigner();\n    const signerAddress = await signer.getAddress();\n    const restrictions = (await accountContract.account.getAllSigners()).filter(item => ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.utils.getAddress(item.signer) === ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.utils.getAddress(signerAddress))[0]?.permissions;\n    if (!restrictions) {\n      return false;\n    }\n    return restrictions.approvedCallTargets.includes(transaction.getTarget());\n  }\n\n  /// PREPARED TRANSACTIONS\n\n  /**\n   * Send a single transaction without waiting for confirmations\n   * @param transaction - the transaction to send\n   * @param config - optional the transaction configuration\n   * @returns The awaitable transaction\n   */\n  async send(transaction, options) {\n    const signer = await this.getSigner();\n    return signer.sendTransaction({\n      to: transaction.getTarget(),\n      data: transaction.encode(),\n      value: await transaction.getValue()\n    }, options);\n  }\n\n  /**\n   * Execute a single transaction (waiting for confirmations)\n   * @param transaction - The transaction to execute\n   * @returns The transaction receipt\n   */\n  async execute(transaction, options) {\n    const tx = await this.send(transaction, options);\n    const receipt = await tx.wait();\n    return {\n      receipt\n    };\n  }\n  async sendBatch(transactions, options) {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    const signer = await this.getSigner();\n    const {\n      tx,\n      batchData\n    } = await this.prepareBatchTx(transactions);\n    return await signer.sendTransaction({\n      to: await signer.getAddress(),\n      data: tx.encode(),\n      value: 0\n    }, {\n      ...options,\n      batchData\n    });\n  }\n\n  /**\n   * Execute multiple transactions in a single batch\n   * @param transactions - The transactions to execute\n   * @returns The transaction receipt\n   */\n  async executeBatch(transactions, options) {\n    const tx = await this.sendBatch(transactions, options);\n    const receipt = await tx.wait();\n    return {\n      receipt\n    };\n  }\n\n  /// RAW TRANSACTIONS\n\n  async sendRaw(transaction, options) {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    const signer = await this.getSigner();\n    return signer.sendTransaction(transaction, options);\n  }\n  async executeRaw(transaction, options) {\n    const tx = await this.sendRaw(transaction, options);\n    const receipt = await tx.wait();\n    return {\n      receipt\n    };\n  }\n  async sendBatchRaw(transactions, options) {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    const signer = await this.getSigner();\n    const batch = await this.prepareBatchRaw(transactions);\n    return signer.sendTransaction({\n      to: await signer.getAddress(),\n      data: batch.tx.encode(),\n      value: 0\n    }, {\n      ...options,\n      batchData: batch.batchData // batched tx flag\n    });\n  }\n  async executeBatchRaw(transactions, options) {\n    const tx = await this.sendBatchRaw(transactions, options);\n    const receipt = await tx.wait();\n    return {\n      receipt\n    };\n  }\n\n  /// ESTIMATION\n\n  async estimate(transaction, options) {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    return this.estimateTx({\n      target: transaction.getTarget(),\n      data: transaction.encode(),\n      value: await transaction.getValue(),\n      gasLimit: await transaction.getOverrides().gasLimit,\n      maxFeePerGas: await transaction.getOverrides().maxFeePerGas,\n      maxPriorityFeePerGas: await transaction.getOverrides().maxPriorityFeePerGas,\n      nonce: await transaction.getOverrides().nonce\n    }, options);\n  }\n  async estimateRaw(transaction, options) {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    const tx = await ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.utils.resolveProperties(transaction);\n    return this.estimateTx({\n      target: tx.to || ethers__WEBPACK_IMPORTED_MODULE_7__.constants.AddressZero,\n      data: tx.data?.toString() || \"\",\n      value: tx.value || ethers__WEBPACK_IMPORTED_MODULE_7__.BigNumber.from(0),\n      gasLimit: tx.gasLimit,\n      maxFeePerGas: tx.maxFeePerGas,\n      maxPriorityFeePerGas: tx.maxPriorityFeePerGas,\n      nonce: tx.nonce\n    }, options);\n  }\n  async estimateBatch(transactions, options) {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    const {\n      tx,\n      batchData\n    } = await this.prepareBatchTx(transactions);\n    return this.estimateTx({\n      target: tx.getTarget(),\n      data: tx.encode(),\n      value: await tx.getValue(),\n      gasLimit: await tx.getOverrides().gasLimit,\n      maxFeePerGas: await tx.getOverrides().maxFeePerGas,\n      maxPriorityFeePerGas: await tx.getOverrides().maxPriorityFeePerGas,\n      nonce: await tx.getOverrides().nonce\n    }, {\n      ...options,\n      batchData\n    });\n  }\n  async estimateBatchRaw(transactions, options) {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    const {\n      tx,\n      batchData\n    } = await this.prepareBatchRaw(transactions);\n    return this.estimateTx({\n      target: tx.getTarget(),\n      data: tx.encode(),\n      value: await tx.getValue(),\n      gasLimit: await tx.getOverrides().gasLimit,\n      maxFeePerGas: await tx.getOverrides().maxFeePerGas,\n      maxPriorityFeePerGas: await tx.getOverrides().maxPriorityFeePerGas,\n      nonce: await tx.getOverrides().nonce\n    }, {\n      ...options,\n      batchData\n    });\n  }\n\n  //// DEPLOYMENT\n\n  /**\n   * Manually deploy the smart wallet contract. If already deployed this will throw an error.\n   * Note that this is not necessary as the smart wallet will be deployed automatically on the first transaction the user makes.\n   * @returns The transaction receipt\n   */\n  async deploy(options) {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    const signer = await this.getSigner();\n    const tx = await signer.sendTransaction({\n      to: await signer.getAddress(),\n      data: \"0x\"\n    }, {\n      ...options,\n      batchData: {\n        targets: [],\n        data: [],\n        values: []\n      } // batched tx flag to avoid hitting the Router fallback method\n    });\n    const receipt = await tx.wait();\n    return {\n      receipt\n    };\n  }\n\n  /**\n   * Check if the smart wallet contract is deployed\n   * @returns true if the smart wallet contract is deployed\n   */\n  async isDeployed() {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    return await this.accountApi.isAcountDeployed();\n  }\n  async deployIfNeeded(options) {\n    const isDeployed = await this.isDeployed();\n    if (!isDeployed) {\n      await this.deploy(options);\n    }\n  }\n\n  //// PERMISSIONS\n\n  async grantPermissions(target, permissions) {\n    const accountContract = await this.getAccountContract();\n    return accountContract.account.grantPermissions(target, permissions);\n  }\n  async revokePermissions(target) {\n    const accountContract = await this.getAccountContract();\n    return accountContract.account.revokeAccess(target);\n  }\n  async addAdmin(target) {\n    const accountContract = await this.getAccountContract();\n    return accountContract.account.grantAdminPermissions(target);\n  }\n  async removeAdmin(target) {\n    const accountContract = await this.getAccountContract();\n    return accountContract.account.revokeAdminPermissions(target);\n  }\n  async getAllActiveSigners() {\n    const isDeployed = await this.isDeployed();\n    if (isDeployed) {\n      const accountContract = await this.getAccountContract();\n      return accountContract.account.getAllAdminsAndSigners();\n    } else {\n      const personalWallet = await this.personalWallet?.getSigner();\n      if (!personalWallet) {\n        throw new Error(\"Personal wallet not connected\");\n      }\n      return [{\n        isAdmin: true,\n        signer: await personalWallet.getAddress(),\n        permissions: {\n          startDate: new Date(0),\n          expirationDate: new Date(0),\n          nativeTokenLimitPerTransaction: ethers__WEBPACK_IMPORTED_MODULE_7__.BigNumber.from(0),\n          approvedCallTargets: []\n        }\n      }];\n    }\n  }\n\n  /**\n   * Get the underlying account contract of the smart wallet.\n   * @returns The account contract of the smart wallet.\n   */\n  async getAccountContract() {\n    // getting a new instance everytime\n    // to avoid caching issues pre/post deployment\n    const sdk = _thirdweb_dev_sdk__WEBPACK_IMPORTED_MODULE_8__.ThirdwebSDK.fromSigner(await this.getSigner(), this.config.chain, {\n      clientId: this.config.clientId,\n      secretKey: this.config.secretKey\n    });\n    if (this.config.accountInfo?.abi) {\n      return sdk.getContract(await this.getAddress(), this.config.accountInfo.abi);\n    } else {\n      return sdk.getContract(await this.getAddress(), _dist_utils_f58e7acc_browser_esm_js__WEBPACK_IMPORTED_MODULE_9__.A);\n    }\n  }\n\n  /**\n   * Get the underlying account factory contract of the smart wallet.\n   * @returns The account factory contract.\n   */\n  async getFactoryContract() {\n    if (!this.config.factoryAddress) {\n      throw new Error(\"Factory address not set!\");\n    }\n    const sdk = _thirdweb_dev_sdk__WEBPACK_IMPORTED_MODULE_8__.ThirdwebSDK.fromSigner(await this.getSigner(), this.config.chain, {\n      clientId: this.config.clientId,\n      secretKey: this.config.secretKey\n    });\n    if (this.config.factoryInfo?.abi) {\n      return sdk.getContract(this.config.factoryAddress, this.config.factoryInfo.abi);\n    }\n    return sdk.getContract(this.config.factoryAddress);\n  }\n  defaultFactoryInfo() {\n    return {\n      createAccount: async (factory, owner) => {\n        return factory.prepare(\"createAccount\", [owner, ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.utils.toUtf8Bytes(\"\")]);\n      },\n      getAccountAddress: async (factory, owner) => {\n        return await factory.call(\"getAddress\", [owner, ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.utils.toUtf8Bytes(\"\")]);\n      }\n    };\n  }\n  defaultAccountInfo() {\n    return {\n      execute: async (account, target, value, data) => {\n        return account.prepare(\"execute\", [target, value, data]);\n      },\n      getNonce: async account => {\n        return account.call(\"getNonce\", []);\n      }\n    };\n  }\n\n  /// PRIVATE METHODS\n\n  async estimateTx(tx, options) {\n    if (!this.accountApi || !this.aaProvider) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    let deployGasLimit = ethers__WEBPACK_IMPORTED_MODULE_7__.BigNumber.from(0);\n    const [provider, isDeployed] = await Promise.all([this.getProvider(), this.isDeployed()]);\n    if (!isDeployed) {\n      deployGasLimit = await this.estimateDeploymentGasLimit();\n    }\n    const [userOp, gasPrice] = await Promise.all([this.accountApi.createUnsignedUserOp(this.aaProvider.httpRpcClient, tx, options), (0,_thirdweb_dev_sdk__WEBPACK_IMPORTED_MODULE_8__.getGasPrice)(provider)]);\n    const resolved = await ethers__WEBPACK_IMPORTED_MODULE_7__.utils.resolveProperties(userOp);\n    const transactionGasLimit = ethers__WEBPACK_IMPORTED_MODULE_7__.BigNumber.from(resolved.callGasLimit);\n    const transactionCost = transactionGasLimit.mul(gasPrice);\n    const deployCost = deployGasLimit.mul(gasPrice);\n    const totalCost = deployCost.add(transactionCost);\n    return {\n      ether: ethers__WEBPACK_IMPORTED_MODULE_7__.utils.formatEther(totalCost),\n      wei: totalCost,\n      details: {\n        deployGasLimit,\n        transactionGasLimit,\n        gasPrice,\n        transactionCost,\n        deployCost,\n        totalCost\n      }\n    };\n  }\n  async estimateDeploymentGasLimit() {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    const initCode = await this.accountApi.getInitCode();\n    const [initGas, verificationGasLimit] = await Promise.all([this.accountApi.estimateCreationGas(initCode), this.accountApi.getVerificationGasLimit()]);\n    return ethers__WEBPACK_IMPORTED_MODULE_7__.BigNumber.from(verificationGasLimit).add(initGas);\n  }\n  async prepareBatchRaw(transactions) {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    const resolvedTxs = await Promise.all(transactions.map(transaction => ethers__WEBPACK_IMPORTED_MODULE_7__.ethers.utils.resolveProperties(transaction)));\n    const targets = resolvedTxs.map(tx => tx.to || ethers__WEBPACK_IMPORTED_MODULE_7__.constants.AddressZero);\n    const data = resolvedTxs.map(tx => tx.data || \"0x\");\n    const values = resolvedTxs.map(tx => tx.value || ethers__WEBPACK_IMPORTED_MODULE_7__.BigNumber.from(0));\n    return {\n      tx: await this.accountApi.prepareExecuteBatch(targets, values, data),\n      batchData: {\n        targets,\n        data,\n        values\n      }\n    };\n  }\n  async prepareBatchTx(transactions) {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    const targets = transactions.map(tx => tx.getTarget());\n    const data = transactions.map(tx => tx.encode());\n    const values = await Promise.all(transactions.map(tx => tx.getValue()));\n    return {\n      tx: await this.accountApi.prepareExecuteBatch(targets, values, data),\n      batchData: {\n        targets,\n        data,\n        values\n      }\n    };\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRoaXJkd2ViLWRldi9yZWFjdC9ub2RlX21vZHVsZXMvQHRoaXJkd2ViLWRldi93YWxsZXRzL2V2bS9jb25uZWN0b3JzL3NtYXJ0LXdhbGxldC9kaXN0L3RoaXJkd2ViLWRldi13YWxsZXRzLWV2bS1jb25uZWN0b3JzLXNtYXJ0LXdhbGxldC5icm93c2VyLmVzbS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFvRjtBQUNtRjtBQUMzRjtBQUNnQjtBQUN2QjtBQUNxQjtBQUNLO0FBQzJDO0FBQ1g7QUFDa0Q7QUFDM0Y7QUFDL0Q7O0FBRXZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvRUFBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNkMseUJBQXlCO0FBQ3RFOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNkMsNkJBQTZCO0FBQzFFO0FBQ0E7QUFDQSxNQUFNLHdFQUFtQjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdGQUFhO0FBQ3BDLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsVUFBVTtBQUNWLFFBQVEsS0FBSztBQUNiO0FBQ0EsUUFBUSw0RUFBSztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLDhDQUE4QyxrQkFBa0IsSUFBSSxNQUFNO0FBQzFFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGtEQUFjO0FBQ3hEO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxRUFBc0I7QUFDdEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsTUFBTTtBQUNOLHNEQUFzRCxrRUFBZ0I7QUFDdEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFFQUFzQjtBQUN0QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsNERBQXdCO0FBQ2hGLE9BQU87QUFDUDtBQUNBLHdEQUF3RCw0REFBd0I7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixrREFBYztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9JQUFvSSw4REFBVztBQUMvSSwyQkFBMkIsMkRBQXVCO0FBQ2xELGdDQUFnQyxrREFBYztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEscURBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtEQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsa0VBQThCO0FBQ3hHLG1EQUFtRCx5REFBcUI7QUFDeEU7QUFDQSxxREFBcUQsa0RBQWM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B0aGlyZHdlYi1kZXYvcmVhY3Qvbm9kZV9tb2R1bGVzL0B0aGlyZHdlYi1kZXYvd2FsbGV0cy9ldm0vY29ubmVjdG9ycy9zbWFydC13YWxsZXQvZGlzdC90aGlyZHdlYi1kZXYtd2FsbGV0cy1ldm0tY29ubmVjdG9ycy1zbWFydC13YWxsZXQuYnJvd3Nlci5lc20uanM/ODE0YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDIGFzIENvbm5lY3RvciB9IGZyb20gJy4uLy4uLy4uLy4uL2Rpc3QvY29ubmVjdG9yLTA1Njg5ZDY4LmJyb3dzZXIuZXNtLmpzJztcbmltcG9ydCB7IGggYXMgaGV4bGlmeVVzZXJPcCwgRCBhcyBERUJVRywgciBhcyByYW5kb21Ob25jZSwgSCBhcyBIdHRwUnBjQ2xpZW50LCBnIGFzIGdldFVzZXJPcEhhc2hWMDYgfSBmcm9tICcuLi8uLi8uLi8uLi9kaXN0L2h0dHAtcnBjLWNsaWVudC0wYTA3OWU4MC5icm93c2VyLmVzbS5qcyc7XG5pbXBvcnQgeyBpIGFzIGlzVHdVcmwgfSBmcm9tICcuLi8uLi8uLi8uLi9kaXN0L3VybC1hNDUyMTliZC5icm93c2VyLmVzbS5qcyc7XG5pbXBvcnQgeyBzIGFzIHNldEFuYWx5dGljc0hlYWRlcnMgfSBmcm9tICcuLi8uLi8uLi8uLi9kaXN0L2hlYWRlcnMtNzMzYTgxOTkuYnJvd3Nlci5lc20uanMnO1xuaW1wb3J0IHsgRW50cnlQb2ludF9fZmFjdG9yeSB9IGZyb20gJ0BhY2NvdW50LWFic3RyYWN0aW9uL2NvbnRyYWN0cyc7XG5pbXBvcnQgeyB1dGlscywgU2lnbmVyLCBldGhlcnMsIHByb3ZpZGVycywgQ29udHJhY3QsIEJpZ051bWJlciwgY29uc3RhbnRzIH0gZnJvbSAnZXRoZXJzJztcbmltcG9ydCB7IF8gYXMgX2RlZmluZVByb3BlcnR5IH0gZnJvbSAnLi4vLi4vLi4vLi4vZGlzdC9kZWZpbmVQcm9wZXJ0eS0zNTBmYzUwOC5icm93c2VyLmVzbS5qcyc7XG5pbXBvcnQgeyBzaWduVHlwZWREYXRhSW50ZXJuYWwsIGdldER5bmFtaWNGZWVEYXRhLCBUaGlyZHdlYlNESywgTE9DQUxfTk9ERV9QS0VZLCBnZXRDaGFpblByb3ZpZGVyLCBnZXRHYXNQcmljZSB9IGZyb20gJ0B0aGlyZHdlYi1kZXYvc2RrJztcbmltcG9ydCB7IGNoYWluSWRUb1RoaXJkd2ViUnBjIH0gZnJvbSAnLi4vLi4vLi4vd2FsbGV0cy9hYnN0cmFjdC9kaXN0L3RoaXJkd2ViLWRldi13YWxsZXRzLWV2bS13YWxsZXRzLWFic3RyYWN0LmJyb3dzZXIuZXNtLmpzJztcbmltcG9ydCB7IGMgYXMgY2hlY2tDb250cmFjdFdhbGxldFNpZ25hdHVyZSwgQSBhcyBBQ0NPVU5UX0NPUkVfQUJJLCBmIGFzIEVOVFJZUE9JTlRfQUREUkVTUywgRCBhcyBERUZBVUxUX0ZBQ1RPUllfQUREUkVTUyB9IGZyb20gJy4uLy4uLy4uLy4uL2Rpc3QvdXRpbHMtZjU4ZTdhY2MuYnJvd3Nlci5lc20uanMnO1xuaW1wb3J0IHsgQ2VsbywgQ2Vsb0FsZmFqb3Jlc1Rlc3RuZXQsIENlbG9CYWtsYXZhVGVzdG5ldCB9IGZyb20gJ0B0aGlyZHdlYi1kZXYvY2hhaW5zJztcbmltcG9ydCAnZXZlbnRlbWl0dGVyMyc7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG4vKipcbiAqIGFuIEFQSSB0byBleHRlcm5hbCBhIFVzZXJPcGVyYXRpb24gd2l0aCBwYXltYXN0ZXIgaW5mb1xuICovXG5jbGFzcyBQYXltYXN0ZXJBUEkge31cblxuY2xhc3MgVmVyaWZ5aW5nUGF5bWFzdGVyQVBJIGV4dGVuZHMgUGF5bWFzdGVyQVBJIHtcbiAgY29uc3RydWN0b3IocGF5bWFzdGVyVXJsLCBlbnRyeVBvaW50LCBjbGllbnRJZCwgc2VjcmV0S2V5KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnBheW1hc3RlclVybCA9IHBheW1hc3RlclVybDtcbiAgICB0aGlzLmVudHJ5UG9pbnQgPSBlbnRyeVBvaW50O1xuICAgIHRoaXMuY2xpZW50SWQgPSBjbGllbnRJZDtcbiAgICB0aGlzLnNlY3JldEtleSA9IHNlY3JldEtleTtcbiAgfVxuICBhc3luYyBnZXRQYXltYXN0ZXJBbmREYXRhKHVzZXJPcCkge1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgIH07XG4gICAgaWYgKGlzVHdVcmwodGhpcy5wYXltYXN0ZXJVcmwpKSB7XG4gICAgICBpZiAodGhpcy5zZWNyZXRLZXkgJiYgdGhpcy5jbGllbnRJZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgdXNlIGJvdGggc2VjcmV0IGtleSBhbmQgY2xpZW50IElELiBQbGVhc2UgdXNlIHNlY3JldEtleSBmb3Igc2VydmVyLXNpZGUgYXBwbGljYXRpb25zIGFuZCBjbGllbnRJZCBmb3IgY2xpZW50LXNpZGUgYXBwbGljYXRpb25zLlwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNlY3JldEtleSkge1xuICAgICAgICBoZWFkZXJzW1wieC1zZWNyZXQta2V5XCJdID0gdGhpcy5zZWNyZXRLZXk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuY2xpZW50SWQpIHtcbiAgICAgICAgaGVhZGVyc1tcIngtY2xpZW50LWlkXCJdID0gdGhpcy5jbGllbnRJZDtcbiAgICAgICAgY29uc3QgYnVuZGxlSWQgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBcIkFQUF9CVU5ETEVfSURcIiBpbiBnbG9iYWxUaGlzID8gZ2xvYmFsVGhpcy5BUFBfQlVORExFX0lEIDogdW5kZWZpbmVkO1xuICAgICAgICBpZiAoYnVuZGxlSWQpIHtcbiAgICAgICAgICBoZWFkZXJzW1wieC1idW5kbGUtaWRcIl0gPSBidW5kbGVJZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBEYXNoYm9hcmQgdG9rZW4uXG4gICAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIgJiYgXCJUV19BVVRIX1RPS0VOXCIgaW4gZ2xvYmFsVGhpcyAmJiB0eXBlb2YgZ2xvYmFsVGhpcy5UV19BVVRIX1RPS0VOID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGhlYWRlcnNbXCJhdXRob3JpemF0aW9uXCJdID0gYEJlYXJlciAke2dsb2JhbFRoaXMuVFdfQVVUSF9UT0tFTn1gO1xuICAgICAgfVxuXG4gICAgICAvLyBDTEkgdG9rZW4uXG4gICAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIgJiYgXCJUV19DTElfQVVUSF9UT0tFTlwiIGluIGdsb2JhbFRoaXMgJiYgdHlwZW9mIGdsb2JhbFRoaXMuVFdfQ0xJX0FVVEhfVE9LRU4gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaGVhZGVyc1tcImF1dGhvcml6YXRpb25cIl0gPSBgQmVhcmVyICR7Z2xvYmFsVGhpcy5UV19DTElfQVVUSF9UT0tFTn1gO1xuICAgICAgICBoZWFkZXJzW1wieC1hdXRob3JpemUtd2FsbGV0XCJdID0gXCJ0cnVlXCI7XG4gICAgICB9XG4gICAgICBzZXRBbmFseXRpY3NIZWFkZXJzKGhlYWRlcnMpO1xuICAgIH1cblxuICAgIC8vIEFzayB0aGUgcGF5bWFzdGVyIHRvIHNpZ24gdGhlIHRyYW5zYWN0aW9uIGFuZCByZXR1cm4gYSB2YWxpZCBwYXltYXN0ZXJBbmREYXRhIHZhbHVlLlxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godGhpcy5wYXltYXN0ZXJVcmwsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICBpZDogMSxcbiAgICAgICAgbWV0aG9kOiBcInBtX3Nwb25zb3JVc2VyT3BlcmF0aW9uXCIsXG4gICAgICAgIHBhcmFtczogW2F3YWl0IGhleGxpZnlVc2VyT3AodXNlck9wKSwgdGhpcy5lbnRyeVBvaW50XVxuICAgICAgfSlcbiAgICB9KTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgY29uc3QgZXJyb3IgPSByZXMuZXJyb3IgfHwgcmVzcG9uc2Uuc3RhdHVzVGV4dDtcbiAgICAgIGNvbnN0IGNvZGUgPSByZXMuY29kZSB8fCBcIlVOS05PV05cIjtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUGF5bWFzdGVyIGVycm9yOiAke2Vycm9yfVxuU3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31cbkNvZGU6ICR7Y29kZX1gKTtcbiAgICB9XG4gICAgaWYgKERFQlVHKSB7XG4gICAgICBjb25zb2xlLmRlYnVnKFwiUGF5bWFzdGVyIHJlc3VsdDpcIiwgcmVzKTtcbiAgICB9XG4gICAgaWYgKHJlcy5yZXN1bHQpIHtcbiAgICAgIC8vIHNvbWUgcGF5bWFzdGVycyByZXR1cm4gYSBzdHJpbmcsIHNvbWUgcmV0dXJuIGFuIG9iamVjdCB3aXRoIG1vcmUgZGF0YVxuICAgICAgaWYgKHR5cGVvZiByZXMucmVzdWx0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcGF5bWFzdGVyQW5kRGF0YTogcmVzLnJlc3VsdFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGVycm9yID0gcmVzLmVycm9yPy5tZXNzYWdlIHx8IHJlcy5lcnJvciB8fCByZXNwb25zZS5zdGF0dXNUZXh0IHx8IFwidW5rbm93biBlcnJvclwiO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBQYXltYXN0ZXIgZXJyb3IgZnJvbSAke3RoaXMucGF5bWFzdGVyVXJsfTogJHtlcnJvcn1gKTtcbiAgICB9XG4gIH1cbn1cbmNvbnN0IGdldFZlcmlmeWluZ1BheW1hc3RlciA9IChwYXltYXN0ZXJVcmwsIGVudHJ5UG9pbnQsIGNsaWVudElkLCBzZWNyZXRLZXkpID0+IG5ldyBWZXJpZnlpbmdQYXltYXN0ZXJBUEkocGF5bWFzdGVyVXJsLCBlbnRyeVBvaW50LCBjbGllbnRJZCwgc2VjcmV0S2V5KTtcblxuLyoqXG4gKiBUaGlzIGNsYXNzIGVuY2Fwc3VsYXRlcyBFdGhlcnMuanMgbGlzdGVuZXIgZnVuY3Rpb24gYW5kIG5lY2Vzc2FyeSBVc2VyT3BlcmF0aW9uIGRldGFpbHMgdG9cbiAqIGRpc2NvdmVyIGEgVHJhbnNhY3Rpb25SZWNlaXB0IGZvciB0aGUgb3BlcmF0aW9uLlxuICpcbiAqIFRPRE8gcmVmYWN0b3IgdGhpcyB0byBhIHNpbXBsZSBldmVudCBsaXN0ZW5lciBvbiB0aGUgZW50cnkgcG9pbnRcbiAqL1xuY2xhc3MgVXNlck9wZXJhdGlvbkV2ZW50TGlzdGVuZXIge1xuICBjb25zdHJ1Y3RvcihyZXNvbHZlLCByZWplY3QsIGVudHJ5UG9pbnQsIHNlbmRlciwgdXNlck9wSGFzaCwgbm9uY2UsIHRpbWVvdXQpIHtcbiAgICB0aGlzLnJlc29sdmUgPSByZXNvbHZlO1xuICAgIHRoaXMucmVqZWN0ID0gcmVqZWN0O1xuICAgIHRoaXMuZW50cnlQb2ludCA9IGVudHJ5UG9pbnQ7XG4gICAgdGhpcy5zZW5kZXIgPSBzZW5kZXI7XG4gICAgdGhpcy51c2VyT3BIYXNoID0gdXNlck9wSGFzaDtcbiAgICB0aGlzLm5vbmNlID0gbm9uY2U7XG4gICAgdGhpcy50aW1lb3V0ID0gdGltZW91dDtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZXNvbHZlZFwiLCBmYWxzZSk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1taXN1c2VkLXByb21pc2VzXG4gICAgdGhpcy5ib3VuZExpc2VuZXIgPSB0aGlzLmxpc3RlbmVyQ2FsbGJhY2suYmluZCh0aGlzKTtcbiAgfVxuICBzdGFydCgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW1pc3VzZWQtcHJvbWlzZXNcbiAgICBjb25zdCBmaWx0ZXIgPSB0aGlzLmVudHJ5UG9pbnQuZmlsdGVycy5Vc2VyT3BlcmF0aW9uRXZlbnQodGhpcy51c2VyT3BIYXNoKTtcbiAgICAvLyBsaXN0ZW5lciB0YWtlcyB0aW1lLi4uIGZpcnN0IHF1ZXJ5IGRpcmVjdGx5OlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbWlzdXNlZC1wcm9taXNlc1xuICAgIHNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5lbnRyeVBvaW50LnF1ZXJ5RmlsdGVyKGZpbHRlciwgLTEwKTsgLy8gbG9vayBhdCBsYXN0IDEwIGJsb2Nrc1xuICAgICAgaWYgKHJlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZvaWQgdGhpcy5saXN0ZW5lckNhbGxiYWNrKHJlc1swXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVudHJ5UG9pbnQub25jZShmaWx0ZXIsIHRoaXMuYm91bmRMaXNlbmVyKTtcbiAgICAgIH1cbiAgICB9LCAxMDApO1xuICB9XG4gIHN0b3AoKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1taXN1c2VkLXByb21pc2VzXG4gICAgdGhpcy5lbnRyeVBvaW50Lm9mZihcIlVzZXJPcGVyYXRpb25FdmVudFwiLCB0aGlzLmJvdW5kTGlzZW5lcik7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIGFzeW5jIGxpc3RlbmVyQ2FsbGJhY2soKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHBhcmFtID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgcGFyYW1bX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIC8vIFRPRE8gY2xlYW4gdGhpcyB1cC4uXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1yZXN0LXBhcmFtc1xuICAgIGNvbnN0IGV2ZW50ID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcbiAgICBpZiAoIWV2ZW50LmFyZ3MpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJnb3QgZXZlbnQgd2l0aG91dCBhcmdzXCIsIGV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gVE9ETzogY2FuIHRoaXMgaGFwcGVuPyB3ZSByZWdpc3RlciB0byBldmVudCBieSB1c2VyT3BIYXNoLi5cbiAgICBpZiAoZXZlbnQuYXJncy51c2VyT3BIYXNoICE9PSB0aGlzLnVzZXJPcEhhc2gpIHtcbiAgICAgIGNvbnNvbGUubG9nKGA9PSBldmVudCB3aXRoIHdyb25nIHVzZXJPcEhhc2g6IHNlbmRlci9ub25jZTogZXZlbnQuJHtldmVudC5hcmdzLnNlbmRlcn1AJHtldmVudC5hcmdzLm5vbmNlLnRvU3RyaW5nKCl9IT0gdXNlck9wLiR7dGhpcy5zZW5kZXJ9QCR7cGFyc2VJbnQodGhpcy5ub25jZT8udG9TdHJpbmcoKSl9YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRyYW5zYWN0aW9uUmVjZWlwdCA9IGF3YWl0IGV2ZW50LmdldFRyYW5zYWN0aW9uUmVjZWlwdCgpO1xuXG4gICAgLy8gYmVmb3JlIHJldHVybmluZyB0aGUgcmVjZWlwdCwgdXBkYXRlIHRoZSBzdGF0dXMgZnJvbSB0aGUgZXZlbnQuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zdHJpY3QtYm9vbGVhbi1leHByZXNzaW9uc1xuICAgIGlmICghZXZlbnQuYXJncy5zdWNjZXNzKSB7XG4gICAgICBhd2FpdCB0aGlzLmV4dHJhY3RGYWlsdXJlUmVhc29uKHRyYW5zYWN0aW9uUmVjZWlwdCk7XG4gICAgfVxuICAgIHRoaXMuc3RvcCgpO1xuICAgIHRoaXMucmVzb2x2ZSh0cmFuc2FjdGlvblJlY2VpcHQpO1xuICAgIHRoaXMucmVzb2x2ZWQgPSB0cnVlO1xuICB9XG4gIGFzeW5jIGV4dHJhY3RGYWlsdXJlUmVhc29uKHJlY2VpcHQpIHtcbiAgICByZWNlaXB0LnN0YXR1cyA9IDA7XG4gICAgY29uc3QgcmV2ZXJ0UmVhc29uRXZlbnRzID0gYXdhaXQgdGhpcy5lbnRyeVBvaW50LnF1ZXJ5RmlsdGVyKHRoaXMuZW50cnlQb2ludC5maWx0ZXJzLlVzZXJPcGVyYXRpb25SZXZlcnRSZWFzb24odGhpcy51c2VyT3BIYXNoLCB0aGlzLnNlbmRlciksIHJlY2VpcHQuYmxvY2tIYXNoKTtcbiAgICBpZiAocmV2ZXJ0UmVhc29uRXZlbnRzWzBdKSB7XG4gICAgICBsZXQgbWVzc2FnZSA9IHJldmVydFJlYXNvbkV2ZW50c1swXS5hcmdzLnJldmVydFJlYXNvbjtcbiAgICAgIGlmIChtZXNzYWdlLnN0YXJ0c1dpdGgoXCIweDA4YzM3OWEwXCIpKSB7XG4gICAgICAgIC8vIEVycm9yKHN0cmluZylcbiAgICAgICAgbWVzc2FnZSA9IHV0aWxzLmRlZmF1bHRBYmlDb2Rlci5kZWNvZGUoW1wic3RyaW5nXCJdLCBcIjB4XCIgKyBtZXNzYWdlLnN1YnN0cmluZygxMCkpLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlamVjdChuZXcgRXJyb3IoYFVzZXJPcCBmYWlsZWQgd2l0aCByZWFzb246ICR7bWVzc2FnZX1gKSk7XG4gICAgfVxuICB9XG59XG5cbmNsYXNzIEVSQzQzMzdFdGhlcnNTaWduZXIgZXh0ZW5kcyBTaWduZXIge1xuICAvLyBUT0RPOiB3ZSBoYXZlICdlcmM0MzM3cHJvdmlkZXInLCByZW1vdmUgc2hhcmVkIGRlcGVuZGVuY2llcyBvciBhdm9pZCB0d28td2F5IHJlZmVyZW5jZVxuICBjb25zdHJ1Y3Rvcihjb25maWcsIG9yaWdpbmFsU2lnbmVyLCBlcmM0MzM3cHJvdmlkZXIsIGh0dHBScGNDbGllbnQsIHNtYXJ0QWNjb3VudEFQSSkge1xuICAgIHN1cGVyKCk7XG4gICAgdXRpbHMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJwcm92aWRlclwiLCBlcmM0MzM3cHJvdmlkZXIpO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMub3JpZ2luYWxTaWduZXIgPSBvcmlnaW5hbFNpZ25lcjtcbiAgICB0aGlzLmVyYzQzMzdwcm92aWRlciA9IGVyYzQzMzdwcm92aWRlcjtcbiAgICB0aGlzLmh0dHBScGNDbGllbnQgPSBodHRwUnBjQ2xpZW50O1xuICAgIHRoaXMuc21hcnRBY2NvdW50QVBJID0gc21hcnRBY2NvdW50QVBJO1xuICAgIHRoaXMuYXBwcm92aW5nID0gZmFsc2U7XG4gIH1cbiAgLy8gVGhpcyBvbmUgaXMgY2FsbGVkIGJ5IENvbnRyYWN0LiBJdCBzaWducyB0aGUgcmVxdWVzdCBhbmQgcGFzc2VzIGluIHRvIFByb3ZpZGVyIHRvIGJlIHNlbnQuXG4gIGFzeW5jIHNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgb3B0aW9ucykge1xuICAgIGlmICghdGhpcy5hcHByb3ZpbmcpIHtcbiAgICAgIHRoaXMuYXBwcm92aW5nID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy5zbWFydEFjY291bnRBUEkuY3JlYXRlQXBwcm92ZVR4KCk7XG4gICAgICBpZiAodHgpIHtcbiAgICAgICAgYXdhaXQgKGF3YWl0IHRoaXMuc2VuZFRyYW5zYWN0aW9uKHR4KSkud2FpdCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5hcHByb3ZpbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgdHggPSBhd2FpdCBldGhlcnMudXRpbHMucmVzb2x2ZVByb3BlcnRpZXModHJhbnNhY3Rpb24pO1xuICAgIGF3YWl0IHRoaXMudmVyaWZ5QWxsTmVjZXNzYXJ5RmllbGRzKHR4KTtcbiAgICBjb25zdCBtdWx0aWRpbWVuc2lvbmFsTm9uY2UgPSByYW5kb21Ob25jZSgpO1xuICAgIGNvbnN0IHVuc2lnbmVkID0gYXdhaXQgdGhpcy5zbWFydEFjY291bnRBUEkuY3JlYXRlVW5zaWduZWRVc2VyT3AodGhpcy5odHRwUnBjQ2xpZW50LCB7XG4gICAgICB0YXJnZXQ6IHR4LnRvIHx8IFwiXCIsXG4gICAgICBkYXRhOiB0eC5kYXRhPy50b1N0cmluZygpIHx8IFwiMHhcIixcbiAgICAgIHZhbHVlOiB0eC52YWx1ZSxcbiAgICAgIGdhc0xpbWl0OiB0eC5nYXNMaW1pdCxcbiAgICAgIG5vbmNlOiBtdWx0aWRpbWVuc2lvbmFsTm9uY2UsXG4gICAgICBtYXhGZWVQZXJHYXM6IHR4Lm1heEZlZVBlckdhcyxcbiAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiB0eC5tYXhQcmlvcml0eUZlZVBlckdhc1xuICAgIH0sIG9wdGlvbnMpO1xuICAgIGNvbnN0IHVzZXJPcGVyYXRpb24gPSBhd2FpdCB0aGlzLnNtYXJ0QWNjb3VudEFQSS5zaWduVXNlck9wKHVuc2lnbmVkKTtcbiAgICBjb25zdCB0cmFuc2FjdGlvblJlc3BvbnNlID0gYXdhaXQgdGhpcy5lcmM0MzM3cHJvdmlkZXIuY29uc3RydWN0VXNlck9wVHJhbnNhY3Rpb25SZXNwb25zZSh1c2VyT3BlcmF0aW9uKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5odHRwUnBjQ2xpZW50LnNlbmRVc2VyT3BUb0J1bmRsZXIodXNlck9wZXJhdGlvbik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IHRoaXMudW53cmFwRXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgICAvLyBUT0RPOiBoYW5kbGUgZXJyb3JzIC0gdHJhbnNhY3Rpb24gdGhhdCBpcyBcInJlamVjdGVkXCIgYnkgYnVuZGxlciBpcyBfbm90IGxpa2VseV8gdG8gZXZlciByZXNvbHZlIGl0cyBcIndhaXQoKVwiXG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uUmVzcG9uc2U7XG4gIH1cbiAgdW53cmFwRXJyb3IoZXJyb3JJbikge1xuICAgIHRyeSB7XG4gICAgICBsZXQgZXJyb3JNc2cgPSBcIlVua25vd24gRXJyb3JcIjtcbiAgICAgIGlmIChlcnJvckluLmVycm9yKSB7XG4gICAgICAgIGVycm9yTXNnID0gYFRoZSBidW5kbGVyIGhhcyBmYWlsZWQgdG8gaW5jbHVkZSBVc2VyT3BlcmF0aW9uIGluIGEgYmF0Y2g6ICR7ZXJyb3JJbi5lcnJvcn1gO1xuICAgICAgfSBlbHNlIGlmIChlcnJvckluLmJvZHkgJiYgdHlwZW9mIGVycm9ySW4uYm9keSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCBlcnJvckJvZHkgPSBKU09OLnBhcnNlKGVycm9ySW4uYm9keSk7XG4gICAgICAgIGNvbnN0IGVycm9yU3RhdHVzID0gZXJyb3JJbi5zdGF0dXMgfHwgXCJVTktOT1dOXCI7XG4gICAgICAgIGNvbnN0IGVycm9yQ29kZSA9IGVycm9yQm9keT8uY29kZSB8fCBcIlVOS05PV05cIjtcbiAgICAgICAgbGV0IGZhaWxlZE9wTWVzc2FnZSA9IGVycm9yQm9keT8uZXJyb3I/Lm1lc3NhZ2UgfHwgZXJyb3JCb2R5Py5lcnJvcj8uZGF0YSB8fCBlcnJvckJvZHk/LmVycm9yIHx8IGVycm9ySW4ucmVhc29uO1xuICAgICAgICBpZiAoZmFpbGVkT3BNZXNzYWdlPy5pbmNsdWRlcyhcIkZhaWxlZE9wXCIpKSB7XG4gICAgICAgICAgbGV0IHBheW1hc3RlckluZm8gPSBcIlwiO1xuICAgICAgICAgIC8vIFRPRE86IGJldHRlciBlcnJvciBleHRyYWN0aW9uIG1ldGhvZHMgd2lsbCBiZSBuZWVkZWRcbiAgICAgICAgICBjb25zdCBtYXRjaGVkID0gZmFpbGVkT3BNZXNzYWdlLm1hdGNoKC9GYWlsZWRPcFxcKCguKilcXCkvKTtcbiAgICAgICAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICAgICAgY29uc3Qgc3BsaXQgPSBtYXRjaGVkWzFdLnNwbGl0KFwiLFwiKTtcbiAgICAgICAgICAgIHBheW1hc3RlckluZm8gPSBgKHBheW1hc3RlciBhZGRyZXNzOiAke3NwbGl0WzFdfSlgO1xuICAgICAgICAgICAgZmFpbGVkT3BNZXNzYWdlID0gc3BsaXRbMl07XG4gICAgICAgICAgfVxuICAgICAgICAgIGVycm9yTXNnID0gYFRoZSBidW5kbGVyIGhhcyBmYWlsZWQgdG8gaW5jbHVkZSBVc2VyT3BlcmF0aW9uIGluIGEgYmF0Y2g6ICR7ZmFpbGVkT3BNZXNzYWdlfSAke3BheW1hc3RlckluZm99YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlcnJvck1zZyA9IGBSUEMgZXJyb3I6ICR7ZmFpbGVkT3BNZXNzYWdlfVxuU3RhdHVzOiAke2Vycm9yU3RhdHVzfVxuQ29kZTogJHtlcnJvckNvZGV9YDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoZXJyb3JNc2cpO1xuICAgICAgZXJyb3Iuc3RhY2sgPSBlcnJvckluLnN0YWNrO1xuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7fVxuICAgIHJldHVybiBlcnJvckluO1xuICB9XG4gIGFzeW5jIHZlcmlmeUFsbE5lY2Vzc2FyeUZpZWxkcyh0cmFuc2FjdGlvblJlcXVlc3QpIHtcbiAgICBpZiAoIXRyYW5zYWN0aW9uUmVxdWVzdC50bykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBjYWxsIHRhcmdldFwiKTtcbiAgICB9XG4gICAgaWYgKCF0cmFuc2FjdGlvblJlcXVlc3QuZGF0YSAmJiAhdHJhbnNhY3Rpb25SZXF1ZXN0LnZhbHVlKSB7XG4gICAgICAvLyBUQkQ6IGJhbm5pbmcgbm8tb3AgVXNlck9wcyBzZWVtcyB0byBtYWtlIHNlbnNlIG9uIHByb3ZpZGVyIGxldmVsXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGNhbGwgZGF0YSBvciB2YWx1ZVwiKTtcbiAgICB9XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIGNvbm5lY3QocHJvdmlkZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjaGFuZ2luZyBwcm92aWRlcnMgaXMgbm90IHN1cHBvcnRlZFwiKTtcbiAgfVxuICBhc3luYyBnZXRBZGRyZXNzKCkge1xuICAgIGlmICghdGhpcy5hZGRyZXNzKSB7XG4gICAgICB0aGlzLmFkZHJlc3MgPSBhd2FpdCB0aGlzLmVyYzQzMzdwcm92aWRlci5nZXRTZW5kZXJBY2NvdW50QWRkcmVzcygpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5hZGRyZXNzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpZ24gYSBtZXNzYWdlIGFuZCByZXR1cm4gdGhlIHNpZ25hdHVyZVxuICAgKi9cbiAgYXN5bmMgc2lnbk1lc3NhZ2UobWVzc2FnZSkge1xuICAgIC8vIERlcGxveSBzbWFydCB3YWxsZXQgaWYgbmVlZGVkXG4gICAgY29uc3QgaXNOb3REZXBsb3llZCA9IGF3YWl0IHRoaXMuc21hcnRBY2NvdW50QVBJLmNoZWNrQWNjb3VudFBoYW50b20oKTtcbiAgICBpZiAoaXNOb3REZXBsb3llZCkge1xuICAgICAgY29uc29sZS5sb2coXCJBY2NvdW50IGNvbnRyYWN0IG5vdCBkZXBsb3llZCB5ZXQuIERlcGxveWluZyBhY2NvdW50IGJlZm9yZSBzaWduaW5nIG1lc3NhZ2VcIik7XG4gICAgICBjb25zdCB0eCA9IGF3YWl0IHRoaXMuc2VuZFRyYW5zYWN0aW9uKHtcbiAgICAgICAgdG86IGF3YWl0IHRoaXMuZ2V0QWRkcmVzcygpLFxuICAgICAgICBkYXRhOiBcIjB4XCJcbiAgICAgIH0pO1xuICAgICAgYXdhaXQgdHgud2FpdCgpO1xuICAgIH1cbiAgICBjb25zdCBbY2hhaW5JZCwgYWRkcmVzc10gPSBhd2FpdCBQcm9taXNlLmFsbChbdGhpcy5nZXRDaGFpbklkKCksIHRoaXMuZ2V0QWRkcmVzcygpXSk7XG4gICAgY29uc3Qgb3JpZ2luYWxNc2dIYXNoID0gdXRpbHMuaGFzaE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgbGV0IGZhY3RvcnlTdXBwb3J0czcxMjtcbiAgICBsZXQgc2lnbmF0dXJlO1xuICAgIGNvbnN0IHJwY1VybCA9IGNoYWluSWRUb1RoaXJkd2ViUnBjKGNoYWluSWQsIHRoaXMuY29uZmlnLmNsaWVudElkKTtcbiAgICBjb25zdCBoZWFkZXJzID0ge307XG4gICAgaWYgKGlzVHdVcmwocnBjVXJsKSkge1xuICAgICAgY29uc3QgYnVuZGxlSWQgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBcIkFQUF9CVU5ETEVfSURcIiBpbiBnbG9iYWxUaGlzID8gZ2xvYmFsVGhpcy5BUFBfQlVORExFX0lEIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKHRoaXMuY29uZmlnLnNlY3JldEtleSkge1xuICAgICAgICBoZWFkZXJzW1wieC1zZWNyZXQta2V5XCJdID0gdGhpcy5jb25maWcuc2VjcmV0S2V5O1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmNvbmZpZy5jbGllbnRJZCkge1xuICAgICAgICBoZWFkZXJzW1wieC1jbGllbnQtaWRcIl0gPSB0aGlzLmNvbmZpZy5jbGllbnRJZDtcbiAgICAgICAgaWYgKGJ1bmRsZUlkKSB7XG4gICAgICAgICAgaGVhZGVyc1tcIngtYnVuZGxlLWlkXCJdID0gYnVuZGxlSWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gRGFzaGJvYXJkIHRva2VuXG4gICAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIgJiYgXCJUV19BVVRIX1RPS0VOXCIgaW4gZ2xvYmFsVGhpcyAmJiB0eXBlb2YgZ2xvYmFsVGhpcy5UV19BVVRIX1RPS0VOID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGhlYWRlcnNbXCJhdXRob3JpemF0aW9uXCJdID0gYEJlYXJlciAke2dsb2JhbFRoaXMuVFdfQVVUSF9UT0tFTn1gO1xuICAgICAgfVxuXG4gICAgICAvLyBDTEkgdG9rZW5cbiAgICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBcIlRXX0NMSV9BVVRIX1RPS0VOXCIgaW4gZ2xvYmFsVGhpcyAmJiB0eXBlb2YgZ2xvYmFsVGhpcy5UV19DTElfQVVUSF9UT0tFTiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBoZWFkZXJzW1wiYXV0aG9yaXphdGlvblwiXSA9IGBCZWFyZXIgJHtnbG9iYWxUaGlzLlRXX0NMSV9BVVRIX1RPS0VOfWA7XG4gICAgICAgIGhlYWRlcnNbXCJ4LWF1dGhvcml6ZS13YWxsZXRcIl0gPSBcInRydWVcIjtcbiAgICAgIH1cbiAgICAgIHNldEFuYWx5dGljc0hlYWRlcnMoaGVhZGVycyk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBwcm92aWRlciA9IG5ldyBwcm92aWRlcnMuU3RhdGljSnNvblJwY1Byb3ZpZGVyKHtcbiAgICAgICAgdXJsOiBycGNVcmwsXG4gICAgICAgIGhlYWRlcnNcbiAgICAgIH0sIGNoYWluSWQpO1xuICAgICAgY29uc3Qgd2FsbGV0Q29udHJhY3QgPSBuZXcgQ29udHJhY3QoYWRkcmVzcywgW1wiZnVuY3Rpb24gZ2V0TWVzc2FnZUhhc2goYnl0ZXMzMiBfaGFzaCkgcHVibGljIHZpZXcgcmV0dXJucyAoYnl0ZXMzMilcIl0sIHByb3ZpZGVyKTtcbiAgICAgIC8vIGlmIHRoaXMgZmFpbHMgaXQncyBhIHByZSA3MTIgZmFjdG9yeVxuICAgICAgYXdhaXQgd2FsbGV0Q29udHJhY3QuZ2V0TWVzc2FnZUhhc2gob3JpZ2luYWxNc2dIYXNoKTtcbiAgICAgIGZhY3RvcnlTdXBwb3J0czcxMiA9IHRydWU7XG4gICAgfSBjYXRjaCB7XG4gICAgICBmYWN0b3J5U3VwcG9ydHM3MTIgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGZhY3RvcnlTdXBwb3J0czcxMikge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2lnblR5cGVkRGF0YUludGVybmFsKHRoaXMsIHtcbiAgICAgICAgbmFtZTogXCJBY2NvdW50XCIsXG4gICAgICAgIHZlcnNpb246IFwiMVwiLFxuICAgICAgICBjaGFpbklkLFxuICAgICAgICB2ZXJpZnlpbmdDb250cmFjdDogYWRkcmVzc1xuICAgICAgfSwge1xuICAgICAgICBBY2NvdW50TWVzc2FnZTogW3tcbiAgICAgICAgICBuYW1lOiBcIm1lc3NhZ2VcIixcbiAgICAgICAgICB0eXBlOiBcImJ5dGVzXCJcbiAgICAgICAgfV1cbiAgICAgIH0sIHtcbiAgICAgICAgbWVzc2FnZTogdXRpbHMuZGVmYXVsdEFiaUNvZGVyLmVuY29kZShbXCJieXRlczMyXCJdLCBbb3JpZ2luYWxNc2dIYXNoXSlcbiAgICAgIH0pO1xuICAgICAgc2lnbmF0dXJlID0gcmVzdWx0LnNpZ25hdHVyZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2lnbmF0dXJlID0gYXdhaXQgdGhpcy5vcmlnaW5hbFNpZ25lci5zaWduTWVzc2FnZShtZXNzYWdlKTtcbiAgICB9XG4gICAgY29uc3QgaXNWYWxpZCA9IGF3YWl0IGNoZWNrQ29udHJhY3RXYWxsZXRTaWduYXR1cmUobWVzc2FnZSwgc2lnbmF0dXJlLCBhZGRyZXNzLCBjaGFpbklkLCB0aGlzLmNvbmZpZy5jbGllbnRJZCwgdGhpcy5jb25maWcuc2VjcmV0S2V5KTtcbiAgICBpZiAoaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIHNpZ25hdHVyZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIHZlcmlmeSBzaWduYXR1cmUgb24gc21hcnQgYWNjb3VudCwgcGxlYXNlIG1ha2Ugc3VyZSB0aGUgc21hcnQgYWNjb3VudCBpcyBkZXBsb3llZCBhbmQgdGhlIHNpZ25hdHVyZSBpcyB2YWxpZC5cIik7XG4gICAgfVxuICB9XG4gIGFzeW5jIHNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgb3B0aW9ucykge1xuICAgIGNvbnN0IHR4ID0gYXdhaXQgZXRoZXJzLnV0aWxzLnJlc29sdmVQcm9wZXJ0aWVzKHRyYW5zYWN0aW9uKTtcbiAgICBhd2FpdCB0aGlzLnZlcmlmeUFsbE5lY2Vzc2FyeUZpZWxkcyh0eCk7XG4gICAgY29uc3QgbXVsdGlkaW1lbnNpb25hbE5vbmNlID0gcmFuZG9tTm9uY2UoKTtcbiAgICBjb25zdCB1bnNpZ25lZCA9IGF3YWl0IHRoaXMuc21hcnRBY2NvdW50QVBJLmNyZWF0ZVVuc2lnbmVkVXNlck9wKHRoaXMuaHR0cFJwY0NsaWVudCwge1xuICAgICAgdGFyZ2V0OiB0eC50byB8fCBcIlwiLFxuICAgICAgZGF0YTogdHguZGF0YT8udG9TdHJpbmcoKSB8fCBcIjB4XCIsXG4gICAgICB2YWx1ZTogdHgudmFsdWUsXG4gICAgICBnYXNMaW1pdDogdHguZ2FzTGltaXQsXG4gICAgICBub25jZTogbXVsdGlkaW1lbnNpb25hbE5vbmNlXG4gICAgfSwgb3B0aW9ucyk7XG4gICAgY29uc3QgdXNlck9wZXJhdGlvbiA9IGF3YWl0IHRoaXMuc21hcnRBY2NvdW50QVBJLnNpZ25Vc2VyT3AodW5zaWduZWQpO1xuICAgIGNvbnN0IHVzZXJPcFN0cmluZyA9IEpTT04uc3RyaW5naWZ5KGF3YWl0IGhleGxpZnlVc2VyT3AodXNlck9wZXJhdGlvbikpO1xuICAgIHJldHVybiB1c2VyT3BTdHJpbmc7XG4gIH1cbn1cblxuY2xhc3MgRVJDNDMzN0V0aGVyc1Byb3ZpZGVyIGV4dGVuZHMgcHJvdmlkZXJzLkJhc2VQcm92aWRlciB7XG4gIGNvbnN0cnVjdG9yKGNoYWluSWQsIGNvbmZpZywgb3JpZ2luYWxTaWduZXIsIG9yaWdpbmFsUHJvdmlkZXIsIGh0dHBScGNDbGllbnQsIGVudHJ5UG9pbnQsIHNtYXJ0QWNjb3VudEFQSSkge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IFwiRVJDLTQzMzcgQ3VzdG9tIE5ldHdvcmtcIixcbiAgICAgIGNoYWluSWRcbiAgICB9KTtcbiAgICB0aGlzLmNoYWluSWQgPSBjaGFpbklkO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMub3JpZ2luYWxTaWduZXIgPSBvcmlnaW5hbFNpZ25lcjtcbiAgICB0aGlzLm9yaWdpbmFsUHJvdmlkZXIgPSBvcmlnaW5hbFByb3ZpZGVyO1xuICAgIHRoaXMuaHR0cFJwY0NsaWVudCA9IGh0dHBScGNDbGllbnQ7XG4gICAgdGhpcy5lbnRyeVBvaW50ID0gZW50cnlQb2ludDtcbiAgICB0aGlzLnNtYXJ0QWNjb3VudEFQSSA9IHNtYXJ0QWNjb3VudEFQSTtcbiAgICB0aGlzLnNpZ25lciA9IG5ldyBFUkM0MzM3RXRoZXJzU2lnbmVyKGNvbmZpZywgb3JpZ2luYWxTaWduZXIsIHRoaXMsIGh0dHBScGNDbGllbnQsIHNtYXJ0QWNjb3VudEFQSSk7XG4gIH1cbiAgZ2V0U2lnbmVyKCkge1xuICAgIHJldHVybiB0aGlzLnNpZ25lcjtcbiAgfVxuICBhc3luYyBwZXJmb3JtKG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgaWYgKG1ldGhvZCA9PT0gXCJzZW5kVHJhbnNhY3Rpb25cIiB8fCBtZXRob2QgPT09IFwiZ2V0VHJhbnNhY3Rpb25SZWNlaXB0XCIpIHtcbiAgICAgIC8vIFRPRE86IGRvIHdlIG5lZWQgJ3BlcmZvcm0nIG1ldGhvZCB0byBiZSBhdmFpbGFibGUgYXQgYWxsP1xuICAgICAgLy8gdGhlcmUgaXMgbm9ib2R5IG91dCB0aGVyZSB0byB1c2UgaXQgZm9yIEVSQy00MzM3IG1ldGhvZHMgeWV0LCB3ZSBoYXZlIG5vdGhpbmcgdG8gb3ZlcnJpZGUgaW4gZmFjdC5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlNob3VsZCBub3QgZ2V0IGhlcmUuIEludmVzdGlnYXRlLlwiKTtcbiAgICB9XG4gICAgaWYgKG1ldGhvZCA9PT0gXCJlc3RpbWF0ZUdhc1wiKSB7XG4gICAgICAvLyBnYXMgZXN0aW1hdGlvbiBkb2VzIG5vdGhpbmcgYXQgdGhpcyBsYXllciwgc2VuZFRyYW5zYWN0aW9uIHdpbGwgZG8gdGhlIGdhcyBlc3RpbWF0aW9uIGZvciB0aGUgdXNlck9wXG4gICAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20oNTAwMDAwKTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMub3JpZ2luYWxQcm92aWRlci5wZXJmb3JtKG1ldGhvZCwgcGFyYW1zKTtcbiAgfVxuICBhc3luYyBnZXRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbkhhc2gpIHtcbiAgICAvLyBUT0RPXG4gICAgcmV0dXJuIGF3YWl0IHN1cGVyLmdldFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uSGFzaCk7XG4gIH1cbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KHRyYW5zYWN0aW9uSGFzaCkge1xuICAgIGNvbnN0IHVzZXJPcEhhc2ggPSBhd2FpdCB0cmFuc2FjdGlvbkhhc2g7XG4gICAgY29uc3Qgc2VuZGVyID0gYXdhaXQgdGhpcy5nZXRTZW5kZXJBY2NvdW50QWRkcmVzcygpO1xuICAgIHJldHVybiBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBuZXcgVXNlck9wZXJhdGlvbkV2ZW50TGlzdGVuZXIocmVzb2x2ZSwgcmVqZWN0LCB0aGlzLmVudHJ5UG9pbnQsIHNlbmRlciwgdXNlck9wSGFzaCkuc3RhcnQoKTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBnZXRTZW5kZXJBY2NvdW50QWRkcmVzcygpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zbWFydEFjY291bnRBUEkuZ2V0QWNjb3VudEFkZHJlc3MoKTtcbiAgfVxuICBhc3luYyB3YWl0Rm9yVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25IYXNoLCBjb25maXJtYXRpb25zLCB0aW1lb3V0KSB7XG4gICAgY29uc3Qgc2VuZGVyID0gYXdhaXQgdGhpcy5nZXRTZW5kZXJBY2NvdW50QWRkcmVzcygpO1xuICAgIHJldHVybiBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBsaXN0ZW5lciA9IG5ldyBVc2VyT3BlcmF0aW9uRXZlbnRMaXN0ZW5lcihyZXNvbHZlLCByZWplY3QsIHRoaXMuZW50cnlQb2ludCwgc2VuZGVyLCB0cmFuc2FjdGlvbkhhc2gsIHVuZGVmaW5lZCwgdGltZW91dCk7XG4gICAgICBsaXN0ZW5lci5zdGFydCgpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gZmFicmljYXRlIGEgcmVzcG9uc2UgaW4gYSBmb3JtYXQgdXNhYmxlIGJ5IGV0aGVycyB1c2Vycy4uLlxuICBhc3luYyBjb25zdHJ1Y3RVc2VyT3BUcmFuc2FjdGlvblJlc3BvbnNlKHVzZXJPcDEpIHtcbiAgICBjb25zdCB1c2VyT3AgPSBhd2FpdCB1dGlscy5yZXNvbHZlUHJvcGVydGllcyh1c2VyT3AxKTtcbiAgICBjb25zdCB1c2VyT3BIYXNoID0gYXdhaXQgdGhpcy5zbWFydEFjY291bnRBUEkuZ2V0VXNlck9wSGFzaCh1c2VyT3ApO1xuICAgIHJldHVybiB7XG4gICAgICBoYXNoOiB1c2VyT3BIYXNoLFxuICAgICAgY29uZmlybWF0aW9uczogMCxcbiAgICAgIGZyb206IHVzZXJPcC5zZW5kZXIsXG4gICAgICBub25jZTogMCxcbiAgICAgIC8vIG5vdCB0aGUgcmVhbCBub25jZSwgYnV0IGdvb2QgZW5vdWdoIGZvciB0aGlzIHB1cnBvc2VcbiAgICAgIGdhc0xpbWl0OiBCaWdOdW1iZXIuZnJvbSh1c2VyT3AuY2FsbEdhc0xpbWl0KSxcbiAgICAgIC8vID8/XG4gICAgICB2YWx1ZTogQmlnTnVtYmVyLmZyb20oMCksXG4gICAgICBkYXRhOiB1dGlscy5oZXhWYWx1ZSh1c2VyT3AuY2FsbERhdGEpLFxuICAgICAgLy8gc2hvdWxkIGV4dHJhY3QgdGhlIGFjdHVhbCBjYWxsZWQgbWV0aG9kIGZyb20gdGhpcyBcImV4ZWNGcm9tRW50cnlQb2ludCgpXCIgY2FsbFxuICAgICAgY2hhaW5JZDogdGhpcy5jaGFpbklkLFxuICAgICAgd2FpdDogYXN5bmMgY29uZmlybWF0aW9ucyA9PiB7XG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uUmVjZWlwdCA9IGF3YWl0IHRoaXMuc21hcnRBY2NvdW50QVBJLmdldFVzZXJPcFJlY2VpcHQodGhpcy5odHRwUnBjQ2xpZW50LCB1c2VyT3BIYXNoKTtcbiAgICAgICAgaWYgKHVzZXJPcC5pbml0Q29kZS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAvLyBjaGVja2luZyBpZiB0aGUgd2FsbGV0IGhhcyBiZWVuIGRlcGxveWVkIGJ5IHRoZSB0cmFuc2FjdGlvbjsgaXQgbXVzdCBiZSBpZiB3ZSBhcmUgaGVyZVxuICAgICAgICAgIGF3YWl0IHRoaXMuc21hcnRBY2NvdW50QVBJLmNoZWNrQWNjb3VudFBoYW50b20oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJhbnNhY3Rpb25SZWNlaXB0O1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgYXN5bmMgZGV0ZWN0TmV0d29yaygpIHtcbiAgICByZXR1cm4gdGhpcy5vcmlnaW5hbFByb3ZpZGVyLmRldGVjdE5ldHdvcmsoKTtcbiAgfVxufVxuXG4vKipcbiAqIHdyYXAgYW4gZXhpc3RpbmcgcHJvdmlkZXIgdG8gdHVubmVsIHJlcXVlc3RzIHRocm91Z2ggQWNjb3VudCBBYnN0cmFjdGlvbi5cbiAqIEBwYXJhbSBvcmlnaW5hbFByb3ZpZGVyIC0gVGhlIG5vcm1hbCBwcm92aWRlclxuICogQHBhcmFtIGNvbmZpZyAtIHNlZSB7QGxpbmsgQ2xpZW50Q29uZmlnfSBmb3IgbW9yZSBpbmZvXG4gKiBAcGFyYW0gb3JpZ2luYWxTaWduZXIgLSB1c2UgdGhpcyBzaWduZXIgYXMgdGhlIG93bmVyLiBvZiB0aGlzIHdhbGxldC4gQnkgZGVmYXVsdCwgdXNlIHRoZSBwcm92aWRlcidzIHNpZ25lclxuICovXG5mdW5jdGlvbiBjcmVhdGU0MzM3UHJvdmlkZXIoY29uZmlnLCBhY2NvdW50QXBpLCBvcmlnaW5hbFByb3ZpZGVyLCBjaGFpbklkKSB7XG4gIGNvbnN0IGVudHJ5UG9pbnQgPSBFbnRyeVBvaW50X19mYWN0b3J5LmNvbm5lY3QoY29uZmlnLmVudHJ5UG9pbnRBZGRyZXNzLCBvcmlnaW5hbFByb3ZpZGVyKTtcbiAgY29uc3QgaHR0cFJwY0NsaWVudCA9IG5ldyBIdHRwUnBjQ2xpZW50KGNvbmZpZy5idW5kbGVyVXJsLCBjb25maWcuZW50cnlQb2ludEFkZHJlc3MsIGNoYWluSWQsIGNvbmZpZy5jbGllbnRJZCwgY29uZmlnLnNlY3JldEtleSk7XG4gIHJldHVybiBuZXcgRVJDNDMzN0V0aGVyc1Byb3ZpZGVyKGNoYWluSWQsIGNvbmZpZywgY29uZmlnLmxvY2FsU2lnbmVyLCBvcmlnaW5hbFByb3ZpZGVyLCBodHRwUnBjQ2xpZW50LCBlbnRyeVBvaW50LCBhY2NvdW50QXBpKTtcbn1cblxuY29uc3QgRFVNTVlfU0lHTkFUVVJFID0gXCIweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmYwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA3YWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhMWNcIjtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBhbGwgU21hcnQgV2FsbGV0IEVSQy00MzM3IENsaWVudHMgdG8gaW1wbGVtZW50LlxuICogU3ViY2xhc3Mgc2hvdWxkIGluaGVyaXQgNSBtZXRob2RzIHRvIHN1cHBvcnQgYSBzcGVjaWZpYyB3YWxsZXQgY29udHJhY3Q6XG4gKlxuICogLSBnZXRBY2NvdW50SW5pdENvZGUgLSByZXR1cm4gdGhlIHZhbHVlIHRvIHB1dCBpbnRvIHRoZSBcImluaXRDb2RlXCIgZmllbGQsIGlmIHRoZSBhY2NvdW50IGlzIG5vdCB5ZXQgZGVwbG95ZWQuIHNob3VsZCBjcmVhdGUgdGhlIGFjY291bnQgaW5zdGFuY2UgdXNpbmcgYSBmYWN0b3J5IGNvbnRyYWN0LlxuICogLSBnZXROb25jZSAtIHJldHVybiBjdXJyZW50IGFjY291bnQncyBub25jZSB2YWx1ZVxuICogLSBlbmNvZGVFeGVjdXRlIC0gZW5jb2RlIHRoZSBjYWxsIGZyb20gZW50cnlQb2ludCB0aHJvdWdoIG91ciBhY2NvdW50IHRvIHRoZSB0YXJnZXQgY29udHJhY3QuXG4gKiAtIHNpZ25Vc2VyT3BIYXNoIC0gc2lnbiB0aGUgaGFzaCBvZiBhIFVzZXJPcC5cbiAqXG4gKiBUaGUgdXNlciBjYW4gdXNlIHRoZSBmb2xsb3dpbmcgQVBJczpcbiAqIC0gY3JlYXRlVW5zaWduZWRVc2VyT3AgLSBnaXZlbiBcInRhcmdldFwiIGFuZCBcImNhbGxkYXRhXCIsIGZpbGwgdXNlck9wIHRvIHBlcmZvcm0gdGhhdCBvcGVyYXRpb24gZnJvbSB0aGUgYWNjb3VudC5cbiAqIC0gY3JlYXRlU2lnbmVkVXNlck9wIC0gaGVscGVyIHRvIGNhbGwgdGhlIGFib3ZlIGNyZWF0ZVVuc2lnbmVkVXNlck9wLCBhbmQgdGhlbiBleHRyYWN0IHRoZSB1c2VyT3BIYXNoIGFuZCBzaWduIGl0XG4gKi9cbmNsYXNzIEJhc2VBY2NvdW50QVBJIHtcbiAgLy8gZW50cnlQb2ludCBjb25uZWN0ZWQgdG8gXCJ6ZXJvXCIgYWRkcmVzcy4gYWxsb3dlZCB0byBtYWtlIHN0YXRpYyBjYWxscyAoZS5nLiB0byBnZXRTZW5kZXJBZGRyZXNzKVxuXG4gIC8qKlxuICAgKiBiYXNlIGNvbnN0cnVjdG9yLlxuICAgKiBzdWJjbGFzcyBTSE9VTEQgYWRkIHBhcmFtZXRlcnMgdGhhdCBkZWZpbmUgdGhlIG93bmVyIChzaWduZXIpIG9mIHRoaXMgd2FsbGV0XG4gICAqL1xuICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJpc1BoYW50b21cIiwgdHJ1ZSk7XG4gICAgdGhpcy5wcm92aWRlciA9IHBhcmFtcy5wcm92aWRlcjtcbiAgICB0aGlzLmVudHJ5UG9pbnRBZGRyZXNzID0gcGFyYW1zLmVudHJ5UG9pbnRBZGRyZXNzO1xuICAgIHRoaXMuYWNjb3VudEFkZHJlc3MgPSBwYXJhbXMuYWNjb3VudEFkZHJlc3M7XG4gICAgdGhpcy5wYXltYXN0ZXJBUEkgPSBwYXJhbXMucGF5bWFzdGVyQVBJO1xuICAgIHRoaXMuZ2FzbGVzcyA9IHBhcmFtcy5nYXNsZXNzO1xuICAgIHRoaXMuZXJjMjBQYXltYXN0ZXJBZGRyZXNzID0gcGFyYW1zLmVyYzIwUGF5bWFzdGVyQWRkcmVzcztcbiAgICB0aGlzLmVyYzIwVG9rZW5BZGRyZXNzID0gcGFyYW1zLmVyYzIwVG9rZW5BZGRyZXNzO1xuXG4gICAgLy8gZmFjdG9yeSBcImNvbm5lY3RcIiBkZWZpbmUgdGhlIGNvbnRyYWN0IGFkZHJlc3MuIHRoZSBjb250cmFjdCBcImNvbm5lY3RcIiBkZWZpbmVzIHRoZSBcImZyb21cIiBhZGRyZXNzLlxuICAgIHRoaXMuZW50cnlQb2ludFZpZXcgPSBFbnRyeVBvaW50X19mYWN0b3J5LmNvbm5lY3QocGFyYW1zLmVudHJ5UG9pbnRBZGRyZXNzLCBwYXJhbXMucHJvdmlkZXIpLmNvbm5lY3QoZXRoZXJzLmNvbnN0YW50cy5BZGRyZXNzWmVybyk7XG4gIH1cblxuICAvKipcbiAgICogcmV0dXJuIHRoZSB2YWx1ZSB0byBwdXQgaW50byB0aGUgXCJpbml0Q29kZVwiIGZpZWxkLCBpZiB0aGUgY29udHJhY3QgaXMgbm90IHlldCBkZXBsb3llZC5cbiAgICogdGhpcyB2YWx1ZSBob2xkcyB0aGUgXCJmYWN0b3J5XCIgYWRkcmVzcywgZm9sbG93ZWQgYnkgdGhpcyBhY2NvdW50J3MgaW5mb3JtYXRpb25cbiAgICovXG5cbiAgLyoqXG4gICAqIHJldHVybiBjdXJyZW50IGFjY291bnQncyBub25jZS5cbiAgICovXG5cbiAgLyoqXG4gICAqIGVuY29kZSB0aGUgY2FsbCBmcm9tIGVudHJ5UG9pbnQgdGhyb3VnaCBvdXIgYWNjb3VudCB0byB0aGUgdGFyZ2V0IGNvbnRyYWN0LlxuICAgKiBAcGFyYW0gdGFyZ2V0IC0gVGhlIHRhcmdldCBjb250cmFjdCBhZGRyZXNzXG4gICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBzZW5kIHRvIHRoZSB0YXJnZXQgY29udHJhY3RcbiAgICogQHBhcmFtIGRhdGEgLSBUaGUgY2FsbGRhdGEgdG8gc2VuZCB0byB0aGUgdGFyZ2V0IGNvbnRyYWN0XG4gICAqL1xuXG4gIC8qKlxuICAgKiBzaWduIGEgdXNlck9wJ3MgaGFzaCAodXNlck9wSGFzaCkuXG4gICAqIEBwYXJhbSB1c2VyT3BIYXNoIC0gVGhlIGhhc2ggdG8gc2lnblxuICAgKi9cblxuICAvKipcbiAgICogY2FsY3VsYXRlIHRoZSBhY2NvdW50IGFkZHJlc3MgZXZlbiBiZWZvcmUgaXQgaXMgZGVwbG95ZWRcbiAgICovXG5cbiAgLyoqXG4gICAqIGNoZWNrIGlmIHRoZSBjb250cmFjdCBpcyBhbHJlYWR5IGRlcGxveWVkLlxuICAgKi9cbiAgYXN5bmMgY2hlY2tBY2NvdW50UGhhbnRvbSgpIHtcbiAgICBpZiAoIXRoaXMuaXNQaGFudG9tKSB7XG4gICAgICAvLyBhbHJlYWR5IGRlcGxveWVkLiBubyBuZWVkIHRvIGNoZWNrIGFueW1vcmUuXG4gICAgICByZXR1cm4gdGhpcy5pc1BoYW50b207XG4gICAgfVxuICAgIGNvbnN0IHNlbmRlckFkZHJlc3NDb2RlID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXRDb2RlKHRoaXMuZ2V0QWNjb3VudEFkZHJlc3MoKSk7XG4gICAgaWYgKHNlbmRlckFkZHJlc3NDb2RlLmxlbmd0aCA+IDIpIHtcbiAgICAgIHRoaXMuaXNQaGFudG9tID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmlzUGhhbnRvbTtcbiAgfVxuICAvKipcbiAgICogcmV0dXJuIGluaXRDb2RlIHZhbHVlIHRvIGludG8gdGhlIFVzZXJPcC5cbiAgICogKGVpdGhlciBkZXBsb3ltZW50IGNvZGUsIG9yIGVtcHR5IGhleCBpZiBjb250cmFjdCBhbHJlYWR5IGRlcGxveWVkKVxuICAgKi9cbiAgYXN5bmMgZ2V0SW5pdENvZGUoKSB7XG4gICAgaWYgKGF3YWl0IHRoaXMuY2hlY2tBY2NvdW50UGhhbnRvbSgpKSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRBY2NvdW50SW5pdENvZGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIFwiMHhcIjtcbiAgfVxuXG4gIC8qKlxuICAgKiByZXR1cm4gbWF4aW11bSBnYXMgdXNlZCBmb3IgdmVyaWZpY2F0aW9uLlxuICAgKiBOT1RFOiBjcmVhdGVVbnNpZ25lZFVzZXJPcCB3aWxsIGFkZCB0byB0aGlzIHZhbHVlIHRoZSBjb3N0IG9mIGNyZWF0aW9uLCBpZiB0aGUgY29udHJhY3QgaXMgbm90IHlldCBjcmVhdGVkLlxuICAgKi9cbiAgYXN5bmMgZ2V0VmVyaWZpY2F0aW9uR2FzTGltaXQoKSB7XG4gICAgcmV0dXJuIDEwMDAwMDtcbiAgfVxuXG4gIC8qKlxuICAgKiByZXR1cm4gdXNlck9wSGFzaCBmb3Igc2lnbmluZy5cbiAgICogVGhpcyB2YWx1ZSBtYXRjaGVzIGVudHJ5UG9pbnQuZ2V0VXNlck9wSGFzaCAoY2FsY3VsYXRlZCBvZmYtY2hhaW4sIHRvIGF2b2lkIGEgdmlldyBjYWxsKVxuICAgKiBAcGFyYW0gdXNlck9wIC0gdXNlck9wZXJhdGlvbiwgKHNpZ25hdHVyZSBmaWVsZCBpZ25vcmVkKVxuICAgKi9cbiAgYXN5bmMgZ2V0VXNlck9wSGFzaCh1c2VyT3ApIHtcbiAgICBjb25zdCBjaGFpbklkID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXROZXR3b3JrKCkudGhlbihuZXQgPT4gbmV0LmNoYWluSWQpO1xuICAgIHJldHVybiBnZXRVc2VyT3BIYXNoVjA2KHVzZXJPcCwgdGhpcy5lbnRyeVBvaW50QWRkcmVzcywgY2hhaW5JZCk7XG4gIH1cblxuICAvKipcbiAgICogcmV0dXJuIHRoZSBhY2NvdW50J3MgYWRkcmVzcy5cbiAgICogdGhpcyB2YWx1ZSBpcyB2YWxpZCBldmVuIGJlZm9yZSBkZXBsb3lpbmcgdGhlIGNvbnRyYWN0LlxuICAgKi9cbiAgYXN5bmMgZ2V0QWNjb3VudEFkZHJlc3MoKSB7XG4gICAgaWYgKCF0aGlzLnNlbmRlckFkZHJlc3MpIHtcbiAgICAgIGlmICh0aGlzLmFjY291bnRBZGRyZXNzKSB7XG4gICAgICAgIHRoaXMuc2VuZGVyQWRkcmVzcyA9IHRoaXMuYWNjb3VudEFkZHJlc3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNlbmRlckFkZHJlc3MgPSBhd2FpdCB0aGlzLmdldENvdW50ZXJGYWN0dWFsQWRkcmVzcygpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zZW5kZXJBZGRyZXNzO1xuICB9XG4gIGFzeW5jIGVzdGltYXRlQ3JlYXRpb25HYXMoaW5pdENvZGUpIHtcbiAgICBpZiAoIWluaXRDb2RlIHx8IGluaXRDb2RlID09PSBcIjB4XCIpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBjb25zdCBkZXBsb3llckFkZHJlc3MgPSBpbml0Q29kZS5zdWJzdHJpbmcoMCwgNDIpO1xuICAgIGNvbnN0IGRlcGxveWVyQ2FsbERhdGEgPSBcIjB4XCIgKyBpbml0Q29kZS5zdWJzdHJpbmcoNDIpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnByb3ZpZGVyLmVzdGltYXRlR2FzKHtcbiAgICAgIHRvOiBkZXBsb3llckFkZHJlc3MsXG4gICAgICBkYXRhOiBkZXBsb3llckNhbGxEYXRhXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgY3JlYXRlVW5zaWduZWRVc2VyT3AoaHR0cFJwY0NsaWVudCwgaW5mbywgb3B0aW9ucykge1xuICAgIGxldCB7XG4gICAgICBtYXhGZWVQZXJHYXMsXG4gICAgICBtYXhQcmlvcml0eUZlZVBlckdhc1xuICAgIH0gPSBpbmZvO1xuICAgIC8vIGdldCBmZWVzIGZyb20gYnVuZGxlciBpZiBhdmFpbGFibGVcbiAgICBpZiAoaXNUd1VybChodHRwUnBjQ2xpZW50LmJ1bmRsZXJVcmwpKSB7XG4gICAgICBjb25zdCBidW5kbGVyRmVlRGF0YSA9IGF3YWl0IGh0dHBScGNDbGllbnQuZ2V0VXNlck9wZXJhdGlvbkdhc1ByaWNlKCk7XG4gICAgICBtYXhGZWVQZXJHYXMgPSBCaWdOdW1iZXIuZnJvbShidW5kbGVyRmVlRGF0YS5tYXhGZWVQZXJHYXMpO1xuICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBCaWdOdW1iZXIuZnJvbShidW5kbGVyRmVlRGF0YS5tYXhQcmlvcml0eUZlZVBlckdhcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIGJ1bmRsZXIgaXMgbm90IGF2YWlsYWJsZSwgdHJ5IHRvIGdldCBmZWVzIGZyb20gdGhlIG5ldHdvcmsgaWYgbm90IHBhc3NlZCBleHBsaWNpdGx5XG4gICAgICBpZiAoIW1heEZlZVBlckdhcyB8fCAhbWF4UHJpb3JpdHlGZWVQZXJHYXMpIHtcbiAgICAgICAgY29uc3QgZmVlRGF0YSA9IGF3YWl0IGdldER5bmFtaWNGZWVEYXRhKHRoaXMucHJvdmlkZXIpO1xuICAgICAgICBpZiAoIW1heFByaW9yaXR5RmVlUGVyR2FzKSB7XG4gICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBmZWVEYXRhLm1heFByaW9yaXR5RmVlUGVyR2FzID8/IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1heEZlZVBlckdhcykge1xuICAgICAgICAgIG1heEZlZVBlckdhcyA9IGZlZURhdGEubWF4RmVlUGVyR2FzID8/IHVuZGVmaW5lZDtcbiAgICAgICAgICBjb25zdCBuZXR3b3JrID0gYXdhaXQgdGhpcy5wcm92aWRlci5nZXROZXR3b3JrKCk7XG4gICAgICAgICAgY29uc3QgY2hhaW5JZCA9IG5ldHdvcmsuY2hhaW5JZDtcbiAgICAgICAgICBpZiAoY2hhaW5JZCA9PT0gQ2Vsby5jaGFpbklkIHx8IGNoYWluSWQgPT09IENlbG9BbGZham9yZXNUZXN0bmV0LmNoYWluSWQgfHwgY2hhaW5JZCA9PT0gQ2Vsb0Jha2xhdmFUZXN0bmV0LmNoYWluSWQpIHtcbiAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzID0gbWF4RmVlUGVyR2FzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW1heEZlZVBlckdhcyB8fCAhbWF4UHJpb3JpdHlGZWVQZXJHYXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm1heEZlZVBlckdhcyBvciBtYXhQcmlvcml0eUZlZVBlckdhcyBjb3VsZCBub3QgYmUgY2FsY3VsYXRlZCwgcGxlYXNlIHBhc3MgdGhlbSBleHBsaWNpdGVseVwiKTtcbiAgICB9XG4gICAgY29uc3QgW3NlbmRlciwgbm9uY2VdID0gYXdhaXQgUHJvbWlzZS5hbGwoW3RoaXMuZ2V0QWNjb3VudEFkZHJlc3MoKSwgaW5mby5ub25jZSA/IFByb21pc2UucmVzb2x2ZShpbmZvLm5vbmNlKSA6IHRoaXMuZ2V0Tm9uY2UoKV0pO1xuICAgIGNvbnN0IGluaXRDb2RlID0gYXdhaXQgdGhpcy5nZXRJbml0Q29kZSgpO1xuICAgIGNvbnN0IHZhbHVlID0gcGFyc2VOdW1iZXIoaW5mby52YWx1ZSkgPz8gQmlnTnVtYmVyLmZyb20oMCk7XG4gICAgY29uc3QgY2FsbERhdGEgPSBvcHRpb25zPy5iYXRjaERhdGEgPyBpbmZvLmRhdGEgOiBhd2FpdCB0aGlzLnByZXBhcmVFeGVjdXRlKGluZm8udGFyZ2V0LCB2YWx1ZSwgaW5mby5kYXRhKS50aGVuKGFzeW5jIHR4ID0+IHtcbiAgICAgIGlmICghaW5mby5nYXNMaW1pdCkge1xuICAgICAgICAvLyBlc3RpbWF0ZSBnYXMgb24gdGhlIGlubmVyIHRyYW5zYWN0aW9ucyB0byBzaW11bGF0ZVxuICAgICAgICAvLyBidW5kbGVyIHdvdWxkIG5vdCByZXZlcnQgb3RoZXJ3aXNlXG4gICAgICAgIGF3YWl0IHRoaXMucHJvdmlkZXIuZXN0aW1hdGVHYXMoe1xuICAgICAgICAgIGZyb206IHNlbmRlcixcbiAgICAgICAgICB0bzogaW5mby50YXJnZXQsXG4gICAgICAgICAgZGF0YTogaW5mby5kYXRhLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0eC5lbmNvZGUoKTtcbiAgICB9KTtcbiAgICBjb25zdCBwYXJ0aWFsT3AgPSB7XG4gICAgICBzZW5kZXIsXG4gICAgICBub25jZSxcbiAgICAgIGluaXRDb2RlLFxuICAgICAgY2FsbERhdGEsXG4gICAgICBtYXhGZWVQZXJHYXMsXG4gICAgICBtYXhQcmlvcml0eUZlZVBlckdhcyxcbiAgICAgIGNhbGxHYXNMaW1pdDogQmlnTnVtYmVyLmZyb20oMTAwMDAwMCksXG4gICAgICB2ZXJpZmljYXRpb25HYXNMaW1pdDogQmlnTnVtYmVyLmZyb20oMTAwMDAwMCksXG4gICAgICBwcmVWZXJpZmljYXRpb25HYXM6IEJpZ051bWJlci5mcm9tKDEwMDAwMDApLFxuICAgICAgcGF5bWFzdGVyQW5kRGF0YTogXCIweFwiLFxuICAgICAgc2lnbmF0dXJlOiBEVU1NWV9TSUdOQVRVUkVcbiAgICB9O1xuXG4gICAgLy8gcGF5bWFzdGVyIGRhdGEgKyBtYXliZSB1c2VkIGZvciBlc3RpbWF0aW9uIGFzIHdlbGxcbiAgICBjb25zdCBnYXNsZXNzID0gb3B0aW9ucz8uZ2FzbGVzcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5nYXNsZXNzIDogdGhpcy5nYXNsZXNzO1xuICAgIGNvbnN0IHVzZUVyYzIwUGF5bWFzdGVyID0gdGhpcy5lcmMyMFBheW1hc3RlckFkZHJlc3MgJiYgdGhpcy5lcmMyMFRva2VuQWRkcmVzcyAmJiAoYXdhaXQgdGhpcy5pc0FjY291bnRBcHByb3ZlZCgpKTtcbiAgICBpZiAodXNlRXJjMjBQYXltYXN0ZXIpIHtcbiAgICAgIHBhcnRpYWxPcC5wYXltYXN0ZXJBbmREYXRhID0gdGhpcy5lcmMyMFBheW1hc3RlckFkZHJlc3M7XG4gICAgICBsZXQgZXN0aW1hdGVzO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZXN0aW1hdGVzID0gYXdhaXQgaHR0cFJwY0NsaWVudC5lc3RpbWF0ZVVzZXJPcEdhcyhwYXJ0aWFsT3ApO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgdGhpcy51bndyYXBCdW5kbGVyRXJyb3IoZXJyb3IpO1xuICAgICAgfVxuICAgICAgcGFydGlhbE9wLmNhbGxHYXNMaW1pdCA9IGVzdGltYXRlcy5jYWxsR2FzTGltaXQ7XG4gICAgICBwYXJ0aWFsT3AudmVyaWZpY2F0aW9uR2FzTGltaXQgPSBlc3RpbWF0ZXMudmVyaWZpY2F0aW9uR2FzTGltaXQ7XG4gICAgICBwYXJ0aWFsT3AucHJlVmVyaWZpY2F0aW9uR2FzID0gZXN0aW1hdGVzLnByZVZlcmlmaWNhdGlvbkdhcztcbiAgICB9IGVsc2UgaWYgKGdhc2xlc3MpIHtcbiAgICAgIGNvbnN0IHBheW1hc3RlclJlc3VsdCA9IGF3YWl0IHRoaXMucGF5bWFzdGVyQVBJLmdldFBheW1hc3RlckFuZERhdGEocGFydGlhbE9wKTtcbiAgICAgIGNvbnN0IHBheW1hc3RlckFuZERhdGEgPSBwYXltYXN0ZXJSZXN1bHQucGF5bWFzdGVyQW5kRGF0YTtcbiAgICAgIGlmIChwYXltYXN0ZXJBbmREYXRhICYmIHBheW1hc3RlckFuZERhdGEgIT09IFwiMHhcIikge1xuICAgICAgICBwYXJ0aWFsT3AucGF5bWFzdGVyQW5kRGF0YSA9IHBheW1hc3RlckFuZERhdGE7XG4gICAgICB9XG4gICAgICAvLyBwYXltYXN0ZXIgY2FuIGhhdmUgdGhlIGdhcyBsaW1pdHMgaW4gdGhlIHJlc3BvbnNlXG4gICAgICBpZiAocGF5bWFzdGVyUmVzdWx0LmNhbGxHYXNMaW1pdCAmJiBwYXltYXN0ZXJSZXN1bHQudmVyaWZpY2F0aW9uR2FzTGltaXQgJiYgcGF5bWFzdGVyUmVzdWx0LnByZVZlcmlmaWNhdGlvbkdhcykge1xuICAgICAgICBwYXJ0aWFsT3AuY2FsbEdhc0xpbWl0ID0gQmlnTnVtYmVyLmZyb20ocGF5bWFzdGVyUmVzdWx0LmNhbGxHYXNMaW1pdCk7XG4gICAgICAgIHBhcnRpYWxPcC52ZXJpZmljYXRpb25HYXNMaW1pdCA9IEJpZ051bWJlci5mcm9tKHBheW1hc3RlclJlc3VsdC52ZXJpZmljYXRpb25HYXNMaW1pdCk7XG4gICAgICAgIHBhcnRpYWxPcC5wcmVWZXJpZmljYXRpb25HYXMgPSBCaWdOdW1iZXIuZnJvbShwYXltYXN0ZXJSZXN1bHQucHJlVmVyaWZpY2F0aW9uR2FzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG90aGVyd2lzZSBmYWxsYmFjayB0byBidW5kbGVyIGZvciBnYXMgbGltaXRzXG4gICAgICAgIGxldCBlc3RpbWF0ZXM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZXN0aW1hdGVzID0gYXdhaXQgaHR0cFJwY0NsaWVudC5lc3RpbWF0ZVVzZXJPcEdhcyhwYXJ0aWFsT3ApO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHRocm93IHRoaXMudW53cmFwQnVuZGxlckVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJ0aWFsT3AuY2FsbEdhc0xpbWl0ID0gZXN0aW1hdGVzLmNhbGxHYXNMaW1pdDtcbiAgICAgICAgcGFydGlhbE9wLnZlcmlmaWNhdGlvbkdhc0xpbWl0ID0gZXN0aW1hdGVzLnZlcmlmaWNhdGlvbkdhc0xpbWl0O1xuICAgICAgICBwYXJ0aWFsT3AucHJlVmVyaWZpY2F0aW9uR2FzID0gZXN0aW1hdGVzLnByZVZlcmlmaWNhdGlvbkdhcztcbiAgICAgICAgLy8gbmVlZCBwYXltYXN0ZXIgdG8gcmUtc2lnbiBhZnRlciBlc3RpbWF0ZXNcbiAgICAgICAgaWYgKHBheW1hc3RlckFuZERhdGEgJiYgcGF5bWFzdGVyQW5kRGF0YSAhPT0gXCIweFwiKSB7XG4gICAgICAgICAgY29uc3QgcGF5bWFzdGVyUmVzdWx0MiA9IGF3YWl0IHRoaXMucGF5bWFzdGVyQVBJLmdldFBheW1hc3RlckFuZERhdGEocGFydGlhbE9wKTtcbiAgICAgICAgICBpZiAocGF5bWFzdGVyUmVzdWx0Mi5wYXltYXN0ZXJBbmREYXRhICYmIHBheW1hc3RlclJlc3VsdDIucGF5bWFzdGVyQW5kRGF0YSAhPT0gXCIweFwiKSB7XG4gICAgICAgICAgICBwYXJ0aWFsT3AucGF5bWFzdGVyQW5kRGF0YSA9IHBheW1hc3RlclJlc3VsdDIucGF5bWFzdGVyQW5kRGF0YTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcXVlcnkgYnVuZGxlciBmb3IgZ2FzIGxpbWl0c1xuICAgICAgbGV0IGVzdGltYXRlcztcbiAgICAgIHRyeSB7XG4gICAgICAgIGVzdGltYXRlcyA9IGF3YWl0IGh0dHBScGNDbGllbnQuZXN0aW1hdGVVc2VyT3BHYXMocGFydGlhbE9wKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRocm93IHRoaXMudW53cmFwQnVuZGxlckVycm9yKGVycm9yKTtcbiAgICAgIH1cbiAgICAgIHBhcnRpYWxPcC5jYWxsR2FzTGltaXQgPSBlc3RpbWF0ZXMuY2FsbEdhc0xpbWl0O1xuICAgICAgcGFydGlhbE9wLnZlcmlmaWNhdGlvbkdhc0xpbWl0ID0gZXN0aW1hdGVzLnZlcmlmaWNhdGlvbkdhc0xpbWl0O1xuICAgICAgcGFydGlhbE9wLnByZVZlcmlmaWNhdGlvbkdhcyA9IGVzdGltYXRlcy5wcmVWZXJpZmljYXRpb25HYXM7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAuLi5wYXJ0aWFsT3AsXG4gICAgICBzaWduYXR1cmU6IFwiXCJcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFNpZ24gdGhlIGZpbGxlZCB1c2VyT3AuXG4gICAqIEBwYXJhbSB1c2VyT3AgLSBUaGUgVXNlck9wZXJhdGlvbiB0byBzaWduICh3aXRoIHNpZ25hdHVyZSBmaWVsZCBpZ25vcmVkKVxuICAgKi9cbiAgYXN5bmMgc2lnblVzZXJPcCh1c2VyT3ApIHtcbiAgICBjb25zdCB1c2VyT3BIYXNoID0gYXdhaXQgdGhpcy5nZXRVc2VyT3BIYXNoKHVzZXJPcCk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgdGhpcy5zaWduVXNlck9wSGFzaCh1c2VyT3BIYXNoKTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4udXNlck9wLFxuICAgICAgc2lnbmF0dXJlXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgdGhlIHRyYW5zYWN0aW9uIHRoYXQgaGFzIHRoaXMgdXNlck9wSGFzaCBtaW5lZCwgb3IgdGhyb3dzIGlmIG5vdCBmb3VuZFxuICAgKiBAcGFyYW0gdXNlck9wSGFzaCAtIHJldHVybmVkIGJ5IHNlbmRVc2VyT3BUb0J1bmRsZXIgKG9yIGJ5IGdldFVzZXJPcEhhc2guLilcbiAgICogQHBhcmFtIHRpbWVvdXQgLSBzdG9wIHdhaXRpbmcgYWZ0ZXIgdGhpcyB0aW1lb3V0XG4gICAqIEBwYXJhbSBpbnRlcnZhbCAtIHRpbWUgdG8gd2FpdCBiZXR3ZWVuIHBvbGxzLlxuICAgKiBAcmV0dXJucyBUaGUgdHJhbnNhY3Rpb24gcmVjZWlwdCwgb3IgYW4gZXJyb3IgaWYgdGltZWQgb3V0LlxuICAgKi9cbiAgYXN5bmMgZ2V0VXNlck9wUmVjZWlwdChodHRwUnBjQ2xpZW50LCB1c2VyT3BIYXNoKSB7XG4gICAgbGV0IHRpbWVvdXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDEyMDAwMDtcbiAgICBsZXQgaW50ZXJ2YWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDEwMDA7XG4gICAgY29uc3QgZW5kdGltZSA9IERhdGUubm93KCkgKyB0aW1lb3V0O1xuICAgIHdoaWxlIChEYXRlLm5vdygpIDwgZW5kdGltZSkge1xuICAgICAgY29uc3QgdXNlck9wUmVjZWlwdCA9IGF3YWl0IGh0dHBScGNDbGllbnQuZ2V0VXNlck9wZXJhdGlvblJlY2VpcHQodXNlck9wSGFzaCk7XG4gICAgICBpZiAodXNlck9wUmVjZWlwdCkge1xuICAgICAgICAvLyBhdm9pZCBkZXN5bmMgd2l0aCBjdXJyZW50IHByb3ZpZGVyIHN0YXRlXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByb3ZpZGVyLndhaXRGb3JUcmFuc2FjdGlvbih1c2VyT3BSZWNlaXB0LnJlY2VpcHQudHJhbnNhY3Rpb25IYXNoKTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBpbnRlcnZhbCkpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaW1lb3V0IHdhaXRpbmcgZm9yIHVzZXJPcCB0byBiZSBtaW5lZFwiKTtcbiAgfVxuICB1bndyYXBCdW5kbGVyRXJyb3IoZXJyb3IpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gZXJyb3I/LmVycm9yPy5tZXNzYWdlIHx8IGVycm9yLmVycm9yIHx8IGVycm9yLm1lc3NhZ2UgfHwgZXJyb3I7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2VOdW1iZXIoYSkge1xuICBpZiAoIWEgfHwgYSA9PT0gXCJcIikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBCaWdOdW1iZXIuZnJvbShhLnRvU3RyaW5nKCkpO1xufVxuXG5jbGFzcyBBY2NvdW50QVBJIGV4dGVuZHMgQmFzZUFjY291bnRBUEkge1xuICBjb25zdHJ1Y3RvcihwYXJhbXMsIG9yaWdpbmFsUHJvdmlkZXIpIHtcbiAgICBzdXBlcih7XG4gICAgICAuLi5wYXJhbXMsXG4gICAgICBwcm92aWRlcjogb3JpZ2luYWxQcm92aWRlclxuICAgIH0pO1xuICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgIC8vIFRlY2huaWNhbGx5IGRvbnQgbmVlZCB0aGUgc2lnbmVyIGhlcmUsIGJ1dCB3ZSBuZWVkIHRvIGVuY29kZS9lc3RpbWF0ZSBnYXMgd2l0aCBpdCBzbyBhIHNpZ25lciBpcyByZXF1aXJlZFxuICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gdXNlIHRoZSBsb2NhbFNpZ25lciBkaXJlY3RseSBzaW5jZSBpdCBtaWdodCBiZSBjb25uZWN0ZWQgdG8gYW5vdGhlciBjaGFpblxuICAgIC8vIHNvIHdlIGp1c3QgdXNlIHRoZSBwdWJsaWMgaGFyZGhhdCBwa2V5IGluc3RlYWRcbiAgICB0aGlzLnNkayA9IFRoaXJkd2ViU0RLLmZyb21Qcml2YXRlS2V5KExPQ0FMX05PREVfUEtFWSwgcGFyYW1zLmNoYWluLCB7XG4gICAgICBjbGllbnRJZDogcGFyYW1zLmNsaWVudElkLFxuICAgICAgc2VjcmV0S2V5OiBwYXJhbXMuc2VjcmV0S2V5LFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBleHBlY3RlZCBjaGFpbiB0eXBlIGVycm9yXG4gICAgICBzdXBwb3J0ZWRDaGFpbnM6IHR5cGVvZiBwYXJhbXMuY2hhaW4gPT09IFwib2JqZWN0XCIgPyBbcGFyYW1zLmNoYWluXSA6IHVuZGVmaW5lZFxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGdldENoYWluSWQoKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0TmV0d29yaygpLnRoZW4obiA9PiBuLmNoYWluSWQpO1xuICB9XG4gIGFzeW5jIGdldEFjY291bnRDb250cmFjdCgpIHtcbiAgICBpZiAoIXRoaXMuYWNjb3VudENvbnRyYWN0KSB7XG4gICAgICBpZiAodGhpcy5wYXJhbXMuYWNjb3VudEluZm8/LmFiaSkge1xuICAgICAgICB0aGlzLmFjY291bnRDb250cmFjdCA9IGF3YWl0IHRoaXMuc2RrLmdldENvbnRyYWN0KGF3YWl0IHRoaXMuZ2V0QWNjb3VudEFkZHJlc3MoKSwgdGhpcy5wYXJhbXMuYWNjb3VudEluZm8uYWJpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWNjb3VudENvbnRyYWN0ID0gYXdhaXQgdGhpcy5zZGsuZ2V0Q29udHJhY3QoYXdhaXQgdGhpcy5nZXRBY2NvdW50QWRkcmVzcygpLCBBQ0NPVU5UX0NPUkVfQUJJKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYWNjb3VudENvbnRyYWN0O1xuICB9XG4gIGFzeW5jIGdldEFjY291bnRJbml0Q29kZSgpIHtcbiAgICBjb25zdCBmYWN0b3J5ID0gYXdhaXQgdGhpcy5nZXRGYWN0b3J5Q29udHJhY3QoKTtcbiAgICBjb25zdCBsb2NhbFNpZ25lciA9IGF3YWl0IHRoaXMucGFyYW1zLmxvY2FsU2lnbmVyLmdldEFkZHJlc3MoKTtcbiAgICBjb25zdCB0eCA9IGF3YWl0IHRoaXMucGFyYW1zLmZhY3RvcnlJbmZvLmNyZWF0ZUFjY291bnQoZmFjdG9yeSwgbG9jYWxTaWduZXIpO1xuICAgIHJldHVybiB1dGlscy5oZXhDb25jYXQoW2ZhY3RvcnkuZ2V0QWRkcmVzcygpLCB0eC5lbmNvZGUoKV0pO1xuICB9XG4gIGFzeW5jIGdldEZhY3RvcnlDb250cmFjdCgpIHtcbiAgICBpZiAodGhpcy5mYWN0b3J5Q29udHJhY3QpIHtcbiAgICAgIHJldHVybiB0aGlzLmZhY3RvcnlDb250cmFjdDtcbiAgICB9XG4gICAgaWYgKHRoaXMucGFyYW1zLmZhY3RvcnlJbmZvPy5hYmkpIHtcbiAgICAgIHRoaXMuZmFjdG9yeUNvbnRyYWN0ID0gYXdhaXQgdGhpcy5zZGsuZ2V0Q29udHJhY3QodGhpcy5wYXJhbXMuZmFjdG9yeUFkZHJlc3MsIHRoaXMucGFyYW1zLmZhY3RvcnlJbmZvLmFiaSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZmFjdG9yeUNvbnRyYWN0ID0gYXdhaXQgdGhpcy5zZGsuZ2V0Q29udHJhY3QodGhpcy5wYXJhbXMuZmFjdG9yeUFkZHJlc3MpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5mYWN0b3J5Q29udHJhY3Q7XG4gIH1cbiAgYXN5bmMgZ2V0Q291bnRlckZhY3R1YWxBZGRyZXNzKCkge1xuICAgIGlmICh0aGlzLnBhcmFtcy5hY2NvdW50QWRkcmVzcykge1xuICAgICAgcmV0dXJuIHRoaXMucGFyYW1zLmFjY291bnRBZGRyZXNzO1xuICAgIH1cbiAgICBjb25zdCBmYWN0b3J5ID0gYXdhaXQgdGhpcy5nZXRGYWN0b3J5Q29udHJhY3QoKTtcbiAgICBjb25zdCBsb2NhbFNpZ25lciA9IGF3YWl0IHRoaXMucGFyYW1zLmxvY2FsU2lnbmVyLmdldEFkZHJlc3MoKTtcbiAgICByZXR1cm4gdGhpcy5wYXJhbXMuZmFjdG9yeUluZm8uZ2V0QWNjb3VudEFkZHJlc3MoZmFjdG9yeSwgbG9jYWxTaWduZXIpO1xuICB9XG4gIGFzeW5jIGdldE5vbmNlKCkge1xuICAgIGlmIChhd2FpdCB0aGlzLmNoZWNrQWNjb3VudFBoYW50b20oKSkge1xuICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKDApO1xuICAgIH1cbiAgICBjb25zdCBhY2NvdW50Q29udHJhY3QgPSBhd2FpdCB0aGlzLmdldEFjY291bnRDb250cmFjdCgpO1xuICAgIHJldHVybiB0aGlzLnBhcmFtcy5hY2NvdW50SW5mby5nZXROb25jZShhY2NvdW50Q29udHJhY3QpO1xuICB9XG4gIGFzeW5jIHByZXBhcmVFeGVjdXRlKHRhcmdldCwgdmFsdWUsIGRhdGEpIHtcbiAgICBjb25zdCBhY2NvdW50Q29udHJhY3QgPSBhd2FpdCB0aGlzLmdldEFjY291bnRDb250cmFjdCgpO1xuICAgIHJldHVybiB0aGlzLnBhcmFtcy5hY2NvdW50SW5mby5leGVjdXRlKGFjY291bnRDb250cmFjdCwgdGFyZ2V0LCB2YWx1ZSwgZGF0YSk7XG4gIH1cbiAgYXN5bmMgcHJlcGFyZUV4ZWN1dGVCYXRjaCh0YXJnZXRzLCB2YWx1ZXMsIGRhdGFzKSB7XG4gICAgY29uc3QgYWNjb3VudENvbnRyYWN0ID0gYXdhaXQgdGhpcy5nZXRBY2NvdW50Q29udHJhY3QoKTtcbiAgICByZXR1cm4gYWNjb3VudENvbnRyYWN0LnByZXBhcmUoXCJleGVjdXRlQmF0Y2hcIiwgW3RhcmdldHMsIHZhbHVlcywgZGF0YXNdKTtcbiAgfVxuICBhc3luYyBzaWduVXNlck9wSGFzaCh1c2VyT3BIYXNoKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucGFyYW1zLmxvY2FsU2lnbmVyLnNpZ25NZXNzYWdlKHV0aWxzLmFycmF5aWZ5KHVzZXJPcEhhc2gpKTtcbiAgfVxuICBhc3luYyBpc0Fjb3VudERlcGxveWVkKCkge1xuICAgIHJldHVybiAhKGF3YWl0IHRoaXMuY2hlY2tBY2NvdW50UGhhbnRvbSgpKTtcbiAgfVxuICBhc3luYyBpc0FjY291bnRBcHByb3ZlZCgpIHtcbiAgICBpZiAoIXRoaXMucGFyYW1zLmVyYzIwUGF5bWFzdGVyQWRkcmVzcyB8fCAhdGhpcy5wYXJhbXMuZXJjMjBUb2tlbkFkZHJlc3MpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBzd0FkZHJlc3MgPSBhd2FpdCB0aGlzLmdldENvdW50ZXJGYWN0dWFsQWRkcmVzcygpO1xuICAgIGNvbnN0IEVSQzIwQWJpID0gKGF3YWl0IGltcG9ydCgnQHRoaXJkd2ViLWRldi9jb250cmFjdHMtanMvZGlzdC9hYmlzL0lFUkMyMC5qc29uJykpLmRlZmF1bHQ7XG4gICAgY29uc3QgZXJjMjBUb2tlbiA9IGF3YWl0IHRoaXMuc2RrLmdldENvbnRyYWN0KHRoaXMucGFyYW1zLmVyYzIwVG9rZW5BZGRyZXNzLCBFUkMyMEFiaSk7XG4gICAgY29uc3QgYWxsb3dhbmNlID0gYXdhaXQgZXJjMjBUb2tlbi5jYWxsKFwiYWxsb3dhbmNlXCIsIFtzd0FkZHJlc3MsIHRoaXMucGFyYW1zLmVyYzIwUGF5bWFzdGVyQWRkcmVzc10pO1xuICAgIHJldHVybiBhbGxvd2FuY2UuZ3RlKEJpZ051bWJlci5mcm9tKDIpLnBvdyg5Nikuc3ViKDEpKTtcbiAgfVxuICBhc3luYyBjcmVhdGVBcHByb3ZlVHgoKSB7XG4gICAgaWYgKGF3YWl0IHRoaXMuaXNBY2NvdW50QXBwcm92ZWQoKSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgYW1vdW50VG9BcHByb3ZlID0gQmlnTnVtYmVyLmZyb20oMikucG93KDk2KS5zdWIoMSk7XG4gICAgY29uc3QgZXRoZXJzU2lnbmVyID0gbmV3IGV0aGVycy5XYWxsZXQoTE9DQUxfTk9ERV9QS0VZLCB0aGlzLnByb3ZpZGVyKTtcbiAgICBjb25zdCBlcmMyMENvbnRyYWN0ID0gbmV3IENvbnRyYWN0KHRoaXMucGFyYW1zLmVyYzIwVG9rZW5BZGRyZXNzLCBbXCJmdW5jdGlvbiBhcHByb3ZlKGFkZHJlc3Mgc3BlbmRlciwgdWludDI1NiBhbW91bnQpIHB1YmxpYyByZXR1cm5zIChib29sKVwiXSwgZXRoZXJzU2lnbmVyKTtcbiAgICBjb25zdCB0eCA9IHtcbiAgICAgIHRvOiB0aGlzLnBhcmFtcy5lcmMyMFRva2VuQWRkcmVzcyxcbiAgICAgIGZyb206IGF3YWl0IHRoaXMuZ2V0QWNjb3VudEFkZHJlc3MoKSxcbiAgICAgIHZhbHVlOiAwLFxuICAgICAgZGF0YTogZXJjMjBDb250cmFjdC5pbnRlcmZhY2UuZW5jb2RlRnVuY3Rpb25EYXRhKFwiYXBwcm92ZVwiLCBbdGhpcy5wYXJhbXMuZXJjMjBQYXltYXN0ZXJBZGRyZXNzLCBhbW91bnRUb0FwcHJvdmVdKVxuICAgIH07XG4gICAgcmV0dXJuIHR4O1xuICB9XG59XG5cbmNsYXNzIFNtYXJ0V2FsbGV0Q29ubmVjdG9yIGV4dGVuZHMgQ29ubmVjdG9yIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgfVxuICBhc3luYyBpbml0aWFsaXplKHBhcmFtcykge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgIGNvbnN0IG9yaWdpbmFsUHJvdmlkZXIgPSBnZXRDaGFpblByb3ZpZGVyKGNvbmZpZy5jaGFpbiwge1xuICAgICAgY2xpZW50SWQ6IGNvbmZpZy5jbGllbnRJZCxcbiAgICAgIHNlY3JldEtleTogY29uZmlnLnNlY3JldEtleVxuICAgIH0pO1xuICAgIHRoaXMuY2hhaW5JZCA9IChhd2FpdCBvcmlnaW5hbFByb3ZpZGVyLmdldE5ldHdvcmsoKSkuY2hhaW5JZDtcbiAgICBjb25zdCBidW5kbGVyVXJsID0gdGhpcy5jb25maWcuYnVuZGxlclVybCB8fCBgaHR0cHM6Ly8ke3RoaXMuY2hhaW5JZH0uYnVuZGxlci50aGlyZHdlYi5jb21gO1xuICAgIGNvbnN0IHBheW1hc3RlclVybCA9IHRoaXMuY29uZmlnLnBheW1hc3RlclVybCB8fCBgaHR0cHM6Ly8ke3RoaXMuY2hhaW5JZH0uYnVuZGxlci50aGlyZHdlYi5jb21gO1xuICAgIGNvbnN0IGVudHJ5UG9pbnRBZGRyZXNzID0gY29uZmlnLmVudHJ5UG9pbnRBZGRyZXNzIHx8IEVOVFJZUE9JTlRfQUREUkVTUztcbiAgICBjb25zdCBsb2NhbFNpZ25lciA9IGF3YWl0IHBhcmFtcy5wZXJzb25hbFdhbGxldC5nZXRTaWduZXIoKTtcbiAgICBjb25zdCBwcm92aWRlckNvbmZpZyA9IHtcbiAgICAgIGNoYWluOiBjb25maWcuY2hhaW4sXG4gICAgICBsb2NhbFNpZ25lcixcbiAgICAgIGVudHJ5UG9pbnRBZGRyZXNzLFxuICAgICAgYnVuZGxlclVybCxcbiAgICAgIHBheW1hc3RlckFQSTogdGhpcy5jb25maWcucGF5bWFzdGVyQVBJID8gdGhpcy5jb25maWcucGF5bWFzdGVyQVBJIDogZ2V0VmVyaWZ5aW5nUGF5bWFzdGVyKHBheW1hc3RlclVybCwgZW50cnlQb2ludEFkZHJlc3MsIHRoaXMuY29uZmlnLmNsaWVudElkLCB0aGlzLmNvbmZpZy5zZWNyZXRLZXkpLFxuICAgICAgZ2FzbGVzczogY29uZmlnLmdhc2xlc3MsXG4gICAgICBmYWN0b3J5QWRkcmVzczogY29uZmlnLmZhY3RvcnlBZGRyZXNzIHx8IERFRkFVTFRfRkFDVE9SWV9BRERSRVNTLFxuICAgICAgYWNjb3VudEFkZHJlc3M6IHBhcmFtcy5hY2NvdW50QWRkcmVzcyxcbiAgICAgIGZhY3RvcnlJbmZvOiB7XG4gICAgICAgIGNyZWF0ZUFjY291bnQ6IGNvbmZpZy5mYWN0b3J5SW5mbz8uY3JlYXRlQWNjb3VudCB8fCB0aGlzLmRlZmF1bHRGYWN0b3J5SW5mbygpLmNyZWF0ZUFjY291bnQsXG4gICAgICAgIGdldEFjY291bnRBZGRyZXNzOiBjb25maWcuZmFjdG9yeUluZm8/LmdldEFjY291bnRBZGRyZXNzIHx8IHRoaXMuZGVmYXVsdEZhY3RvcnlJbmZvKCkuZ2V0QWNjb3VudEFkZHJlc3MsXG4gICAgICAgIGFiaTogY29uZmlnLmZhY3RvcnlJbmZvPy5hYmlcbiAgICAgIH0sXG4gICAgICBhY2NvdW50SW5mbzoge1xuICAgICAgICBleGVjdXRlOiBjb25maWcuYWNjb3VudEluZm8/LmV4ZWN1dGUgfHwgdGhpcy5kZWZhdWx0QWNjb3VudEluZm8oKS5leGVjdXRlLFxuICAgICAgICBnZXROb25jZTogY29uZmlnLmFjY291bnRJbmZvPy5nZXROb25jZSB8fCB0aGlzLmRlZmF1bHRBY2NvdW50SW5mbygpLmdldE5vbmNlLFxuICAgICAgICBhYmk6IGNvbmZpZy5hY2NvdW50SW5mbz8uYWJpXG4gICAgICB9LFxuICAgICAgY2xpZW50SWQ6IGNvbmZpZy5jbGllbnRJZCxcbiAgICAgIHNlY3JldEtleTogY29uZmlnLnNlY3JldEtleSxcbiAgICAgIGVyYzIwUGF5bWFzdGVyQWRkcmVzczogY29uZmlnLmVyYzIwUGF5bWFzdGVyQWRkcmVzcyxcbiAgICAgIGVyYzIwVG9rZW5BZGRyZXNzOiBjb25maWcuZXJjMjBUb2tlbkFkZHJlc3NcbiAgICB9O1xuICAgIHRoaXMucGVyc29uYWxXYWxsZXQgPSBwYXJhbXMucGVyc29uYWxXYWxsZXQ7XG4gICAgY29uc3QgYWNjb3VudEFwaSA9IG5ldyBBY2NvdW50QVBJKHByb3ZpZGVyQ29uZmlnLCBvcmlnaW5hbFByb3ZpZGVyKTtcbiAgICB0aGlzLmFhUHJvdmlkZXIgPSBjcmVhdGU0MzM3UHJvdmlkZXIocHJvdmlkZXJDb25maWcsIGFjY291bnRBcGksIG9yaWdpbmFsUHJvdmlkZXIsIHRoaXMuY2hhaW5JZCk7XG4gICAgdGhpcy5hY2NvdW50QXBpID0gYWNjb3VudEFwaTtcbiAgfVxuICBhc3luYyBjb25uZWN0KGNvbm5lY3Rpb25BcmdzKSB7XG4gICAgYXdhaXQgdGhpcy5pbml0aWFsaXplKGNvbm5lY3Rpb25BcmdzKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRBZGRyZXNzKCk7XG4gIH1cbiAgZ2V0UHJvdmlkZXIoKSB7XG4gICAgaWYgKCF0aGlzLmFhUHJvdmlkZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBlcnNvbmFsIHdhbGxldCBub3QgY29ubmVjdGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuYWFQcm92aWRlcik7XG4gIH1cbiAgYXN5bmMgZ2V0U2lnbmVyKCkge1xuICAgIGlmICghdGhpcy5hYVByb3ZpZGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQZXJzb25hbCB3YWxsZXQgbm90IGNvbm5lY3RlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmFhUHJvdmlkZXIuZ2V0U2lnbmVyKCkpO1xuICB9XG4gIGFzeW5jIGdldEFkZHJlc3MoKSB7XG4gICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgdGhpcy5nZXRTaWduZXIoKTtcbiAgICByZXR1cm4gc2lnbmVyLmdldEFkZHJlc3MoKTtcbiAgfVxuICBhc3luYyBpc0Nvbm5lY3RlZCgpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYWRkcmVzcyA9IGF3YWl0IHRoaXMuZ2V0QWRkcmVzcygpO1xuICAgICAgcmV0dXJuICEhYWRkcmVzcztcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGFzeW5jIGRpc2Nvbm5lY3QoKSB7XG4gICAgdGhpcy5wZXJzb25hbFdhbGxldCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmFhUHJvdmlkZXIgPSB1bmRlZmluZWQ7XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuXG4gIGFzeW5jIHN3aXRjaENoYWluKGNoYWluSWQpIHtcbiAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IHRoaXMuZ2V0UHJvdmlkZXIoKTtcbiAgICBjb25zdCBjdXJyZW50Q2hhaW5JZCA9IChhd2FpdCBwcm92aWRlci5nZXROZXR3b3JrKCkpLmNoYWluSWQ7XG4gICAgaWYgKGN1cnJlbnRDaGFpbklkICE9PSBjaGFpbklkKSB7XG4gICAgICAvLyBvbmx5IHRocm93IGlmIGFjdHVhbGx5IHRyeWluZyB0byBzd2l0Y2ggY2hhaW5zXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3Qgc3VwcG9ydGVkLlwiKTtcbiAgICB9XG4gIH1cbiAgc2V0dXBMaXN0ZW5lcnMoKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICB1cGRhdGVDaGFpbnMoY2hhaW5zKSB7fVxuXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIHRoZSBjb25uZWN0ZWQgc2lnbmVyIGNhbiBleGVjdXRlIGEgZ2l2ZW4gdHJhbnNhY3Rpb24gdXNpbmcgdGhlIHNtYXJ0IHdhbGxldC5cbiAgICogQHBhcmFtIHRyYW5zYWN0aW9uIC0gVGhlIHRyYW5zYWN0aW9uIHRvIGV4ZWN1dGUgdXNpbmcgdGhlIHNtYXJ0IHdhbGxldC5cbiAgICogQHJldHVybnMgd2hldGhlciB0aGUgY29ubmVjdGVkIHNpZ25lciBjYW4gZXhlY3V0ZSB0aGUgdHJhbnNhY3Rpb24gdXNpbmcgdGhlIHNtYXJ0IHdhbGxldC5cbiAgICovXG4gIGFzeW5jIGhhc1Blcm1pc3Npb25Ub0V4ZWN1dGUodHJhbnNhY3Rpb24pIHtcbiAgICBjb25zdCBhY2NvdW50Q29udHJhY3QgPSBhd2FpdCB0aGlzLmdldEFjY291bnRDb250cmFjdCgpO1xuICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IHRoaXMuZ2V0U2lnbmVyKCk7XG4gICAgY29uc3Qgc2lnbmVyQWRkcmVzcyA9IGF3YWl0IHNpZ25lci5nZXRBZGRyZXNzKCk7XG4gICAgY29uc3QgcmVzdHJpY3Rpb25zID0gKGF3YWl0IGFjY291bnRDb250cmFjdC5hY2NvdW50LmdldEFsbFNpZ25lcnMoKSkuZmlsdGVyKGl0ZW0gPT4gZXRoZXJzLnV0aWxzLmdldEFkZHJlc3MoaXRlbS5zaWduZXIpID09PSBldGhlcnMudXRpbHMuZ2V0QWRkcmVzcyhzaWduZXJBZGRyZXNzKSlbMF0/LnBlcm1pc3Npb25zO1xuICAgIGlmICghcmVzdHJpY3Rpb25zKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiByZXN0cmljdGlvbnMuYXBwcm92ZWRDYWxsVGFyZ2V0cy5pbmNsdWRlcyh0cmFuc2FjdGlvbi5nZXRUYXJnZXQoKSk7XG4gIH1cblxuICAvLy8gUFJFUEFSRUQgVFJBTlNBQ1RJT05TXG5cbiAgLyoqXG4gICAqIFNlbmQgYSBzaW5nbGUgdHJhbnNhY3Rpb24gd2l0aG91dCB3YWl0aW5nIGZvciBjb25maXJtYXRpb25zXG4gICAqIEBwYXJhbSB0cmFuc2FjdGlvbiAtIHRoZSB0cmFuc2FjdGlvbiB0byBzZW5kXG4gICAqIEBwYXJhbSBjb25maWcgLSBvcHRpb25hbCB0aGUgdHJhbnNhY3Rpb24gY29uZmlndXJhdGlvblxuICAgKiBAcmV0dXJucyBUaGUgYXdhaXRhYmxlIHRyYW5zYWN0aW9uXG4gICAqL1xuICBhc3luYyBzZW5kKHRyYW5zYWN0aW9uLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgdGhpcy5nZXRTaWduZXIoKTtcbiAgICByZXR1cm4gc2lnbmVyLnNlbmRUcmFuc2FjdGlvbih7XG4gICAgICB0bzogdHJhbnNhY3Rpb24uZ2V0VGFyZ2V0KCksXG4gICAgICBkYXRhOiB0cmFuc2FjdGlvbi5lbmNvZGUoKSxcbiAgICAgIHZhbHVlOiBhd2FpdCB0cmFuc2FjdGlvbi5nZXRWYWx1ZSgpXG4gICAgfSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZSBhIHNpbmdsZSB0cmFuc2FjdGlvbiAod2FpdGluZyBmb3IgY29uZmlybWF0aW9ucylcbiAgICogQHBhcmFtIHRyYW5zYWN0aW9uIC0gVGhlIHRyYW5zYWN0aW9uIHRvIGV4ZWN1dGVcbiAgICogQHJldHVybnMgVGhlIHRyYW5zYWN0aW9uIHJlY2VpcHRcbiAgICovXG4gIGFzeW5jIGV4ZWN1dGUodHJhbnNhY3Rpb24sIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0eCA9IGF3YWl0IHRoaXMuc2VuZCh0cmFuc2FjdGlvbiwgb3B0aW9ucyk7XG4gICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHR4LndhaXQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVjZWlwdFxuICAgIH07XG4gIH1cbiAgYXN5bmMgc2VuZEJhdGNoKHRyYW5zYWN0aW9ucywgb3B0aW9ucykge1xuICAgIGlmICghdGhpcy5hY2NvdW50QXBpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQZXJzb25hbCB3YWxsZXQgbm90IGNvbm5lY3RlZFwiKTtcbiAgICB9XG4gICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgdGhpcy5nZXRTaWduZXIoKTtcbiAgICBjb25zdCB7XG4gICAgICB0eCxcbiAgICAgIGJhdGNoRGF0YVxuICAgIH0gPSBhd2FpdCB0aGlzLnByZXBhcmVCYXRjaFR4KHRyYW5zYWN0aW9ucyk7XG4gICAgcmV0dXJuIGF3YWl0IHNpZ25lci5zZW5kVHJhbnNhY3Rpb24oe1xuICAgICAgdG86IGF3YWl0IHNpZ25lci5nZXRBZGRyZXNzKCksXG4gICAgICBkYXRhOiB0eC5lbmNvZGUoKSxcbiAgICAgIHZhbHVlOiAwXG4gICAgfSwge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGJhdGNoRGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgbXVsdGlwbGUgdHJhbnNhY3Rpb25zIGluIGEgc2luZ2xlIGJhdGNoXG4gICAqIEBwYXJhbSB0cmFuc2FjdGlvbnMgLSBUaGUgdHJhbnNhY3Rpb25zIHRvIGV4ZWN1dGVcbiAgICogQHJldHVybnMgVGhlIHRyYW5zYWN0aW9uIHJlY2VpcHRcbiAgICovXG4gIGFzeW5jIGV4ZWN1dGVCYXRjaCh0cmFuc2FjdGlvbnMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0eCA9IGF3YWl0IHRoaXMuc2VuZEJhdGNoKHRyYW5zYWN0aW9ucywgb3B0aW9ucyk7XG4gICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHR4LndhaXQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVjZWlwdFxuICAgIH07XG4gIH1cblxuICAvLy8gUkFXIFRSQU5TQUNUSU9OU1xuXG4gIGFzeW5jIHNlbmRSYXcodHJhbnNhY3Rpb24sIG9wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuYWNjb3VudEFwaSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGVyc29uYWwgd2FsbGV0IG5vdCBjb25uZWN0ZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IHRoaXMuZ2V0U2lnbmVyKCk7XG4gICAgcmV0dXJuIHNpZ25lci5zZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIG9wdGlvbnMpO1xuICB9XG4gIGFzeW5jIGV4ZWN1dGVSYXcodHJhbnNhY3Rpb24sIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0eCA9IGF3YWl0IHRoaXMuc2VuZFJhdyh0cmFuc2FjdGlvbiwgb3B0aW9ucyk7XG4gICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHR4LndhaXQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVjZWlwdFxuICAgIH07XG4gIH1cbiAgYXN5bmMgc2VuZEJhdGNoUmF3KHRyYW5zYWN0aW9ucywgb3B0aW9ucykge1xuICAgIGlmICghdGhpcy5hY2NvdW50QXBpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQZXJzb25hbCB3YWxsZXQgbm90IGNvbm5lY3RlZFwiKTtcbiAgICB9XG4gICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgdGhpcy5nZXRTaWduZXIoKTtcbiAgICBjb25zdCBiYXRjaCA9IGF3YWl0IHRoaXMucHJlcGFyZUJhdGNoUmF3KHRyYW5zYWN0aW9ucyk7XG4gICAgcmV0dXJuIHNpZ25lci5zZW5kVHJhbnNhY3Rpb24oe1xuICAgICAgdG86IGF3YWl0IHNpZ25lci5nZXRBZGRyZXNzKCksXG4gICAgICBkYXRhOiBiYXRjaC50eC5lbmNvZGUoKSxcbiAgICAgIHZhbHVlOiAwXG4gICAgfSwge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGJhdGNoRGF0YTogYmF0Y2guYmF0Y2hEYXRhIC8vIGJhdGNoZWQgdHggZmxhZ1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGV4ZWN1dGVCYXRjaFJhdyh0cmFuc2FjdGlvbnMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0eCA9IGF3YWl0IHRoaXMuc2VuZEJhdGNoUmF3KHRyYW5zYWN0aW9ucywgb3B0aW9ucyk7XG4gICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHR4LndhaXQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVjZWlwdFxuICAgIH07XG4gIH1cblxuICAvLy8gRVNUSU1BVElPTlxuXG4gIGFzeW5jIGVzdGltYXRlKHRyYW5zYWN0aW9uLCBvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmFjY291bnRBcGkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBlcnNvbmFsIHdhbGxldCBub3QgY29ubmVjdGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5lc3RpbWF0ZVR4KHtcbiAgICAgIHRhcmdldDogdHJhbnNhY3Rpb24uZ2V0VGFyZ2V0KCksXG4gICAgICBkYXRhOiB0cmFuc2FjdGlvbi5lbmNvZGUoKSxcbiAgICAgIHZhbHVlOiBhd2FpdCB0cmFuc2FjdGlvbi5nZXRWYWx1ZSgpLFxuICAgICAgZ2FzTGltaXQ6IGF3YWl0IHRyYW5zYWN0aW9uLmdldE92ZXJyaWRlcygpLmdhc0xpbWl0LFxuICAgICAgbWF4RmVlUGVyR2FzOiBhd2FpdCB0cmFuc2FjdGlvbi5nZXRPdmVycmlkZXMoKS5tYXhGZWVQZXJHYXMsXG4gICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogYXdhaXQgdHJhbnNhY3Rpb24uZ2V0T3ZlcnJpZGVzKCkubWF4UHJpb3JpdHlGZWVQZXJHYXMsXG4gICAgICBub25jZTogYXdhaXQgdHJhbnNhY3Rpb24uZ2V0T3ZlcnJpZGVzKCkubm9uY2VcbiAgICB9LCBvcHRpb25zKTtcbiAgfVxuICBhc3luYyBlc3RpbWF0ZVJhdyh0cmFuc2FjdGlvbiwgb3B0aW9ucykge1xuICAgIGlmICghdGhpcy5hY2NvdW50QXBpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQZXJzb25hbCB3YWxsZXQgbm90IGNvbm5lY3RlZFwiKTtcbiAgICB9XG4gICAgY29uc3QgdHggPSBhd2FpdCBldGhlcnMudXRpbHMucmVzb2x2ZVByb3BlcnRpZXModHJhbnNhY3Rpb24pO1xuICAgIHJldHVybiB0aGlzLmVzdGltYXRlVHgoe1xuICAgICAgdGFyZ2V0OiB0eC50byB8fCBjb25zdGFudHMuQWRkcmVzc1plcm8sXG4gICAgICBkYXRhOiB0eC5kYXRhPy50b1N0cmluZygpIHx8IFwiXCIsXG4gICAgICB2YWx1ZTogdHgudmFsdWUgfHwgQmlnTnVtYmVyLmZyb20oMCksXG4gICAgICBnYXNMaW1pdDogdHguZ2FzTGltaXQsXG4gICAgICBtYXhGZWVQZXJHYXM6IHR4Lm1heEZlZVBlckdhcyxcbiAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiB0eC5tYXhQcmlvcml0eUZlZVBlckdhcyxcbiAgICAgIG5vbmNlOiB0eC5ub25jZVxuICAgIH0sIG9wdGlvbnMpO1xuICB9XG4gIGFzeW5jIGVzdGltYXRlQmF0Y2godHJhbnNhY3Rpb25zLCBvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmFjY291bnRBcGkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBlcnNvbmFsIHdhbGxldCBub3QgY29ubmVjdGVkXCIpO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICB0eCxcbiAgICAgIGJhdGNoRGF0YVxuICAgIH0gPSBhd2FpdCB0aGlzLnByZXBhcmVCYXRjaFR4KHRyYW5zYWN0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXMuZXN0aW1hdGVUeCh7XG4gICAgICB0YXJnZXQ6IHR4LmdldFRhcmdldCgpLFxuICAgICAgZGF0YTogdHguZW5jb2RlKCksXG4gICAgICB2YWx1ZTogYXdhaXQgdHguZ2V0VmFsdWUoKSxcbiAgICAgIGdhc0xpbWl0OiBhd2FpdCB0eC5nZXRPdmVycmlkZXMoKS5nYXNMaW1pdCxcbiAgICAgIG1heEZlZVBlckdhczogYXdhaXQgdHguZ2V0T3ZlcnJpZGVzKCkubWF4RmVlUGVyR2FzLFxuICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IGF3YWl0IHR4LmdldE92ZXJyaWRlcygpLm1heFByaW9yaXR5RmVlUGVyR2FzLFxuICAgICAgbm9uY2U6IGF3YWl0IHR4LmdldE92ZXJyaWRlcygpLm5vbmNlXG4gICAgfSwge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGJhdGNoRGF0YVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGVzdGltYXRlQmF0Y2hSYXcodHJhbnNhY3Rpb25zLCBvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmFjY291bnRBcGkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBlcnNvbmFsIHdhbGxldCBub3QgY29ubmVjdGVkXCIpO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICB0eCxcbiAgICAgIGJhdGNoRGF0YVxuICAgIH0gPSBhd2FpdCB0aGlzLnByZXBhcmVCYXRjaFJhdyh0cmFuc2FjdGlvbnMpO1xuICAgIHJldHVybiB0aGlzLmVzdGltYXRlVHgoe1xuICAgICAgdGFyZ2V0OiB0eC5nZXRUYXJnZXQoKSxcbiAgICAgIGRhdGE6IHR4LmVuY29kZSgpLFxuICAgICAgdmFsdWU6IGF3YWl0IHR4LmdldFZhbHVlKCksXG4gICAgICBnYXNMaW1pdDogYXdhaXQgdHguZ2V0T3ZlcnJpZGVzKCkuZ2FzTGltaXQsXG4gICAgICBtYXhGZWVQZXJHYXM6IGF3YWl0IHR4LmdldE92ZXJyaWRlcygpLm1heEZlZVBlckdhcyxcbiAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBhd2FpdCB0eC5nZXRPdmVycmlkZXMoKS5tYXhQcmlvcml0eUZlZVBlckdhcyxcbiAgICAgIG5vbmNlOiBhd2FpdCB0eC5nZXRPdmVycmlkZXMoKS5ub25jZVxuICAgIH0sIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBiYXRjaERhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8vLy8gREVQTE9ZTUVOVFxuXG4gIC8qKlxuICAgKiBNYW51YWxseSBkZXBsb3kgdGhlIHNtYXJ0IHdhbGxldCBjb250cmFjdC4gSWYgYWxyZWFkeSBkZXBsb3llZCB0aGlzIHdpbGwgdGhyb3cgYW4gZXJyb3IuXG4gICAqIE5vdGUgdGhhdCB0aGlzIGlzIG5vdCBuZWNlc3NhcnkgYXMgdGhlIHNtYXJ0IHdhbGxldCB3aWxsIGJlIGRlcGxveWVkIGF1dG9tYXRpY2FsbHkgb24gdGhlIGZpcnN0IHRyYW5zYWN0aW9uIHRoZSB1c2VyIG1ha2VzLlxuICAgKiBAcmV0dXJucyBUaGUgdHJhbnNhY3Rpb24gcmVjZWlwdFxuICAgKi9cbiAgYXN5bmMgZGVwbG95KG9wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuYWNjb3VudEFwaSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGVyc29uYWwgd2FsbGV0IG5vdCBjb25uZWN0ZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IHRoaXMuZ2V0U2lnbmVyKCk7XG4gICAgY29uc3QgdHggPSBhd2FpdCBzaWduZXIuc2VuZFRyYW5zYWN0aW9uKHtcbiAgICAgIHRvOiBhd2FpdCBzaWduZXIuZ2V0QWRkcmVzcygpLFxuICAgICAgZGF0YTogXCIweFwiXG4gICAgfSwge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGJhdGNoRGF0YToge1xuICAgICAgICB0YXJnZXRzOiBbXSxcbiAgICAgICAgZGF0YTogW10sXG4gICAgICAgIHZhbHVlczogW11cbiAgICAgIH0gLy8gYmF0Y2hlZCB0eCBmbGFnIHRvIGF2b2lkIGhpdHRpbmcgdGhlIFJvdXRlciBmYWxsYmFjayBtZXRob2RcbiAgICB9KTtcbiAgICBjb25zdCByZWNlaXB0ID0gYXdhaXQgdHgud2FpdCgpO1xuICAgIHJldHVybiB7XG4gICAgICByZWNlaXB0XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgc21hcnQgd2FsbGV0IGNvbnRyYWN0IGlzIGRlcGxveWVkXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHNtYXJ0IHdhbGxldCBjb250cmFjdCBpcyBkZXBsb3llZFxuICAgKi9cbiAgYXN5bmMgaXNEZXBsb3llZCgpIHtcbiAgICBpZiAoIXRoaXMuYWNjb3VudEFwaSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGVyc29uYWwgd2FsbGV0IG5vdCBjb25uZWN0ZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCB0aGlzLmFjY291bnRBcGkuaXNBY291bnREZXBsb3llZCgpO1xuICB9XG4gIGFzeW5jIGRlcGxveUlmTmVlZGVkKG9wdGlvbnMpIHtcbiAgICBjb25zdCBpc0RlcGxveWVkID0gYXdhaXQgdGhpcy5pc0RlcGxveWVkKCk7XG4gICAgaWYgKCFpc0RlcGxveWVkKSB7XG4gICAgICBhd2FpdCB0aGlzLmRlcGxveShvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICAvLy8vIFBFUk1JU1NJT05TXG5cbiAgYXN5bmMgZ3JhbnRQZXJtaXNzaW9ucyh0YXJnZXQsIHBlcm1pc3Npb25zKSB7XG4gICAgY29uc3QgYWNjb3VudENvbnRyYWN0ID0gYXdhaXQgdGhpcy5nZXRBY2NvdW50Q29udHJhY3QoKTtcbiAgICByZXR1cm4gYWNjb3VudENvbnRyYWN0LmFjY291bnQuZ3JhbnRQZXJtaXNzaW9ucyh0YXJnZXQsIHBlcm1pc3Npb25zKTtcbiAgfVxuICBhc3luYyByZXZva2VQZXJtaXNzaW9ucyh0YXJnZXQpIHtcbiAgICBjb25zdCBhY2NvdW50Q29udHJhY3QgPSBhd2FpdCB0aGlzLmdldEFjY291bnRDb250cmFjdCgpO1xuICAgIHJldHVybiBhY2NvdW50Q29udHJhY3QuYWNjb3VudC5yZXZva2VBY2Nlc3ModGFyZ2V0KTtcbiAgfVxuICBhc3luYyBhZGRBZG1pbih0YXJnZXQpIHtcbiAgICBjb25zdCBhY2NvdW50Q29udHJhY3QgPSBhd2FpdCB0aGlzLmdldEFjY291bnRDb250cmFjdCgpO1xuICAgIHJldHVybiBhY2NvdW50Q29udHJhY3QuYWNjb3VudC5ncmFudEFkbWluUGVybWlzc2lvbnModGFyZ2V0KTtcbiAgfVxuICBhc3luYyByZW1vdmVBZG1pbih0YXJnZXQpIHtcbiAgICBjb25zdCBhY2NvdW50Q29udHJhY3QgPSBhd2FpdCB0aGlzLmdldEFjY291bnRDb250cmFjdCgpO1xuICAgIHJldHVybiBhY2NvdW50Q29udHJhY3QuYWNjb3VudC5yZXZva2VBZG1pblBlcm1pc3Npb25zKHRhcmdldCk7XG4gIH1cbiAgYXN5bmMgZ2V0QWxsQWN0aXZlU2lnbmVycygpIHtcbiAgICBjb25zdCBpc0RlcGxveWVkID0gYXdhaXQgdGhpcy5pc0RlcGxveWVkKCk7XG4gICAgaWYgKGlzRGVwbG95ZWQpIHtcbiAgICAgIGNvbnN0IGFjY291bnRDb250cmFjdCA9IGF3YWl0IHRoaXMuZ2V0QWNjb3VudENvbnRyYWN0KCk7XG4gICAgICByZXR1cm4gYWNjb3VudENvbnRyYWN0LmFjY291bnQuZ2V0QWxsQWRtaW5zQW5kU2lnbmVycygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwZXJzb25hbFdhbGxldCA9IGF3YWl0IHRoaXMucGVyc29uYWxXYWxsZXQ/LmdldFNpZ25lcigpO1xuICAgICAgaWYgKCFwZXJzb25hbFdhbGxldCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQZXJzb25hbCB3YWxsZXQgbm90IGNvbm5lY3RlZFwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbe1xuICAgICAgICBpc0FkbWluOiB0cnVlLFxuICAgICAgICBzaWduZXI6IGF3YWl0IHBlcnNvbmFsV2FsbGV0LmdldEFkZHJlc3MoKSxcbiAgICAgICAgcGVybWlzc2lvbnM6IHtcbiAgICAgICAgICBzdGFydERhdGU6IG5ldyBEYXRlKDApLFxuICAgICAgICAgIGV4cGlyYXRpb25EYXRlOiBuZXcgRGF0ZSgwKSxcbiAgICAgICAgICBuYXRpdmVUb2tlbkxpbWl0UGVyVHJhbnNhY3Rpb246IEJpZ051bWJlci5mcm9tKDApLFxuICAgICAgICAgIGFwcHJvdmVkQ2FsbFRhcmdldHM6IFtdXG4gICAgICAgIH1cbiAgICAgIH1dO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHVuZGVybHlpbmcgYWNjb3VudCBjb250cmFjdCBvZiB0aGUgc21hcnQgd2FsbGV0LlxuICAgKiBAcmV0dXJucyBUaGUgYWNjb3VudCBjb250cmFjdCBvZiB0aGUgc21hcnQgd2FsbGV0LlxuICAgKi9cbiAgYXN5bmMgZ2V0QWNjb3VudENvbnRyYWN0KCkge1xuICAgIC8vIGdldHRpbmcgYSBuZXcgaW5zdGFuY2UgZXZlcnl0aW1lXG4gICAgLy8gdG8gYXZvaWQgY2FjaGluZyBpc3N1ZXMgcHJlL3Bvc3QgZGVwbG95bWVudFxuICAgIGNvbnN0IHNkayA9IFRoaXJkd2ViU0RLLmZyb21TaWduZXIoYXdhaXQgdGhpcy5nZXRTaWduZXIoKSwgdGhpcy5jb25maWcuY2hhaW4sIHtcbiAgICAgIGNsaWVudElkOiB0aGlzLmNvbmZpZy5jbGllbnRJZCxcbiAgICAgIHNlY3JldEtleTogdGhpcy5jb25maWcuc2VjcmV0S2V5XG4gICAgfSk7XG4gICAgaWYgKHRoaXMuY29uZmlnLmFjY291bnRJbmZvPy5hYmkpIHtcbiAgICAgIHJldHVybiBzZGsuZ2V0Q29udHJhY3QoYXdhaXQgdGhpcy5nZXRBZGRyZXNzKCksIHRoaXMuY29uZmlnLmFjY291bnRJbmZvLmFiaSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzZGsuZ2V0Q29udHJhY3QoYXdhaXQgdGhpcy5nZXRBZGRyZXNzKCksIEFDQ09VTlRfQ09SRV9BQkkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHVuZGVybHlpbmcgYWNjb3VudCBmYWN0b3J5IGNvbnRyYWN0IG9mIHRoZSBzbWFydCB3YWxsZXQuXG4gICAqIEByZXR1cm5zIFRoZSBhY2NvdW50IGZhY3RvcnkgY29udHJhY3QuXG4gICAqL1xuICBhc3luYyBnZXRGYWN0b3J5Q29udHJhY3QoKSB7XG4gICAgaWYgKCF0aGlzLmNvbmZpZy5mYWN0b3J5QWRkcmVzcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFjdG9yeSBhZGRyZXNzIG5vdCBzZXQhXCIpO1xuICAgIH1cbiAgICBjb25zdCBzZGsgPSBUaGlyZHdlYlNESy5mcm9tU2lnbmVyKGF3YWl0IHRoaXMuZ2V0U2lnbmVyKCksIHRoaXMuY29uZmlnLmNoYWluLCB7XG4gICAgICBjbGllbnRJZDogdGhpcy5jb25maWcuY2xpZW50SWQsXG4gICAgICBzZWNyZXRLZXk6IHRoaXMuY29uZmlnLnNlY3JldEtleVxuICAgIH0pO1xuICAgIGlmICh0aGlzLmNvbmZpZy5mYWN0b3J5SW5mbz8uYWJpKSB7XG4gICAgICByZXR1cm4gc2RrLmdldENvbnRyYWN0KHRoaXMuY29uZmlnLmZhY3RvcnlBZGRyZXNzLCB0aGlzLmNvbmZpZy5mYWN0b3J5SW5mby5hYmkpO1xuICAgIH1cbiAgICByZXR1cm4gc2RrLmdldENvbnRyYWN0KHRoaXMuY29uZmlnLmZhY3RvcnlBZGRyZXNzKTtcbiAgfVxuICBkZWZhdWx0RmFjdG9yeUluZm8oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNyZWF0ZUFjY291bnQ6IGFzeW5jIChmYWN0b3J5LCBvd25lcikgPT4ge1xuICAgICAgICByZXR1cm4gZmFjdG9yeS5wcmVwYXJlKFwiY3JlYXRlQWNjb3VudFwiLCBbb3duZXIsIGV0aGVycy51dGlscy50b1V0ZjhCeXRlcyhcIlwiKV0pO1xuICAgICAgfSxcbiAgICAgIGdldEFjY291bnRBZGRyZXNzOiBhc3luYyAoZmFjdG9yeSwgb3duZXIpID0+IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGZhY3RvcnkuY2FsbChcImdldEFkZHJlc3NcIiwgW293bmVyLCBldGhlcnMudXRpbHMudG9VdGY4Qnl0ZXMoXCJcIildKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGRlZmF1bHRBY2NvdW50SW5mbygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXhlY3V0ZTogYXN5bmMgKGFjY291bnQsIHRhcmdldCwgdmFsdWUsIGRhdGEpID0+IHtcbiAgICAgICAgcmV0dXJuIGFjY291bnQucHJlcGFyZShcImV4ZWN1dGVcIiwgW3RhcmdldCwgdmFsdWUsIGRhdGFdKTtcbiAgICAgIH0sXG4gICAgICBnZXROb25jZTogYXN5bmMgYWNjb3VudCA9PiB7XG4gICAgICAgIHJldHVybiBhY2NvdW50LmNhbGwoXCJnZXROb25jZVwiLCBbXSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vLyBQUklWQVRFIE1FVEhPRFNcblxuICBhc3luYyBlc3RpbWF0ZVR4KHR4LCBvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmFjY291bnRBcGkgfHwgIXRoaXMuYWFQcm92aWRlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGVyc29uYWwgd2FsbGV0IG5vdCBjb25uZWN0ZWRcIik7XG4gICAgfVxuICAgIGxldCBkZXBsb3lHYXNMaW1pdCA9IEJpZ051bWJlci5mcm9tKDApO1xuICAgIGNvbnN0IFtwcm92aWRlciwgaXNEZXBsb3llZF0gPSBhd2FpdCBQcm9taXNlLmFsbChbdGhpcy5nZXRQcm92aWRlcigpLCB0aGlzLmlzRGVwbG95ZWQoKV0pO1xuICAgIGlmICghaXNEZXBsb3llZCkge1xuICAgICAgZGVwbG95R2FzTGltaXQgPSBhd2FpdCB0aGlzLmVzdGltYXRlRGVwbG95bWVudEdhc0xpbWl0KCk7XG4gICAgfVxuICAgIGNvbnN0IFt1c2VyT3AsIGdhc1ByaWNlXSA9IGF3YWl0IFByb21pc2UuYWxsKFt0aGlzLmFjY291bnRBcGkuY3JlYXRlVW5zaWduZWRVc2VyT3AodGhpcy5hYVByb3ZpZGVyLmh0dHBScGNDbGllbnQsIHR4LCBvcHRpb25zKSwgZ2V0R2FzUHJpY2UocHJvdmlkZXIpXSk7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSBhd2FpdCB1dGlscy5yZXNvbHZlUHJvcGVydGllcyh1c2VyT3ApO1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uR2FzTGltaXQgPSBCaWdOdW1iZXIuZnJvbShyZXNvbHZlZC5jYWxsR2FzTGltaXQpO1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uQ29zdCA9IHRyYW5zYWN0aW9uR2FzTGltaXQubXVsKGdhc1ByaWNlKTtcbiAgICBjb25zdCBkZXBsb3lDb3N0ID0gZGVwbG95R2FzTGltaXQubXVsKGdhc1ByaWNlKTtcbiAgICBjb25zdCB0b3RhbENvc3QgPSBkZXBsb3lDb3N0LmFkZCh0cmFuc2FjdGlvbkNvc3QpO1xuICAgIHJldHVybiB7XG4gICAgICBldGhlcjogdXRpbHMuZm9ybWF0RXRoZXIodG90YWxDb3N0KSxcbiAgICAgIHdlaTogdG90YWxDb3N0LFxuICAgICAgZGV0YWlsczoge1xuICAgICAgICBkZXBsb3lHYXNMaW1pdCxcbiAgICAgICAgdHJhbnNhY3Rpb25HYXNMaW1pdCxcbiAgICAgICAgZ2FzUHJpY2UsXG4gICAgICAgIHRyYW5zYWN0aW9uQ29zdCxcbiAgICAgICAgZGVwbG95Q29zdCxcbiAgICAgICAgdG90YWxDb3N0XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBhc3luYyBlc3RpbWF0ZURlcGxveW1lbnRHYXNMaW1pdCgpIHtcbiAgICBpZiAoIXRoaXMuYWNjb3VudEFwaSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGVyc29uYWwgd2FsbGV0IG5vdCBjb25uZWN0ZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IGluaXRDb2RlID0gYXdhaXQgdGhpcy5hY2NvdW50QXBpLmdldEluaXRDb2RlKCk7XG4gICAgY29uc3QgW2luaXRHYXMsIHZlcmlmaWNhdGlvbkdhc0xpbWl0XSA9IGF3YWl0IFByb21pc2UuYWxsKFt0aGlzLmFjY291bnRBcGkuZXN0aW1hdGVDcmVhdGlvbkdhcyhpbml0Q29kZSksIHRoaXMuYWNjb3VudEFwaS5nZXRWZXJpZmljYXRpb25HYXNMaW1pdCgpXSk7XG4gICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKHZlcmlmaWNhdGlvbkdhc0xpbWl0KS5hZGQoaW5pdEdhcyk7XG4gIH1cbiAgYXN5bmMgcHJlcGFyZUJhdGNoUmF3KHRyYW5zYWN0aW9ucykge1xuICAgIGlmICghdGhpcy5hY2NvdW50QXBpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQZXJzb25hbCB3YWxsZXQgbm90IGNvbm5lY3RlZFwiKTtcbiAgICB9XG4gICAgY29uc3QgcmVzb2x2ZWRUeHMgPSBhd2FpdCBQcm9taXNlLmFsbCh0cmFuc2FjdGlvbnMubWFwKHRyYW5zYWN0aW9uID0+IGV0aGVycy51dGlscy5yZXNvbHZlUHJvcGVydGllcyh0cmFuc2FjdGlvbikpKTtcbiAgICBjb25zdCB0YXJnZXRzID0gcmVzb2x2ZWRUeHMubWFwKHR4ID0+IHR4LnRvIHx8IGNvbnN0YW50cy5BZGRyZXNzWmVybyk7XG4gICAgY29uc3QgZGF0YSA9IHJlc29sdmVkVHhzLm1hcCh0eCA9PiB0eC5kYXRhIHx8IFwiMHhcIik7XG4gICAgY29uc3QgdmFsdWVzID0gcmVzb2x2ZWRUeHMubWFwKHR4ID0+IHR4LnZhbHVlIHx8IEJpZ051bWJlci5mcm9tKDApKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHg6IGF3YWl0IHRoaXMuYWNjb3VudEFwaS5wcmVwYXJlRXhlY3V0ZUJhdGNoKHRhcmdldHMsIHZhbHVlcywgZGF0YSksXG4gICAgICBiYXRjaERhdGE6IHtcbiAgICAgICAgdGFyZ2V0cyxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgdmFsdWVzXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBhc3luYyBwcmVwYXJlQmF0Y2hUeCh0cmFuc2FjdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuYWNjb3VudEFwaSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGVyc29uYWwgd2FsbGV0IG5vdCBjb25uZWN0ZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldHMgPSB0cmFuc2FjdGlvbnMubWFwKHR4ID0+IHR4LmdldFRhcmdldCgpKTtcbiAgICBjb25zdCBkYXRhID0gdHJhbnNhY3Rpb25zLm1hcCh0eCA9PiB0eC5lbmNvZGUoKSk7XG4gICAgY29uc3QgdmFsdWVzID0gYXdhaXQgUHJvbWlzZS5hbGwodHJhbnNhY3Rpb25zLm1hcCh0eCA9PiB0eC5nZXRWYWx1ZSgpKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR4OiBhd2FpdCB0aGlzLmFjY291bnRBcGkucHJlcGFyZUV4ZWN1dGVCYXRjaCh0YXJnZXRzLCB2YWx1ZXMsIGRhdGEpLFxuICAgICAgYmF0Y2hEYXRhOiB7XG4gICAgICAgIHRhcmdldHMsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHZhbHVlc1xuICAgICAgfVxuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IHsgU21hcnRXYWxsZXRDb25uZWN0b3IgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/evm/connectors/smart-wallet/dist/thirdweb-dev-wallets-evm-connectors-smart-wallet.browser.esm.js\n"));

/***/ }),

/***/ "./node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/evm/connectors/token-bound-smart-wallet/dist/thirdweb-dev-wallets-evm-connectors-token-bound-smart-wallet.browser.esm.js":
/*!******************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/evm/connectors/token-bound-smart-wallet/dist/thirdweb-dev-wallets-evm-connectors-token-bound-smart-wallet.browser.esm.js ***!
  \******************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TokenBoundSmartWalletConnector\": function() { return /* binding */ TokenBoundSmartWalletConnector; }\n/* harmony export */ });\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ethers */ \"./node_modules/ethers/lib.esm/index.js\");\n/* harmony import */ var _smart_wallet_dist_thirdweb_dev_wallets_evm_connectors_smart_wallet_browser_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../smart-wallet/dist/thirdweb-dev-wallets-evm-connectors-smart-wallet.browser.esm.js */ \"./node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/evm/connectors/smart-wallet/dist/thirdweb-dev-wallets-evm-connectors-smart-wallet.browser.esm.js\");\n/* harmony import */ var _dist_utils_f58e7acc_browser_esm_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../dist/utils-f58e7acc.browser.esm.js */ \"./node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/dist/utils-f58e7acc.browser.esm.js\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! eventemitter3 */ \"./node_modules/@thirdweb-dev/react/node_modules/eventemitter3/index.mjs\");\n/* harmony import */ var _account_abstraction_contracts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @account-abstraction/contracts */ \"./node_modules/@account-abstraction/contracts/dist/index.js\");\n/* harmony import */ var _account_abstraction_contracts__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_account_abstraction_contracts__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _wallets_abstract_dist_thirdweb_dev_wallets_evm_wallets_abstract_browser_esm_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../wallets/abstract/dist/thirdweb-dev-wallets-evm-wallets-abstract.browser.esm.js */ \"./node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/evm/wallets/abstract/dist/thirdweb-dev-wallets-evm-wallets-abstract.browser.esm.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass TokenBoundSmartWalletConnector extends _smart_wallet_dist_thirdweb_dev_wallets_evm_connectors_smart_wallet_browser_esm_js__WEBPACK_IMPORTED_MODULE_0__.SmartWalletConnector {\n  constructor(input) {\n    super({\n      ...input,\n      factoryAddress: input.registryAddress || _dist_utils_f58e7acc_browser_esm_js__WEBPACK_IMPORTED_MODULE_4__.E\n    });\n    this.tbaConfig = input;\n    // TODO default account implementation address\n  }\n  defaultFactoryInfo() {\n    return {\n      createAccount: async factory => {\n        return factory.prepare(\"createAccount\", [this.tbaConfig.accountImplementation, this.chainId, this.tbaConfig.tokenContract, this.tbaConfig.tokenId, this.tbaConfig.salt, ethers__WEBPACK_IMPORTED_MODULE_5__.ethers.utils.toUtf8Bytes(\"\")]);\n      },\n      getAccountAddress: async factory => {\n        return await factory.call(\"account\", [this.tbaConfig.accountImplementation, this.chainId, this.tbaConfig.tokenContract, this.tbaConfig.tokenId, this.tbaConfig.salt]);\n      }\n    };\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRoaXJkd2ViLWRldi9yZWFjdC9ub2RlX21vZHVsZXMvQHRoaXJkd2ViLWRldi93YWxsZXRzL2V2bS9jb25uZWN0b3JzL3Rva2VuLWJvdW5kLXNtYXJ0LXdhbGxldC9kaXN0L3RoaXJkd2ViLWRldi13YWxsZXRzLWV2bS1jb25uZWN0b3JzLXRva2VuLWJvdW5kLXNtYXJ0LXdhbGxldC5icm93c2VyLmVzbS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFnQztBQUMrRjtBQUN4QztBQUMzQjtBQUNyQztBQUMyQztBQUNaO0FBQ3hCO0FBQzRCO0FBQ2xCO0FBQ3lCO0FBQ3RDO0FBQ3NFOztBQUVqRyw2Q0FBNkMsb0lBQW9CO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxrRUFBZ0I7QUFDL0QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdMQUFnTCw0REFBd0I7QUFDeE0sT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B0aGlyZHdlYi1kZXYvcmVhY3Qvbm9kZV9tb2R1bGVzL0B0aGlyZHdlYi1kZXYvd2FsbGV0cy9ldm0vY29ubmVjdG9ycy90b2tlbi1ib3VuZC1zbWFydC13YWxsZXQvZGlzdC90aGlyZHdlYi1kZXYtd2FsbGV0cy1ldm0tY29ubmVjdG9ycy10b2tlbi1ib3VuZC1zbWFydC13YWxsZXQuYnJvd3Nlci5lc20uanM/N2UwNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBldGhlcnMgfSBmcm9tICdldGhlcnMnO1xuaW1wb3J0IHsgU21hcnRXYWxsZXRDb25uZWN0b3IgfSBmcm9tICcuLi8uLi9zbWFydC13YWxsZXQvZGlzdC90aGlyZHdlYi1kZXYtd2FsbGV0cy1ldm0tY29ubmVjdG9ycy1zbWFydC13YWxsZXQuYnJvd3Nlci5lc20uanMnO1xuaW1wb3J0IHsgRSBhcyBFUkM2NTUxX1JFR0lTVFJZIH0gZnJvbSAnLi4vLi4vLi4vLi4vZGlzdC91dGlscy1mNThlN2FjYy5icm93c2VyLmVzbS5qcyc7XG5pbXBvcnQgJy4uLy4uLy4uLy4uL2Rpc3QvY29ubmVjdG9yLTA1Njg5ZDY4LmJyb3dzZXIuZXNtLmpzJztcbmltcG9ydCAnZXZlbnRlbWl0dGVyMyc7XG5pbXBvcnQgJy4uLy4uLy4uLy4uL2Rpc3QvaHR0cC1ycGMtY2xpZW50LTBhMDc5ZTgwLmJyb3dzZXIuZXNtLmpzJztcbmltcG9ydCAnLi4vLi4vLi4vLi4vZGlzdC91cmwtYTQ1MjE5YmQuYnJvd3Nlci5lc20uanMnO1xuaW1wb3J0ICdAdGhpcmR3ZWItZGV2L2NoYWlucyc7XG5pbXBvcnQgJy4uLy4uLy4uLy4uL2Rpc3QvaGVhZGVycy03MzNhODE5OS5icm93c2VyLmVzbS5qcyc7XG5pbXBvcnQgJ0BhY2NvdW50LWFic3RyYWN0aW9uL2NvbnRyYWN0cyc7XG5pbXBvcnQgJy4uLy4uLy4uLy4uL2Rpc3QvZGVmaW5lUHJvcGVydHktMzUwZmM1MDguYnJvd3Nlci5lc20uanMnO1xuaW1wb3J0ICdAdGhpcmR3ZWItZGV2L3Nkayc7XG5pbXBvcnQgJy4uLy4uLy4uL3dhbGxldHMvYWJzdHJhY3QvZGlzdC90aGlyZHdlYi1kZXYtd2FsbGV0cy1ldm0td2FsbGV0cy1hYnN0cmFjdC5icm93c2VyLmVzbS5qcyc7XG5cbmNsYXNzIFRva2VuQm91bmRTbWFydFdhbGxldENvbm5lY3RvciBleHRlbmRzIFNtYXJ0V2FsbGV0Q29ubmVjdG9yIHtcbiAgY29uc3RydWN0b3IoaW5wdXQpIHtcbiAgICBzdXBlcih7XG4gICAgICAuLi5pbnB1dCxcbiAgICAgIGZhY3RvcnlBZGRyZXNzOiBpbnB1dC5yZWdpc3RyeUFkZHJlc3MgfHwgRVJDNjU1MV9SRUdJU1RSWVxuICAgIH0pO1xuICAgIHRoaXMudGJhQ29uZmlnID0gaW5wdXQ7XG4gICAgLy8gVE9ETyBkZWZhdWx0IGFjY291bnQgaW1wbGVtZW50YXRpb24gYWRkcmVzc1xuICB9XG4gIGRlZmF1bHRGYWN0b3J5SW5mbygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY3JlYXRlQWNjb3VudDogYXN5bmMgZmFjdG9yeSA9PiB7XG4gICAgICAgIHJldHVybiBmYWN0b3J5LnByZXBhcmUoXCJjcmVhdGVBY2NvdW50XCIsIFt0aGlzLnRiYUNvbmZpZy5hY2NvdW50SW1wbGVtZW50YXRpb24sIHRoaXMuY2hhaW5JZCwgdGhpcy50YmFDb25maWcudG9rZW5Db250cmFjdCwgdGhpcy50YmFDb25maWcudG9rZW5JZCwgdGhpcy50YmFDb25maWcuc2FsdCwgZXRoZXJzLnV0aWxzLnRvVXRmOEJ5dGVzKFwiXCIpXSk7XG4gICAgICB9LFxuICAgICAgZ2V0QWNjb3VudEFkZHJlc3M6IGFzeW5jIGZhY3RvcnkgPT4ge1xuICAgICAgICByZXR1cm4gYXdhaXQgZmFjdG9yeS5jYWxsKFwiYWNjb3VudFwiLCBbdGhpcy50YmFDb25maWcuYWNjb3VudEltcGxlbWVudGF0aW9uLCB0aGlzLmNoYWluSWQsIHRoaXMudGJhQ29uZmlnLnRva2VuQ29udHJhY3QsIHRoaXMudGJhQ29uZmlnLnRva2VuSWQsIHRoaXMudGJhQ29uZmlnLnNhbHRdKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCB7IFRva2VuQm91bmRTbWFydFdhbGxldENvbm5lY3RvciB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/evm/connectors/token-bound-smart-wallet/dist/thirdweb-dev-wallets-evm-connectors-token-bound-smart-wallet.browser.esm.js\n"));

/***/ })

}]);