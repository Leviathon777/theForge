"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["node_modules_thirdweb-dev_sdk_node_modules_thirdweb_dist_esm_storage_upload_js"],{

/***/ "./node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/storage/upload.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/storage/upload.js ***!
  \*****************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"upload\": function() { return /* binding */ upload; }\n/* harmony export */ });\n/* harmony import */ var _utils_detect_platform_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/detect-platform.js */ \"./node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/detect-platform.js\");\n/* harmony import */ var _utils_json_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/json.js */ \"./node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/json.js\");\n/* harmony import */ var _upload_helpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./upload/helpers.js */ \"./node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/storage/upload/helpers.js\");\n\n\n\n/**\n * Uploads files based on the provided options.\n * @param options - The upload options.\n * @returns A promise that resolves to the uploaded file URI or URIs (when passing multiple files).\n * @throws An error if the upload fails.\n * @example\n * ```ts\n * import { upload } from \"thirdweb/storage\";\n * const uri = await upload({\n *  client,\n *  files: [\n *    new File([\"hello world\"], \"hello.txt\"),\n *  ],\n * });\n * ```\n * @storage\n */\nasync function upload(options) {\n    // deal with the differnt file types\n    // if there are no files, return an empty array immediately\n    if (options.files.length === 0) {\n        return null;\n    }\n    // handle file arrays\n    const isFileArray = options.files\n        .map((item) => (0,_upload_helpers_js__WEBPACK_IMPORTED_MODULE_0__.isFileOrUint8Array)(item) || typeof item === \"string\")\n        .every((item) => !!item);\n    let uris;\n    if (isFileArray) {\n        // if we already have an array of files, we can just pass it through\n        uris = options.files;\n    }\n    else {\n        // otherwise we have to process them first\n        let cleaned = options.files;\n        // Replace any gateway URLs with their hashes\n        cleaned = (0,_upload_helpers_js__WEBPACK_IMPORTED_MODULE_0__.replaceObjectGatewayUrlsWithSchemes)(cleaned);\n        // Recurse through data and extract files to upload\n        const files = (0,_upload_helpers_js__WEBPACK_IMPORTED_MODULE_0__.extractObjectFiles)(cleaned);\n        if (files.length) {\n            // Upload all files that came from the object\n            const uris_ = await upload({ ...options, files });\n            // Recurse through data and replace files with hashes\n            cleaned = (0,_upload_helpers_js__WEBPACK_IMPORTED_MODULE_0__.replaceObjectFilesWithUris)(cleaned, \n            // always pass an array even if the underlying upload returns a single uri\n            Array.isArray(uris_) ? uris_ : [uris_]);\n        }\n        uris = cleaned.map((item) => {\n            if (typeof item === \"string\") {\n                return item;\n            }\n            return (0,_utils_json_js__WEBPACK_IMPORTED_MODULE_1__.stringify)(item);\n        });\n    }\n    // end deal with the differnt file types\n    const form_ = new FormData();\n    const { fileNames, form } = (0,_upload_helpers_js__WEBPACK_IMPORTED_MODULE_0__.buildFormData)(form_, uris, options);\n    const platform = (0,_utils_detect_platform_js__WEBPACK_IMPORTED_MODULE_2__.detectPlatform)();\n    if (platform === \"browser\" || platform === \"node\") {\n        const { uploadBatch } = await __webpack_require__.e(/*! import() */ \"node_modules_thirdweb-dev_sdk_node_modules_thirdweb_dist_esm_storage_upload_web-node_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./upload/web-node.js */ \"./node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/storage/upload/web-node.js\"));\n        const uris = await uploadBatch(options.client, form, fileNames, options);\n        // if we only passed a single file, return its URI directly\n        if (options.files.length === 1) {\n            return uris[0];\n        }\n        return uris;\n    }\n    throw new Error(\"Please, use the uploadMobile function in mobile environments.\");\n}\n//# sourceMappingURL=upload.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRoaXJkd2ViLWRldi9zZGsvbm9kZV9tb2R1bGVzL3RoaXJkd2ViL2Rpc3QvZXNtL3N0b3JhZ2UvdXBsb2FkLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBNkQ7QUFDaEI7QUFDaUg7QUFDOUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNFQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix1RkFBbUM7QUFDckQ7QUFDQSxzQkFBc0Isc0VBQWtCO0FBQ3hDO0FBQ0E7QUFDQSx5Q0FBeUMsbUJBQW1CO0FBQzVEO0FBQ0Esc0JBQXNCLDhFQUEwQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5REFBUztBQUM1QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQkFBa0IsRUFBRSxpRUFBYTtBQUM3QyxxQkFBcUIseUVBQWM7QUFDbkM7QUFDQSxnQkFBZ0IsY0FBYyxRQUFRLDhTQUE4QjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHRoaXJkd2ViLWRldi9zZGsvbm9kZV9tb2R1bGVzL3RoaXJkd2ViL2Rpc3QvZXNtL3N0b3JhZ2UvdXBsb2FkLmpzPzlhMDIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGV0ZWN0UGxhdGZvcm0gfSBmcm9tIFwiLi4vdXRpbHMvZGV0ZWN0LXBsYXRmb3JtLmpzXCI7XG5pbXBvcnQgeyBzdHJpbmdpZnkgfSBmcm9tIFwiLi4vdXRpbHMvanNvbi5qc1wiO1xuaW1wb3J0IHsgYnVpbGRGb3JtRGF0YSwgZXh0cmFjdE9iamVjdEZpbGVzLCBpc0ZpbGVPclVpbnQ4QXJyYXksIHJlcGxhY2VPYmplY3RGaWxlc1dpdGhVcmlzLCByZXBsYWNlT2JqZWN0R2F0ZXdheVVybHNXaXRoU2NoZW1lcywgfSBmcm9tIFwiLi91cGxvYWQvaGVscGVycy5qc1wiO1xuLyoqXG4gKiBVcGxvYWRzIGZpbGVzIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBvcHRpb25zLlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgdXBsb2FkIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgdXBsb2FkZWQgZmlsZSBVUkkgb3IgVVJJcyAod2hlbiBwYXNzaW5nIG11bHRpcGxlIGZpbGVzKS5cbiAqIEB0aHJvd3MgQW4gZXJyb3IgaWYgdGhlIHVwbG9hZCBmYWlscy5cbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgdXBsb2FkIH0gZnJvbSBcInRoaXJkd2ViL3N0b3JhZ2VcIjtcbiAqIGNvbnN0IHVyaSA9IGF3YWl0IHVwbG9hZCh7XG4gKiAgY2xpZW50LFxuICogIGZpbGVzOiBbXG4gKiAgICBuZXcgRmlsZShbXCJoZWxsbyB3b3JsZFwiXSwgXCJoZWxsby50eHRcIiksXG4gKiAgXSxcbiAqIH0pO1xuICogYGBgXG4gKiBAc3RvcmFnZVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBsb2FkKG9wdGlvbnMpIHtcbiAgICAvLyBkZWFsIHdpdGggdGhlIGRpZmZlcm50IGZpbGUgdHlwZXNcbiAgICAvLyBpZiB0aGVyZSBhcmUgbm8gZmlsZXMsIHJldHVybiBhbiBlbXB0eSBhcnJheSBpbW1lZGlhdGVseVxuICAgIGlmIChvcHRpb25zLmZpbGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gaGFuZGxlIGZpbGUgYXJyYXlzXG4gICAgY29uc3QgaXNGaWxlQXJyYXkgPSBvcHRpb25zLmZpbGVzXG4gICAgICAgIC5tYXAoKGl0ZW0pID0+IGlzRmlsZU9yVWludDhBcnJheShpdGVtKSB8fCB0eXBlb2YgaXRlbSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgLmV2ZXJ5KChpdGVtKSA9PiAhIWl0ZW0pO1xuICAgIGxldCB1cmlzO1xuICAgIGlmIChpc0ZpbGVBcnJheSkge1xuICAgICAgICAvLyBpZiB3ZSBhbHJlYWR5IGhhdmUgYW4gYXJyYXkgb2YgZmlsZXMsIHdlIGNhbiBqdXN0IHBhc3MgaXQgdGhyb3VnaFxuICAgICAgICB1cmlzID0gb3B0aW9ucy5maWxlcztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIG90aGVyd2lzZSB3ZSBoYXZlIHRvIHByb2Nlc3MgdGhlbSBmaXJzdFxuICAgICAgICBsZXQgY2xlYW5lZCA9IG9wdGlvbnMuZmlsZXM7XG4gICAgICAgIC8vIFJlcGxhY2UgYW55IGdhdGV3YXkgVVJMcyB3aXRoIHRoZWlyIGhhc2hlc1xuICAgICAgICBjbGVhbmVkID0gcmVwbGFjZU9iamVjdEdhdGV3YXlVcmxzV2l0aFNjaGVtZXMoY2xlYW5lZCk7XG4gICAgICAgIC8vIFJlY3Vyc2UgdGhyb3VnaCBkYXRhIGFuZCBleHRyYWN0IGZpbGVzIHRvIHVwbG9hZFxuICAgICAgICBjb25zdCBmaWxlcyA9IGV4dHJhY3RPYmplY3RGaWxlcyhjbGVhbmVkKTtcbiAgICAgICAgaWYgKGZpbGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gVXBsb2FkIGFsbCBmaWxlcyB0aGF0IGNhbWUgZnJvbSB0aGUgb2JqZWN0XG4gICAgICAgICAgICBjb25zdCB1cmlzXyA9IGF3YWl0IHVwbG9hZCh7IC4uLm9wdGlvbnMsIGZpbGVzIH0pO1xuICAgICAgICAgICAgLy8gUmVjdXJzZSB0aHJvdWdoIGRhdGEgYW5kIHJlcGxhY2UgZmlsZXMgd2l0aCBoYXNoZXNcbiAgICAgICAgICAgIGNsZWFuZWQgPSByZXBsYWNlT2JqZWN0RmlsZXNXaXRoVXJpcyhjbGVhbmVkLCBcbiAgICAgICAgICAgIC8vIGFsd2F5cyBwYXNzIGFuIGFycmF5IGV2ZW4gaWYgdGhlIHVuZGVybHlpbmcgdXBsb2FkIHJldHVybnMgYSBzaW5nbGUgdXJpXG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KHVyaXNfKSA/IHVyaXNfIDogW3VyaXNfXSk7XG4gICAgICAgIH1cbiAgICAgICAgdXJpcyA9IGNsZWFuZWQubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdpZnkoaXRlbSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBlbmQgZGVhbCB3aXRoIHRoZSBkaWZmZXJudCBmaWxlIHR5cGVzXG4gICAgY29uc3QgZm9ybV8gPSBuZXcgRm9ybURhdGEoKTtcbiAgICBjb25zdCB7IGZpbGVOYW1lcywgZm9ybSB9ID0gYnVpbGRGb3JtRGF0YShmb3JtXywgdXJpcywgb3B0aW9ucyk7XG4gICAgY29uc3QgcGxhdGZvcm0gPSBkZXRlY3RQbGF0Zm9ybSgpO1xuICAgIGlmIChwbGF0Zm9ybSA9PT0gXCJicm93c2VyXCIgfHwgcGxhdGZvcm0gPT09IFwibm9kZVwiKSB7XG4gICAgICAgIGNvbnN0IHsgdXBsb2FkQmF0Y2ggfSA9IGF3YWl0IGltcG9ydChcIi4vdXBsb2FkL3dlYi1ub2RlLmpzXCIpO1xuICAgICAgICBjb25zdCB1cmlzID0gYXdhaXQgdXBsb2FkQmF0Y2gob3B0aW9ucy5jbGllbnQsIGZvcm0sIGZpbGVOYW1lcywgb3B0aW9ucyk7XG4gICAgICAgIC8vIGlmIHdlIG9ubHkgcGFzc2VkIGEgc2luZ2xlIGZpbGUsIHJldHVybiBpdHMgVVJJIGRpcmVjdGx5XG4gICAgICAgIGlmIChvcHRpb25zLmZpbGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHVyaXNbMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVyaXM7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIlBsZWFzZSwgdXNlIHRoZSB1cGxvYWRNb2JpbGUgZnVuY3Rpb24gaW4gbW9iaWxlIGVudmlyb25tZW50cy5cIik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11cGxvYWQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/storage/upload.js\n"));

/***/ }),

/***/ "./node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/storage/upload/helpers.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/storage/upload/helpers.js ***!
  \*************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"buildFormData\": function() { return /* binding */ buildFormData; },\n/* harmony export */   \"extractObjectFiles\": function() { return /* binding */ extractObjectFiles; },\n/* harmony export */   \"isFileBufferOrStringEqual\": function() { return /* binding */ isFileBufferOrStringEqual; },\n/* harmony export */   \"isFileOrUint8Array\": function() { return /* binding */ isFileOrUint8Array; },\n/* harmony export */   \"replaceGatewayUrlWithScheme\": function() { return /* binding */ replaceGatewayUrlWithScheme; },\n/* harmony export */   \"replaceObjectFilesWithUris\": function() { return /* binding */ replaceObjectFilesWithUris; },\n/* harmony export */   \"replaceObjectGatewayUrlsWithSchemes\": function() { return /* binding */ replaceObjectGatewayUrlsWithSchemes; }\n/* harmony export */ });\n/* harmony import */ var _utils_type_guards_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/type-guards.js */ \"./node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/type-guards.js\");\n/* harmony import */ var _utils_uint8_array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/uint8-array.js */ \"./node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/uint8-array.js\");\n\n\n/**\n * @internal\n */\nfunction isFileInstance(data) {\n    return globalThis.File && data instanceof File;\n}\n/**\n * @internal\n */\nfunction isBufferOrStringWithName(data) {\n    if (!data) {\n        return false;\n    }\n    if (!(0,_utils_type_guards_js__WEBPACK_IMPORTED_MODULE_0__.isObjectWithKeys)(data, [\"data\", \"name\"])) {\n        return false;\n    }\n    return !!(typeof data.name === \"string\" &&\n        (typeof data.data === \"string\" || (0,_utils_uint8_array_js__WEBPACK_IMPORTED_MODULE_1__.isUint8Array)(data.data)));\n}\nfunction isFileBufferOrStringEqual(input1, input2) {\n    if (isFileInstance(input1) && isFileInstance(input2)) {\n        // if both are File types, compare the name, size, and last modified date (best guess that these are the same files)\n        if (input1.name === input2.name &&\n            input1.lastModified === input2.lastModified &&\n            input1.size === input2.size) {\n            return true;\n        }\n    }\n    else if ((0,_utils_uint8_array_js__WEBPACK_IMPORTED_MODULE_1__.isUint8Array)(input1) && (0,_utils_uint8_array_js__WEBPACK_IMPORTED_MODULE_1__.isUint8Array)(input2)) {\n        // buffer gives us an easy way to compare the contents!\n        return (0,_utils_uint8_array_js__WEBPACK_IMPORTED_MODULE_1__.areUint8ArraysEqual)(input1, input2);\n    }\n    else if (isBufferOrStringWithName(input1) &&\n        isBufferOrStringWithName(input2)) {\n        // first check the names\n        if (input1.name === input2.name) {\n            // if the data for both is a string, compare the strings\n            if (typeof input1.data === \"string\" && typeof input2.data === \"string\") {\n                return input1.data === input2.data;\n            }\n            if ((0,_utils_uint8_array_js__WEBPACK_IMPORTED_MODULE_1__.isUint8Array)(input1.data) && (0,_utils_uint8_array_js__WEBPACK_IMPORTED_MODULE_1__.isUint8Array)(input2.data)) {\n                // otherwise we know it's buffers, so compare the buffers\n                return (0,_utils_uint8_array_js__WEBPACK_IMPORTED_MODULE_1__.areUint8ArraysEqual)(input1.data, input2.data);\n            }\n        }\n    }\n    // otherwise if we have not found a match, return false\n    return false;\n}\nfunction buildFormData(form, files, options) {\n    const fileNameToFileMap = new Map();\n    const fileNames = [];\n    for (let i = 0; i < files.length; i++) {\n        // biome-ignore lint/style/noNonNullAssertion: we know that files[i] is not null or undefined because we are iterating over the array\n        const file = files[i];\n        let fileName = \"\";\n        let fileData = file;\n        if (isFileInstance(file)) {\n            if (options?.rewriteFileNames) {\n                let extensions = \"\";\n                if (file.name) {\n                    const extensionStartIndex = file.name.lastIndexOf(\".\");\n                    if (extensionStartIndex > -1) {\n                        extensions = file.name.substring(extensionStartIndex);\n                    }\n                }\n                fileName = `${i + options.rewriteFileNames.fileStartNumber}${extensions}`;\n            }\n            else {\n                fileName = `${file.name}`;\n            }\n        }\n        else if (isBufferOrStringWithName(file)) {\n            fileData = file.data;\n            if (options?.rewriteFileNames) {\n                fileName = `${i + options.rewriteFileNames.fileStartNumber}`;\n            }\n            else {\n                fileName = `${file.name}`;\n            }\n        }\n        else {\n            if (options?.rewriteFileNames) {\n                fileName = `${i + options.rewriteFileNames.fileStartNumber}`;\n            }\n            else {\n                fileName = `${i}`;\n            }\n        }\n        // If we don't want to wrap with directory, adjust the filepath\n        const filepath = options?.uploadWithoutDirectory\n            ? \"files\"\n            : `files/${fileName}`;\n        if (fileNameToFileMap.has(fileName)) {\n            // if the file in the map is the same as the file we are already looking at then just skip and continue\n            if (isFileBufferOrStringEqual(fileNameToFileMap.get(fileName), file)) {\n                // we add it to the filenames array so that we can return the correct number of urls,\n                fileNames.push(fileName);\n                // but then we skip because we don't need to upload it multiple times\n                continue;\n            }\n            // otherwise if file names are the same but they are not the same file then we should throw an error (trying to upload to differnt files but with the same names)\n            throw new Error(`[DUPLICATE_FILE_NAME_ERROR] File name ${fileName} was passed for more than one different file.`);\n        }\n        // add it to the map so that we can check for duplicates\n        fileNameToFileMap.set(fileName, file);\n        // add it to the filenames array so that we can return the correct number of urls\n        fileNames.push(fileName);\n        form.append(\"file\", new Blob([fileData]), filepath);\n    }\n    const metadata = {\n        name: \"Storage SDK\",\n        keyvalues: { ...options?.metadata },\n    };\n    form.append(\"pinataMetadata\", JSON.stringify(metadata));\n    if (options?.uploadWithoutDirectory) {\n        form.append(\"pinataOptions\", JSON.stringify({\n            wrapWithDirectory: false,\n        }));\n    }\n    return {\n        form,\n        // encode the file names on the way out (which is what the upload backend expects)\n        fileNames: fileNames.map((fName) => encodeURIComponent(fName)),\n    };\n}\nfunction isFileOrUint8Array(data) {\n    return (isFileInstance(data) || (0,_utils_uint8_array_js__WEBPACK_IMPORTED_MODULE_1__.isUint8Array)(data) || isBufferOrStringWithName(data));\n}\n/**\n * @internal\n */\nfunction extractObjectFiles(data, files = []) {\n    // If item is a FileOrBuffer add it to our list of files\n    if (isFileOrUint8Array(data)) {\n        files.push(data);\n        return files;\n    }\n    if (typeof data === \"object\") {\n        if (!data) {\n            return files;\n        }\n        if (Array.isArray(data)) {\n            for (const entry of data) {\n                extractObjectFiles(entry, files);\n            }\n        }\n        else {\n            Object.keys(data).map((key) => extractObjectFiles(data[key], files));\n        }\n    }\n    return files;\n}\n/**\n * @internal\n */\nfunction replaceObjectFilesWithUris(data, uris) {\n    if (isFileOrUint8Array(data)) {\n        if (uris.length) {\n            return uris.shift();\n        }\n        console.warn(\"Not enough URIs to replace all files in object.\");\n    }\n    if (typeof data === \"object\") {\n        if (!data) {\n            return data;\n        }\n        if (Array.isArray(data)) {\n            return data.map((entry) => replaceObjectFilesWithUris(entry, uris));\n        }\n        return Object.fromEntries(Object.entries(data).map(([key, value]) => [\n            key,\n            replaceObjectFilesWithUris(value, uris),\n        ]));\n    }\n    return data;\n}\n/**\n * @internal\n */\nfunction replaceGatewayUrlWithScheme(url) {\n    if (url.includes(\"/ipfs/\")) {\n        const hash = url.split(\"/ipfs/\")[1];\n        return `ipfs://${hash}`;\n    }\n    return url;\n}\n/**\n * @internal\n */\nfunction replaceObjectGatewayUrlsWithSchemes(data) {\n    if (typeof data === \"string\") {\n        return replaceGatewayUrlWithScheme(data);\n    }\n    if (typeof data === \"object\") {\n        if (!data) {\n            return data;\n        }\n        if (isFileOrUint8Array(data)) {\n            return data;\n        }\n        if (Array.isArray(data)) {\n            return data.map((entry) => replaceObjectGatewayUrlsWithSchemes(entry));\n        }\n        return Object.fromEntries(Object.entries(data).map(([key, value]) => [\n            key,\n            replaceObjectGatewayUrlsWithSchemes(value),\n        ]));\n    }\n    return data;\n}\n//# sourceMappingURL=helpers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRoaXJkd2ViLWRldi9zZGsvbm9kZV9tb2R1bGVzL3RoaXJkd2ViL2Rpc3QvZXNtL3N0b3JhZ2UvdXBsb2FkL2hlbHBlcnMuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQThEO0FBQ2lCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx1RUFBZ0I7QUFDekI7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLG1FQUFZO0FBQ3REO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtRUFBWSxZQUFZLG1FQUFZO0FBQ2pEO0FBQ0EsZUFBZSwwRUFBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1FQUFZLGlCQUFpQixtRUFBWTtBQUN6RDtBQUNBLHVCQUF1QiwwRUFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw2Q0FBNkMsRUFBRSxXQUFXO0FBQ3hGO0FBQ0E7QUFDQSw4QkFBOEIsVUFBVTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDZDQUE2QztBQUMzRTtBQUNBO0FBQ0EsOEJBQThCLFVBQVU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNkNBQTZDO0FBQzNFO0FBQ0E7QUFDQSw4QkFBOEIsRUFBRTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLFVBQVU7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNCQUFzQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxvQ0FBb0MsbUVBQVk7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSx5QkFBeUIsS0FBSztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHRoaXJkd2ViLWRldi9zZGsvbm9kZV9tb2R1bGVzL3RoaXJkd2ViL2Rpc3QvZXNtL3N0b3JhZ2UvdXBsb2FkL2hlbHBlcnMuanM/Y2U3YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc09iamVjdFdpdGhLZXlzIH0gZnJvbSBcIi4uLy4uL3V0aWxzL3R5cGUtZ3VhcmRzLmpzXCI7XG5pbXBvcnQgeyBhcmVVaW50OEFycmF5c0VxdWFsLCBpc1VpbnQ4QXJyYXkgfSBmcm9tIFwiLi4vLi4vdXRpbHMvdWludDgtYXJyYXkuanNcIjtcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGlzRmlsZUluc3RhbmNlKGRhdGEpIHtcbiAgICByZXR1cm4gZ2xvYmFsVGhpcy5GaWxlICYmIGRhdGEgaW5zdGFuY2VvZiBGaWxlO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gaXNCdWZmZXJPclN0cmluZ1dpdGhOYW1lKGRhdGEpIHtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWlzT2JqZWN0V2l0aEtleXMoZGF0YSwgW1wiZGF0YVwiLCBcIm5hbWVcIl0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuICEhKHR5cGVvZiBkYXRhLm5hbWUgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgKHR5cGVvZiBkYXRhLmRhdGEgPT09IFwic3RyaW5nXCIgfHwgaXNVaW50OEFycmF5KGRhdGEuZGF0YSkpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0ZpbGVCdWZmZXJPclN0cmluZ0VxdWFsKGlucHV0MSwgaW5wdXQyKSB7XG4gICAgaWYgKGlzRmlsZUluc3RhbmNlKGlucHV0MSkgJiYgaXNGaWxlSW5zdGFuY2UoaW5wdXQyKSkge1xuICAgICAgICAvLyBpZiBib3RoIGFyZSBGaWxlIHR5cGVzLCBjb21wYXJlIHRoZSBuYW1lLCBzaXplLCBhbmQgbGFzdCBtb2RpZmllZCBkYXRlIChiZXN0IGd1ZXNzIHRoYXQgdGhlc2UgYXJlIHRoZSBzYW1lIGZpbGVzKVxuICAgICAgICBpZiAoaW5wdXQxLm5hbWUgPT09IGlucHV0Mi5uYW1lICYmXG4gICAgICAgICAgICBpbnB1dDEubGFzdE1vZGlmaWVkID09PSBpbnB1dDIubGFzdE1vZGlmaWVkICYmXG4gICAgICAgICAgICBpbnB1dDEuc2l6ZSA9PT0gaW5wdXQyLnNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzVWludDhBcnJheShpbnB1dDEpICYmIGlzVWludDhBcnJheShpbnB1dDIpKSB7XG4gICAgICAgIC8vIGJ1ZmZlciBnaXZlcyB1cyBhbiBlYXN5IHdheSB0byBjb21wYXJlIHRoZSBjb250ZW50cyFcbiAgICAgICAgcmV0dXJuIGFyZVVpbnQ4QXJyYXlzRXF1YWwoaW5wdXQxLCBpbnB1dDIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0J1ZmZlck9yU3RyaW5nV2l0aE5hbWUoaW5wdXQxKSAmJlxuICAgICAgICBpc0J1ZmZlck9yU3RyaW5nV2l0aE5hbWUoaW5wdXQyKSkge1xuICAgICAgICAvLyBmaXJzdCBjaGVjayB0aGUgbmFtZXNcbiAgICAgICAgaWYgKGlucHV0MS5uYW1lID09PSBpbnB1dDIubmFtZSkge1xuICAgICAgICAgICAgLy8gaWYgdGhlIGRhdGEgZm9yIGJvdGggaXMgYSBzdHJpbmcsIGNvbXBhcmUgdGhlIHN0cmluZ3NcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQxLmRhdGEgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIGlucHV0Mi5kYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0MS5kYXRhID09PSBpbnB1dDIuZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1VpbnQ4QXJyYXkoaW5wdXQxLmRhdGEpICYmIGlzVWludDhBcnJheShpbnB1dDIuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2Ugd2Uga25vdyBpdCdzIGJ1ZmZlcnMsIHNvIGNvbXBhcmUgdGhlIGJ1ZmZlcnNcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJlVWludDhBcnJheXNFcXVhbChpbnB1dDEuZGF0YSwgaW5wdXQyLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIG90aGVyd2lzZSBpZiB3ZSBoYXZlIG5vdCBmb3VuZCBhIG1hdGNoLCByZXR1cm4gZmFsc2VcbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnQgZnVuY3Rpb24gYnVpbGRGb3JtRGF0YShmb3JtLCBmaWxlcywgb3B0aW9ucykge1xuICAgIGNvbnN0IGZpbGVOYW1lVG9GaWxlTWFwID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGZpbGVOYW1lcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gYmlvbWUtaWdub3JlIGxpbnQvc3R5bGUvbm9Ob25OdWxsQXNzZXJ0aW9uOiB3ZSBrbm93IHRoYXQgZmlsZXNbaV0gaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkIGJlY2F1c2Ugd2UgYXJlIGl0ZXJhdGluZyBvdmVyIHRoZSBhcnJheVxuICAgICAgICBjb25zdCBmaWxlID0gZmlsZXNbaV07XG4gICAgICAgIGxldCBmaWxlTmFtZSA9IFwiXCI7XG4gICAgICAgIGxldCBmaWxlRGF0YSA9IGZpbGU7XG4gICAgICAgIGlmIChpc0ZpbGVJbnN0YW5jZShmaWxlKSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnM/LnJld3JpdGVGaWxlTmFtZXMpIHtcbiAgICAgICAgICAgICAgICBsZXQgZXh0ZW5zaW9ucyA9IFwiXCI7XG4gICAgICAgICAgICAgICAgaWYgKGZpbGUubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBleHRlbnNpb25TdGFydEluZGV4ID0gZmlsZS5uYW1lLmxhc3RJbmRleE9mKFwiLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4dGVuc2lvblN0YXJ0SW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9ucyA9IGZpbGUubmFtZS5zdWJzdHJpbmcoZXh0ZW5zaW9uU3RhcnRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmlsZU5hbWUgPSBgJHtpICsgb3B0aW9ucy5yZXdyaXRlRmlsZU5hbWVzLmZpbGVTdGFydE51bWJlcn0ke2V4dGVuc2lvbnN9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZpbGVOYW1lID0gYCR7ZmlsZS5uYW1lfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNCdWZmZXJPclN0cmluZ1dpdGhOYW1lKGZpbGUpKSB7XG4gICAgICAgICAgICBmaWxlRGF0YSA9IGZpbGUuZGF0YTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zPy5yZXdyaXRlRmlsZU5hbWVzKSB7XG4gICAgICAgICAgICAgICAgZmlsZU5hbWUgPSBgJHtpICsgb3B0aW9ucy5yZXdyaXRlRmlsZU5hbWVzLmZpbGVTdGFydE51bWJlcn1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZmlsZU5hbWUgPSBgJHtmaWxlLm5hbWV9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zPy5yZXdyaXRlRmlsZU5hbWVzKSB7XG4gICAgICAgICAgICAgICAgZmlsZU5hbWUgPSBgJHtpICsgb3B0aW9ucy5yZXdyaXRlRmlsZU5hbWVzLmZpbGVTdGFydE51bWJlcn1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZmlsZU5hbWUgPSBgJHtpfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgZG9uJ3Qgd2FudCB0byB3cmFwIHdpdGggZGlyZWN0b3J5LCBhZGp1c3QgdGhlIGZpbGVwYXRoXG4gICAgICAgIGNvbnN0IGZpbGVwYXRoID0gb3B0aW9ucz8udXBsb2FkV2l0aG91dERpcmVjdG9yeVxuICAgICAgICAgICAgPyBcImZpbGVzXCJcbiAgICAgICAgICAgIDogYGZpbGVzLyR7ZmlsZU5hbWV9YDtcbiAgICAgICAgaWYgKGZpbGVOYW1lVG9GaWxlTWFwLmhhcyhmaWxlTmFtZSkpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBmaWxlIGluIHRoZSBtYXAgaXMgdGhlIHNhbWUgYXMgdGhlIGZpbGUgd2UgYXJlIGFscmVhZHkgbG9va2luZyBhdCB0aGVuIGp1c3Qgc2tpcCBhbmQgY29udGludWVcbiAgICAgICAgICAgIGlmIChpc0ZpbGVCdWZmZXJPclN0cmluZ0VxdWFsKGZpbGVOYW1lVG9GaWxlTWFwLmdldChmaWxlTmFtZSksIGZpbGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gd2UgYWRkIGl0IHRvIHRoZSBmaWxlbmFtZXMgYXJyYXkgc28gdGhhdCB3ZSBjYW4gcmV0dXJuIHRoZSBjb3JyZWN0IG51bWJlciBvZiB1cmxzLFxuICAgICAgICAgICAgICAgIGZpbGVOYW1lcy5wdXNoKGZpbGVOYW1lKTtcbiAgICAgICAgICAgICAgICAvLyBidXQgdGhlbiB3ZSBza2lwIGJlY2F1c2Ugd2UgZG9uJ3QgbmVlZCB0byB1cGxvYWQgaXQgbXVsdGlwbGUgdGltZXNcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSBpZiBmaWxlIG5hbWVzIGFyZSB0aGUgc2FtZSBidXQgdGhleSBhcmUgbm90IHRoZSBzYW1lIGZpbGUgdGhlbiB3ZSBzaG91bGQgdGhyb3cgYW4gZXJyb3IgKHRyeWluZyB0byB1cGxvYWQgdG8gZGlmZmVybnQgZmlsZXMgYnV0IHdpdGggdGhlIHNhbWUgbmFtZXMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFtEVVBMSUNBVEVfRklMRV9OQU1FX0VSUk9SXSBGaWxlIG5hbWUgJHtmaWxlTmFtZX0gd2FzIHBhc3NlZCBmb3IgbW9yZSB0aGFuIG9uZSBkaWZmZXJlbnQgZmlsZS5gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhZGQgaXQgdG8gdGhlIG1hcCBzbyB0aGF0IHdlIGNhbiBjaGVjayBmb3IgZHVwbGljYXRlc1xuICAgICAgICBmaWxlTmFtZVRvRmlsZU1hcC5zZXQoZmlsZU5hbWUsIGZpbGUpO1xuICAgICAgICAvLyBhZGQgaXQgdG8gdGhlIGZpbGVuYW1lcyBhcnJheSBzbyB0aGF0IHdlIGNhbiByZXR1cm4gdGhlIGNvcnJlY3QgbnVtYmVyIG9mIHVybHNcbiAgICAgICAgZmlsZU5hbWVzLnB1c2goZmlsZU5hbWUpO1xuICAgICAgICBmb3JtLmFwcGVuZChcImZpbGVcIiwgbmV3IEJsb2IoW2ZpbGVEYXRhXSksIGZpbGVwYXRoKTtcbiAgICB9XG4gICAgY29uc3QgbWV0YWRhdGEgPSB7XG4gICAgICAgIG5hbWU6IFwiU3RvcmFnZSBTREtcIixcbiAgICAgICAga2V5dmFsdWVzOiB7IC4uLm9wdGlvbnM/Lm1ldGFkYXRhIH0sXG4gICAgfTtcbiAgICBmb3JtLmFwcGVuZChcInBpbmF0YU1ldGFkYXRhXCIsIEpTT04uc3RyaW5naWZ5KG1ldGFkYXRhKSk7XG4gICAgaWYgKG9wdGlvbnM/LnVwbG9hZFdpdGhvdXREaXJlY3RvcnkpIHtcbiAgICAgICAgZm9ybS5hcHBlbmQoXCJwaW5hdGFPcHRpb25zXCIsIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIHdyYXBXaXRoRGlyZWN0b3J5OiBmYWxzZSxcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBmb3JtLFxuICAgICAgICAvLyBlbmNvZGUgdGhlIGZpbGUgbmFtZXMgb24gdGhlIHdheSBvdXQgKHdoaWNoIGlzIHdoYXQgdGhlIHVwbG9hZCBiYWNrZW5kIGV4cGVjdHMpXG4gICAgICAgIGZpbGVOYW1lczogZmlsZU5hbWVzLm1hcCgoZk5hbWUpID0+IGVuY29kZVVSSUNvbXBvbmVudChmTmFtZSkpLFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gaXNGaWxlT3JVaW50OEFycmF5KGRhdGEpIHtcbiAgICByZXR1cm4gKGlzRmlsZUluc3RhbmNlKGRhdGEpIHx8IGlzVWludDhBcnJheShkYXRhKSB8fCBpc0J1ZmZlck9yU3RyaW5nV2l0aE5hbWUoZGF0YSkpO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RPYmplY3RGaWxlcyhkYXRhLCBmaWxlcyA9IFtdKSB7XG4gICAgLy8gSWYgaXRlbSBpcyBhIEZpbGVPckJ1ZmZlciBhZGQgaXQgdG8gb3VyIGxpc3Qgb2YgZmlsZXNcbiAgICBpZiAoaXNGaWxlT3JVaW50OEFycmF5KGRhdGEpKSB7XG4gICAgICAgIGZpbGVzLnB1c2goZGF0YSk7XG4gICAgICAgIHJldHVybiBmaWxlcztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIGZpbGVzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGRhdGEpIHtcbiAgICAgICAgICAgICAgICBleHRyYWN0T2JqZWN0RmlsZXMoZW50cnksIGZpbGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGRhdGEpLm1hcCgoa2V5KSA9PiBleHRyYWN0T2JqZWN0RmlsZXMoZGF0YVtrZXldLCBmaWxlcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmaWxlcztcbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXBsYWNlT2JqZWN0RmlsZXNXaXRoVXJpcyhkYXRhLCB1cmlzKSB7XG4gICAgaWYgKGlzRmlsZU9yVWludDhBcnJheShkYXRhKSkge1xuICAgICAgICBpZiAodXJpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB1cmlzLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS53YXJuKFwiTm90IGVub3VnaCBVUklzIHRvIHJlcGxhY2UgYWxsIGZpbGVzIGluIG9iamVjdC5cIik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YS5tYXAoKGVudHJ5KSA9PiByZXBsYWNlT2JqZWN0RmlsZXNXaXRoVXJpcyhlbnRyeSwgdXJpcykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoZGF0YSkubWFwKChba2V5LCB2YWx1ZV0pID0+IFtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHJlcGxhY2VPYmplY3RGaWxlc1dpdGhVcmlzKHZhbHVlLCB1cmlzKSxcbiAgICAgICAgXSkpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXBsYWNlR2F0ZXdheVVybFdpdGhTY2hlbWUodXJsKSB7XG4gICAgaWYgKHVybC5pbmNsdWRlcyhcIi9pcGZzL1wiKSkge1xuICAgICAgICBjb25zdCBoYXNoID0gdXJsLnNwbGl0KFwiL2lwZnMvXCIpWzFdO1xuICAgICAgICByZXR1cm4gYGlwZnM6Ly8ke2hhc2h9YDtcbiAgICB9XG4gICAgcmV0dXJuIHVybDtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXBsYWNlT2JqZWN0R2F0ZXdheVVybHNXaXRoU2NoZW1lcyhkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiByZXBsYWNlR2F0ZXdheVVybFdpdGhTY2hlbWUoZGF0YSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0ZpbGVPclVpbnQ4QXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YS5tYXAoKGVudHJ5KSA9PiByZXBsYWNlT2JqZWN0R2F0ZXdheVVybHNXaXRoU2NoZW1lcyhlbnRyeSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoZGF0YSkubWFwKChba2V5LCB2YWx1ZV0pID0+IFtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHJlcGxhY2VPYmplY3RHYXRld2F5VXJsc1dpdGhTY2hlbWVzKHZhbHVlKSxcbiAgICAgICAgXSkpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlbHBlcnMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/storage/upload/helpers.js\n"));

/***/ }),

/***/ "./node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/uint8-array.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/uint8-array.js ***!
  \********************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"areUint8ArraysEqual\": function() { return /* binding */ areUint8ArraysEqual; },\n/* harmony export */   \"base64ToString\": function() { return /* binding */ base64ToString; },\n/* harmony export */   \"base64ToUint8Array\": function() { return /* binding */ base64ToUint8Array; },\n/* harmony export */   \"compareUint8Arrays\": function() { return /* binding */ compareUint8Arrays; },\n/* harmony export */   \"concatUint8Arrays\": function() { return /* binding */ concatUint8Arrays; },\n/* harmony export */   \"isUint8Array\": function() { return /* binding */ isUint8Array; },\n/* harmony export */   \"uint8ArrayToBase64\": function() { return /* binding */ uint8ArrayToBase64; },\n/* harmony export */   \"uint8ArrayToString\": function() { return /* binding */ uint8ArrayToString; }\n/* harmony export */ });\n/* harmony import */ var _text_decoder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./text-decoder.js */ \"./node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/text-decoder.js\");\n\nconst uint8ArrayStringified = \"[object Uint8Array]\";\n/**\n * Throw a `TypeError` if the given value is not an instance of `Uint8Array`.\n * @example\n * ```ts\n * import {assertUint8Array} from 'uint8array-extras';\n *\n * try {\n * assertUint8Array(new ArrayBuffer(10)); // Throws a TypeError\n * } catch (error) {\n * console.error(error.message);\n * }\n * ```\n */\nfunction assertUint8Array(value) {\n    if (!isUint8Array(value)) {\n        throw new TypeError(`Expected \\`Uint8Array\\`, got \\`${typeof value}\\``);\n    }\n}\n/**\n * Check if the given value is an instance of `Uint8Array`.\n *\n * Replacement for [`Buffer.isBuffer()`](https://nodejs.org/api/buffer.html#static-method-bufferisbufferobj).\n * @example\n * ```ts\n * import {isUint8Array} from 'uint8array-extras';\n *\n * console.log(isUint8Array(new Uint8Array()));\n * //=> true\n *\n * console.log(isUint8Array(Buffer.from('x')));\n * //=> true\n *\n * console.log(isUint8Array(new ArrayBuffer(10)));\n * //=> false\n * ```\n */\nfunction isUint8Array(value) {\n    if (!value) {\n        return false;\n    }\n    if (value.constructor === Uint8Array) {\n        return true;\n    }\n    return Object.prototype.toString.call(value) === uint8ArrayStringified;\n}\n/**\n * Check if two arrays are identical by verifying that they contain the same bytes in the same sequence.\n *\n * Replacement for [`Buffer#equals()`](https://nodejs.org/api/buffer.html#bufequalsotherbuffer).\n * @example\n * ```ts\n * import {areUint8ArraysEqual} from 'uint8array-extras';\n *\n * const a = new Uint8Array([1, 2, 3]);\n * const b = new Uint8Array([1, 2, 3]);\n * const c = new Uint8Array([4, 5, 6]);\n *\n * console.log(areUint8ArraysEqual(a, b));\n * //=> true\n *\n * console.log(areUint8ArraysEqual(a, c));\n * //=> false\n * ```\n */\nfunction areUint8ArraysEqual(a, b) {\n    assertUint8Array(a);\n    assertUint8Array(b);\n    if (a === b) {\n        return true;\n    }\n    if (a.length !== b.length) {\n        return false;\n    }\n    for (let index = 0; index < a.length; index++) {\n        if (a[index] !== b[index]) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Convert a `Uint8Array` (containing a UTF-8 string) to a string.\n *\n * Replacement for [`Buffer#toString()`](https://nodejs.org/api/buffer.html#buftostringencoding-start-end).\n * @example\n * ```ts\n * import {uint8ArrayToString} from 'uint8array-extras';\n *\n * const byteArray = new Uint8Array([72, 101, 108, 108, 111]);\n *\n * console.log(uint8ArrayToString(byteArray));\n * //=> 'Hello'\n * ```\n */\nfunction uint8ArrayToString(array) {\n    assertUint8Array(array);\n    return (0,_text_decoder_js__WEBPACK_IMPORTED_MODULE_0__.cachedTextDecoder)().decode(array);\n}\nfunction assertString(value) {\n    if (typeof value !== \"string\") {\n        throw new TypeError(`Expected \\`string\\`, got \\`${typeof value}\\``);\n    }\n}\nfunction base64UrlToBase64(base64url) {\n    return base64url.replaceAll(\"-\", \"+\").replaceAll(\"_\", \"/\");\n}\n/**\n * Convert a Base64-encoded or [Base64URL](https://base64.guru/standards/base64url)-encoded string to a `Uint8Array`.\n *\n * Replacement for [`Buffer.from('SGVsbG8=', 'base64')`](https://nodejs.org/api/buffer.html#static-method-bufferfromstring-encoding).\n * @example\n * ```ts\n * import {base64ToUint8Array} from 'uint8array-extras';\n *\n * console.log(base64ToUint8Array('SGVsbG8='));\n * //=> Uint8Array [72, 101, 108, 108, 111]\n * ```\n */\nfunction base64ToUint8Array(base64String) {\n    assertString(base64String);\n    return Uint8Array.from(globalThis.atob(base64UrlToBase64(base64String)), \n    // biome-ignore lint/style/noNonNullAssertion: we know that the code points exist\n    (x) => x.codePointAt(0));\n}\n/**\n * Decode a Base64-encoded or [Base64URL](https://base64.guru/standards/base64url)-encoded string to a string.\n *\n * Replacement for `Buffer.from('SGVsbG8=', 'base64').toString()` and [`atob()`](https://developer.mozilla.org/en-US/docs/Web/API/atob).\n * @example\n * ```ts\n * import {base64ToString} from 'uint8array-extras';\n *\n * console.log(base64ToString('SGVsbG8='));\n * //=> 'Hello'\n * ```\n */\nfunction base64ToString(base64String) {\n    assertString(base64String);\n    return uint8ArrayToString(base64ToUint8Array(base64String));\n}\nfunction base64ToBase64Url(base64) {\n    return base64.replaceAll(\"+\", \"-\").replaceAll(\"/\", \"_\").replace(/=+$/, \"\");\n}\n// Reference: https://phuoc.ng/collection/this-vs-that/concat-vs-push/\nconst MAX_BLOCK_SIZE = 65_535;\nfunction uint8ArrayToBase64(array, { urlSafe = false } = {}) {\n    assertUint8Array(array);\n    let base64;\n    if (array.length < MAX_BLOCK_SIZE) {\n        // Required as `btoa` and `atob` don't properly support Unicode: https://developer.mozilla.org/en-US/docs/Glossary/Base64#the_unicode_problem\n        // @ts-expect-error - TS doesn't know about `String#fromCodePoint`\n        base64 = globalThis.btoa(String.fromCodePoint.apply(this, array));\n    }\n    else {\n        base64 = \"\";\n        for (const value of array) {\n            base64 += String.fromCodePoint(value);\n        }\n        base64 = globalThis.btoa(base64);\n    }\n    return urlSafe ? base64ToBase64Url(base64) : base64;\n}\nfunction concatUint8Arrays(arrays, totalLength) {\n    if (arrays.length === 0) {\n        return new Uint8Array(0);\n    }\n    const calculatedTotalLength = totalLength ??\n        arrays.reduce((accumulator, currentValue) => accumulator + currentValue.length, 0);\n    const returnValue = new Uint8Array(calculatedTotalLength);\n    let offset = 0;\n    for (const array of arrays) {\n        assertUint8Array(array);\n        returnValue.set(array, offset);\n        offset += array.length;\n    }\n    return returnValue;\n}\nfunction compareUint8Arrays(a, b) {\n    assertUint8Array(a);\n    assertUint8Array(b);\n    const length = Math.min(a.length, b.length);\n    for (let index = 0; index < length; index++) {\n        // biome-ignore lint/style/noNonNullAssertion: we check the length above so the index is always in bounds\n        const diff = a[index] - b[index];\n        if (diff !== 0) {\n            return Math.sign(diff);\n        }\n    }\n    // At this point, all the compared elements are equal.\n    // The shorter array should come first if the arrays are of different lengths.\n    return Math.sign(a.length - b.length);\n}\n//# sourceMappingURL=uint8-array.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRoaXJkd2ViLWRldi9zZGsvbm9kZV9tb2R1bGVzL3RoaXJkd2ViL2Rpc3QvZXNtL3V0aWxzL3VpbnQ4LWFycmF5LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0I7QUFDQTtBQUNBLDBDQUEwQztBQUMxQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELGFBQWE7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxXQUFXLG1FQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsYUFBYTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxxQ0FBcUMsa0JBQWtCLElBQUk7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHRoaXJkd2ViLWRldi9zZGsvbm9kZV9tb2R1bGVzL3RoaXJkd2ViL2Rpc3QvZXNtL3V0aWxzL3VpbnQ4LWFycmF5LmpzPzU5MzMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY2FjaGVkVGV4dERlY29kZXIgfSBmcm9tIFwiLi90ZXh0LWRlY29kZXIuanNcIjtcbmNvbnN0IHVpbnQ4QXJyYXlTdHJpbmdpZmllZCA9IFwiW29iamVjdCBVaW50OEFycmF5XVwiO1xuLyoqXG4gKiBUaHJvdyBhIGBUeXBlRXJyb3JgIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgYFVpbnQ4QXJyYXlgLlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQge2Fzc2VydFVpbnQ4QXJyYXl9IGZyb20gJ3VpbnQ4YXJyYXktZXh0cmFzJztcbiAqXG4gKiB0cnkge1xuICogYXNzZXJ0VWludDhBcnJheShuZXcgQXJyYXlCdWZmZXIoMTApKTsgLy8gVGhyb3dzIGEgVHlwZUVycm9yXG4gKiB9IGNhdGNoIChlcnJvcikge1xuICogY29uc29sZS5lcnJvcihlcnJvci5tZXNzYWdlKTtcbiAqIH1cbiAqIGBgYFxuICovXG5mdW5jdGlvbiBhc3NlcnRVaW50OEFycmF5KHZhbHVlKSB7XG4gICAgaWYgKCFpc1VpbnQ4QXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIFxcYFVpbnQ4QXJyYXlcXGAsIGdvdCBcXGAke3R5cGVvZiB2YWx1ZX1cXGBgKTtcbiAgICB9XG59XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhbiBpbnN0YW5jZSBvZiBgVWludDhBcnJheWAuXG4gKlxuICogUmVwbGFjZW1lbnQgZm9yIFtgQnVmZmVyLmlzQnVmZmVyKClgXShodHRwczovL25vZGVqcy5vcmcvYXBpL2J1ZmZlci5odG1sI3N0YXRpYy1tZXRob2QtYnVmZmVyaXNidWZmZXJvYmopLlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQge2lzVWludDhBcnJheX0gZnJvbSAndWludDhhcnJheS1leHRyYXMnO1xuICpcbiAqIGNvbnNvbGUubG9nKGlzVWludDhBcnJheShuZXcgVWludDhBcnJheSgpKSk7XG4gKiAvLz0+IHRydWVcbiAqXG4gKiBjb25zb2xlLmxvZyhpc1VpbnQ4QXJyYXkoQnVmZmVyLmZyb20oJ3gnKSkpO1xuICogLy89PiB0cnVlXG4gKlxuICogY29uc29sZS5sb2coaXNVaW50OEFycmF5KG5ldyBBcnJheUJ1ZmZlcigxMCkpKTtcbiAqIC8vPT4gZmFsc2VcbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNVaW50OEFycmF5KHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gVWludDhBcnJheSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09IHVpbnQ4QXJyYXlTdHJpbmdpZmllZDtcbn1cbi8qKlxuICogQ2hlY2sgaWYgdHdvIGFycmF5cyBhcmUgaWRlbnRpY2FsIGJ5IHZlcmlmeWluZyB0aGF0IHRoZXkgY29udGFpbiB0aGUgc2FtZSBieXRlcyBpbiB0aGUgc2FtZSBzZXF1ZW5jZS5cbiAqXG4gKiBSZXBsYWNlbWVudCBmb3IgW2BCdWZmZXIjZXF1YWxzKClgXShodHRwczovL25vZGVqcy5vcmcvYXBpL2J1ZmZlci5odG1sI2J1ZmVxdWFsc290aGVyYnVmZmVyKS5cbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHthcmVVaW50OEFycmF5c0VxdWFsfSBmcm9tICd1aW50OGFycmF5LWV4dHJhcyc7XG4gKlxuICogY29uc3QgYSA9IG5ldyBVaW50OEFycmF5KFsxLCAyLCAzXSk7XG4gKiBjb25zdCBiID0gbmV3IFVpbnQ4QXJyYXkoWzEsIDIsIDNdKTtcbiAqIGNvbnN0IGMgPSBuZXcgVWludDhBcnJheShbNCwgNSwgNl0pO1xuICpcbiAqIGNvbnNvbGUubG9nKGFyZVVpbnQ4QXJyYXlzRXF1YWwoYSwgYikpO1xuICogLy89PiB0cnVlXG4gKlxuICogY29uc29sZS5sb2coYXJlVWludDhBcnJheXNFcXVhbChhLCBjKSk7XG4gKiAvLz0+IGZhbHNlXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFyZVVpbnQ4QXJyYXlzRXF1YWwoYSwgYikge1xuICAgIGFzc2VydFVpbnQ4QXJyYXkoYSk7XG4gICAgYXNzZXJ0VWludDhBcnJheShiKTtcbiAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBhLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBpZiAoYVtpbmRleF0gIT09IGJbaW5kZXhdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIENvbnZlcnQgYSBgVWludDhBcnJheWAgKGNvbnRhaW5pbmcgYSBVVEYtOCBzdHJpbmcpIHRvIGEgc3RyaW5nLlxuICpcbiAqIFJlcGxhY2VtZW50IGZvciBbYEJ1ZmZlciN0b1N0cmluZygpYF0oaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9idWZmZXIuaHRtbCNidWZ0b3N0cmluZ2VuY29kaW5nLXN0YXJ0LWVuZCkuXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7dWludDhBcnJheVRvU3RyaW5nfSBmcm9tICd1aW50OGFycmF5LWV4dHJhcyc7XG4gKlxuICogY29uc3QgYnl0ZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoWzcyLCAxMDEsIDEwOCwgMTA4LCAxMTFdKTtcbiAqXG4gKiBjb25zb2xlLmxvZyh1aW50OEFycmF5VG9TdHJpbmcoYnl0ZUFycmF5KSk7XG4gKiAvLz0+ICdIZWxsbydcbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gdWludDhBcnJheVRvU3RyaW5nKGFycmF5KSB7XG4gICAgYXNzZXJ0VWludDhBcnJheShhcnJheSk7XG4gICAgcmV0dXJuIGNhY2hlZFRleHREZWNvZGVyKCkuZGVjb2RlKGFycmF5KTtcbn1cbmZ1bmN0aW9uIGFzc2VydFN0cmluZyh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgXFxgc3RyaW5nXFxgLCBnb3QgXFxgJHt0eXBlb2YgdmFsdWV9XFxgYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYmFzZTY0VXJsVG9CYXNlNjQoYmFzZTY0dXJsKSB7XG4gICAgcmV0dXJuIGJhc2U2NHVybC5yZXBsYWNlQWxsKFwiLVwiLCBcIitcIikucmVwbGFjZUFsbChcIl9cIiwgXCIvXCIpO1xufVxuLyoqXG4gKiBDb252ZXJ0IGEgQmFzZTY0LWVuY29kZWQgb3IgW0Jhc2U2NFVSTF0oaHR0cHM6Ly9iYXNlNjQuZ3VydS9zdGFuZGFyZHMvYmFzZTY0dXJsKS1lbmNvZGVkIHN0cmluZyB0byBhIGBVaW50OEFycmF5YC5cbiAqXG4gKiBSZXBsYWNlbWVudCBmb3IgW2BCdWZmZXIuZnJvbSgnU0dWc2JHOD0nLCAnYmFzZTY0JylgXShodHRwczovL25vZGVqcy5vcmcvYXBpL2J1ZmZlci5odG1sI3N0YXRpYy1tZXRob2QtYnVmZmVyZnJvbXN0cmluZy1lbmNvZGluZykuXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7YmFzZTY0VG9VaW50OEFycmF5fSBmcm9tICd1aW50OGFycmF5LWV4dHJhcyc7XG4gKlxuICogY29uc29sZS5sb2coYmFzZTY0VG9VaW50OEFycmF5KCdTR1ZzYkc4PScpKTtcbiAqIC8vPT4gVWludDhBcnJheSBbNzIsIDEwMSwgMTA4LCAxMDgsIDExMV1cbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gYmFzZTY0VG9VaW50OEFycmF5KGJhc2U2NFN0cmluZykge1xuICAgIGFzc2VydFN0cmluZyhiYXNlNjRTdHJpbmcpO1xuICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oZ2xvYmFsVGhpcy5hdG9iKGJhc2U2NFVybFRvQmFzZTY0KGJhc2U2NFN0cmluZykpLCBcbiAgICAvLyBiaW9tZS1pZ25vcmUgbGludC9zdHlsZS9ub05vbk51bGxBc3NlcnRpb246IHdlIGtub3cgdGhhdCB0aGUgY29kZSBwb2ludHMgZXhpc3RcbiAgICAoeCkgPT4geC5jb2RlUG9pbnRBdCgwKSk7XG59XG4vKipcbiAqIERlY29kZSBhIEJhc2U2NC1lbmNvZGVkIG9yIFtCYXNlNjRVUkxdKGh0dHBzOi8vYmFzZTY0Lmd1cnUvc3RhbmRhcmRzL2Jhc2U2NHVybCktZW5jb2RlZCBzdHJpbmcgdG8gYSBzdHJpbmcuXG4gKlxuICogUmVwbGFjZW1lbnQgZm9yIGBCdWZmZXIuZnJvbSgnU0dWc2JHOD0nLCAnYmFzZTY0JykudG9TdHJpbmcoKWAgYW5kIFtgYXRvYigpYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL2F0b2IpLlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQge2Jhc2U2NFRvU3RyaW5nfSBmcm9tICd1aW50OGFycmF5LWV4dHJhcyc7XG4gKlxuICogY29uc29sZS5sb2coYmFzZTY0VG9TdHJpbmcoJ1NHVnNiRzg9JykpO1xuICogLy89PiAnSGVsbG8nXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJhc2U2NFRvU3RyaW5nKGJhc2U2NFN0cmluZykge1xuICAgIGFzc2VydFN0cmluZyhiYXNlNjRTdHJpbmcpO1xuICAgIHJldHVybiB1aW50OEFycmF5VG9TdHJpbmcoYmFzZTY0VG9VaW50OEFycmF5KGJhc2U2NFN0cmluZykpO1xufVxuZnVuY3Rpb24gYmFzZTY0VG9CYXNlNjRVcmwoYmFzZTY0KSB7XG4gICAgcmV0dXJuIGJhc2U2NC5yZXBsYWNlQWxsKFwiK1wiLCBcIi1cIikucmVwbGFjZUFsbChcIi9cIiwgXCJfXCIpLnJlcGxhY2UoLz0rJC8sIFwiXCIpO1xufVxuLy8gUmVmZXJlbmNlOiBodHRwczovL3BodW9jLm5nL2NvbGxlY3Rpb24vdGhpcy12cy10aGF0L2NvbmNhdC12cy1wdXNoL1xuY29uc3QgTUFYX0JMT0NLX1NJWkUgPSA2NV81MzU7XG5leHBvcnQgZnVuY3Rpb24gdWludDhBcnJheVRvQmFzZTY0KGFycmF5LCB7IHVybFNhZmUgPSBmYWxzZSB9ID0ge30pIHtcbiAgICBhc3NlcnRVaW50OEFycmF5KGFycmF5KTtcbiAgICBsZXQgYmFzZTY0O1xuICAgIGlmIChhcnJheS5sZW5ndGggPCBNQVhfQkxPQ0tfU0laRSkge1xuICAgICAgICAvLyBSZXF1aXJlZCBhcyBgYnRvYWAgYW5kIGBhdG9iYCBkb24ndCBwcm9wZXJseSBzdXBwb3J0IFVuaWNvZGU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvR2xvc3NhcnkvQmFzZTY0I3RoZV91bmljb2RlX3Byb2JsZW1cbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtIFRTIGRvZXNuJ3Qga25vdyBhYm91dCBgU3RyaW5nI2Zyb21Db2RlUG9pbnRgXG4gICAgICAgIGJhc2U2NCA9IGdsb2JhbFRoaXMuYnRvYShTdHJpbmcuZnJvbUNvZGVQb2ludC5hcHBseSh0aGlzLCBhcnJheSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYmFzZTY0ID0gXCJcIjtcbiAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBhcnJheSkge1xuICAgICAgICAgICAgYmFzZTY0ICs9IFN0cmluZy5mcm9tQ29kZVBvaW50KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBiYXNlNjQgPSBnbG9iYWxUaGlzLmJ0b2EoYmFzZTY0KTtcbiAgICB9XG4gICAgcmV0dXJuIHVybFNhZmUgPyBiYXNlNjRUb0Jhc2U2NFVybChiYXNlNjQpIDogYmFzZTY0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdFVpbnQ4QXJyYXlzKGFycmF5cywgdG90YWxMZW5ndGgpIHtcbiAgICBpZiAoYXJyYXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgfVxuICAgIGNvbnN0IGNhbGN1bGF0ZWRUb3RhbExlbmd0aCA9IHRvdGFsTGVuZ3RoID8/XG4gICAgICAgIGFycmF5cy5yZWR1Y2UoKGFjY3VtdWxhdG9yLCBjdXJyZW50VmFsdWUpID0+IGFjY3VtdWxhdG9yICsgY3VycmVudFZhbHVlLmxlbmd0aCwgMCk7XG4gICAgY29uc3QgcmV0dXJuVmFsdWUgPSBuZXcgVWludDhBcnJheShjYWxjdWxhdGVkVG90YWxMZW5ndGgpO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGZvciAoY29uc3QgYXJyYXkgb2YgYXJyYXlzKSB7XG4gICAgICAgIGFzc2VydFVpbnQ4QXJyYXkoYXJyYXkpO1xuICAgICAgICByZXR1cm5WYWx1ZS5zZXQoYXJyYXksIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSBhcnJheS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb21wYXJlVWludDhBcnJheXMoYSwgYikge1xuICAgIGFzc2VydFVpbnQ4QXJyYXkoYSk7XG4gICAgYXNzZXJ0VWludDhBcnJheShiKTtcbiAgICBjb25zdCBsZW5ndGggPSBNYXRoLm1pbihhLmxlbmd0aCwgYi5sZW5ndGgpO1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgLy8gYmlvbWUtaWdub3JlIGxpbnQvc3R5bGUvbm9Ob25OdWxsQXNzZXJ0aW9uOiB3ZSBjaGVjayB0aGUgbGVuZ3RoIGFib3ZlIHNvIHRoZSBpbmRleCBpcyBhbHdheXMgaW4gYm91bmRzXG4gICAgICAgIGNvbnN0IGRpZmYgPSBhW2luZGV4XSAtIGJbaW5kZXhdO1xuICAgICAgICBpZiAoZGlmZiAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguc2lnbihkaWZmKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBdCB0aGlzIHBvaW50LCBhbGwgdGhlIGNvbXBhcmVkIGVsZW1lbnRzIGFyZSBlcXVhbC5cbiAgICAvLyBUaGUgc2hvcnRlciBhcnJheSBzaG91bGQgY29tZSBmaXJzdCBpZiB0aGUgYXJyYXlzIGFyZSBvZiBkaWZmZXJlbnQgbGVuZ3Rocy5cbiAgICByZXR1cm4gTWF0aC5zaWduKGEubGVuZ3RoIC0gYi5sZW5ndGgpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dWludDgtYXJyYXkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@thirdweb-dev/sdk/node_modules/thirdweb/dist/esm/utils/uint8-array.js\n"));

/***/ })

}]);