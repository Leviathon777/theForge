(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[3626],{86407:function(e,t,r){"use strict";r.d(t,{E:function(){return l},R:function(){return s},S:function(){return o},a:function(){return u}});var n=r(2593),i=r(1604),a=r(99612);const s=(()=>i.z.union([i.z.date().transform((e=>n.O$.from(Math.floor(e.getTime()/1e3)))),i.z.number().transform((e=>n.O$.from(e)))]))(),o=(()=>s.default(new Date(0)))(),l=(()=>s.default(new Date(Date.now()+31536e7)))();function u(e,t){if(!e)throw new a.x(t);return e}},17736:function(e,t,r){"use strict";r.d(t,{B:function(){return l},C:function(){return u},N:function(){return c},a:function(){return f},s:function(){return h}});var n=r(99612),i=r(1604),a=r(43277);const s=(()=>i.z.object({}).catchall(i.z.union([n.cx,i.z.unknown()])))(),o=(()=>i.z.union([i.z.array(i.z.array(s)).transform((e=>e.flat())),i.z.array(s),s]).optional().nullable())(),l=(()=>i.z.object({name:i.z.union([i.z.string(),i.z.number()]).optional().nullable(),description:i.z.string().nullable().optional().nullable(),image:n.cy.nullable().optional(),animation_url:n.cy.optional().nullable()}))(),u=(()=>l.extend({external_url:n.cy.nullable().optional(),background_color:n.cz.optional().nullable(),properties:o,attributes:o}).catchall(i.z.union([n.cx,i.z.unknown()])))(),c=(()=>i.z.union([u,i.z.string()]))(),f=(()=>u.extend({id:i.z.string(),uri:i.z.string(),image:i.z.string().nullable().optional(),external_url:i.z.string().nullable().optional(),animation_url:i.z.string().nullable().optional()}))();async function h(e,t,i,s){if(!(0,a.i)(i)){const a=(await Promise.resolve().then(r.t.bind(r,30853,19))).default,o=e.getSigner(),l=e.getProvider(),u=new n.cs(o||l,i,a,e.options,e.storage),c=await e.getSignerAddress(),f=e.address;return(await u.read("allowance",[c,f])).lt(t)&&await u.sendTransaction("approve",[f,t]),s}s.value=t}},93626:function(e,t,r){"use strict";r.d(t,{A:function(){return E},B:function(){return Q},C:function(){return K},D:function(){return L},E:function(){return R},F:function(){return z},H:function(){return V},I:function(){return C},J:function(){return A},K:function(){return Y},L:function(){return G},M:function(){return le},S:function(){return X},a:function(){return M},f:function(){return I},n:function(){return ee},r:function(){return ie},s:function(){return ae},t:function(){return se},u:function(){return oe},v:function(){return ue},w:function(){return ce},x:function(){return fe},y:function(){return Z},z:function(){return N}});var n=r(21046),i=r(61744),a=r(31886),s=r(9279),o=r(38197),l=r(2593),u=r(16441),c=r(29251),f=r(99612),h=r(43277),m=r(99979),d=r(48764),p=r(56351),y=r.n(p),g=r(99269);class b{print(){b.print(this)}bufferIndexOf(e,t){if(arguments.length>2&&void 0!==arguments[2]&&arguments[2])return this.binarySearch(e,t,d.Buffer.compare);return this.linearSearch(e,t,((e,t)=>e.equals(t)))}static binarySearch(e,t,r){let n=0,i=e.length-1;for(;n<=i;){const a=Math.floor((n+i)/2),s=r(e[a],t);if(0===s){for(let n=a-1;n>=0;n--)if(0!==r(e[n],t))return n+1;return 0}s<0?n=a+1:i=a-1}return-1}binarySearch(e,t,r){return b.binarySearch(e,t,r)}static linearSearch(e,t,r){for(let n=0;n<e.length;n++)if(r(e[n],t))return n;return-1}linearSearch(e,t,r){return b.linearSearch(e,t,r)}static bufferify(e){if(!d.Buffer.isBuffer(e)){if("object"===typeof e&&e.words)return d.Buffer.from(e.toString(v),"hex");if(b.isHexString(e))return d.Buffer.from(e.replace(/^0x/,""),"hex");if("string"===typeof e)return d.Buffer.from(e);if("bigint"===typeof e)return d.Buffer.from(e.toString(16),"hex");if(e instanceof Uint8Array)return d.Buffer.from(e.buffer);if("number"===typeof e){let t=e.toString();return t.length%2&&(t=`0${t}`),d.Buffer.from(t,"hex")}if(ArrayBuffer.isView(e))return d.Buffer.from(e.buffer,e.byteOffset,e.byteLength)}return e}bigNumberify(e){return b.bigNumberify(e)}static bigNumberify(e){if("bigint"===typeof e)return e;if("string"===typeof e)return e.startsWith("0x")&&b.isHexString(e)?BigInt("0x"+e.replace("0x","").toString()):BigInt(e);if(d.Buffer.isBuffer(e))return BigInt("0x"+e.toString("hex"));if(e instanceof Uint8Array)return function(e){const t=Array.from(e).map((e=>e.toString(16).padStart(2,"0"))).join("");return BigInt(`0x${t}`)}(e);if("number"===typeof e)return BigInt(e);throw new Error("cannot bigNumberify")}static isHexString(e){return"string"===typeof e&&/^(0x)?[0-9A-Fa-f]*$/.test(e)}static print(e){console.log(e.toString())}bufferToHex(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];return b.bufferToHex(e,t)}static bufferToHex(e){return`${!(arguments.length>1&&void 0!==arguments[1])||arguments[1]?"0x":""}${(e||d.Buffer.alloc(0)).toString("hex")}`}bufferify(e){return b.bufferify(e)}bufferifyFn(e){return t=>{const r=e(t);if(d.Buffer.isBuffer(r))return r;if(this.isHexString(r))return d.Buffer.from(r.replace("0x",""),"hex");if("string"===typeof r)return d.Buffer.from(r);if("bigint"===typeof r)return d.Buffer.from(t.toString(16),"hex");if(ArrayBuffer.isView(r))return d.Buffer.from(r.buffer,r.byteOffset,r.byteLength);const n=function(e){const t=new Uint8Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=parseInt(e.substring(r,r+2),16);return t.buffer}(t.toString("hex")),i=function(e){const t=new Uint8Array(e);return Array.from(t).map((e=>e.toString(16).padStart(2,"0"))).join("")}(e(n));return d.Buffer.from(i,"hex")}}isHexString(e){return b.isHexString(e)}log2(e){return 1===e?0:1+this.log2(e/2|0)}zip(e,t){return e.map(((e,r)=>[e,t[r]]))}static hexZeroPad(e,t){return"0x"+e.replace("0x","").padStart(t,"0")}}var w=b;function v(e){const t=e.words,r=new ArrayBuffer(4*t.length),n=new Uint8Array(r);for(let i=0;i<t.length;i++)n[4*i]=t[i]>>24&255,n[4*i+1]=t[i]>>16&255,n[4*i+2]=t[i]>>8&255,n[4*i+3]=255&t[i];return r}class x extends w{duplicateOdd=!1;concatenator=d.Buffer.concat;hashLeaves=!1;isBitcoinTree=!1;leaves=[];layers=[];sortLeaves=!1;sortPairs=!1;sort=!1;fillDefaultHash=null;complete=!1;constructor(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(super(),r.complete){if(r.isBitcoinTree)throw new Error('option "complete" is incompatible with "isBitcoinTree"');if(r.duplicateOdd)throw new Error('option "complete" is incompatible with "duplicateOdd"')}if(this.isBitcoinTree=!!r.isBitcoinTree,this.hashLeaves=!!r.hashLeaves,this.sortLeaves=!!r.sortLeaves,this.sortPairs=!!r.sortPairs,this.complete=!!r.complete,r.fillDefaultHash)if("function"===typeof r.fillDefaultHash)this.fillDefaultHash=r.fillDefaultHash;else{if(!d.Buffer.isBuffer(r.fillDefaultHash)&&"string"!==typeof r.fillDefaultHash)throw new Error('method "fillDefaultHash" must be a function, Buffer, or string');this.fillDefaultHash=(e,t)=>r.fillDefaultHash}this.sort=!!r.sort,this.sort&&(this.sortLeaves=!0,this.sortPairs=!0),this.duplicateOdd=!!r.duplicateOdd,r.concatenator&&(this.concatenator=r.concatenator),this.hashFn=this.bufferifyFn(t),this.processLeaves(e)}getOptions(){return{complete:this.complete,isBitcoinTree:this.isBitcoinTree,hashLeaves:this.hashLeaves,sortLeaves:this.sortLeaves,sortPairs:this.sortPairs,sort:this.sort,fillDefaultHash:this.fillDefaultHash?.toString()??null,duplicateOdd:this.duplicateOdd}}processLeaves(e){if(this.hashLeaves&&(e=e.map(this.hashFn)),this.leaves=e.map(this.bufferify),this.sortLeaves&&(this.leaves=this.leaves.sort(d.Buffer.compare)),this.fillDefaultHash)for(let t=this.leaves.length;t<Math.pow(2,Math.ceil(Math.log2(this.leaves.length)));t++)this.leaves.push(this.bufferify(this.fillDefaultHash(t,this.hashFn)));this.createHashes(this.leaves)}createHashes(e){for(this.layers=[e];e.length>1;){const t=this.layers.length;this.layers.push([]);const r=this.complete&&1===t&&!Number.isInteger(Math.log2(e.length))?2*e.length-2**Math.ceil(Math.log2(e.length)):e.length;for(let n=0;n<e.length;n+=2){if(n>=r){this.layers[t].push(...e.slice(r));break}if(n+1===e.length&&e.length%2===1){const r=e[e.length-1];let i=r;if(this.isBitcoinTree){i=this.hashFn(this.concatenator([y()(r),y()(r)])),i=y()(this.hashFn(i)),this.layers[t].push(i);continue}if(!this.duplicateOdd){this.layers[t].push(e[n]);continue}}const i=e[n],a=n+1===e.length?i:e[n+1];let s=null;s=this.isBitcoinTree?[y()(i),y()(a)]:[i,a],this.sortPairs&&s.sort(d.Buffer.compare);let o=this.hashFn(this.concatenator(s));this.isBitcoinTree&&(o=y()(this.hashFn(o))),this.layers[t].push(o)}e=this.layers[t]}}addLeaf(e){arguments.length>1&&void 0!==arguments[1]&&arguments[1]&&(e=this.hashFn(e)),this.processLeaves(this.leaves.concat(e))}addLeaves(e){arguments.length>1&&void 0!==arguments[1]&&arguments[1]&&(e=e.map(this.hashFn)),this.processLeaves(this.leaves.concat(e))}getLeaves(e){return Array.isArray(e)?(this.hashLeaves&&(e=e.map(this.hashFn),this.sortLeaves&&(e=e.sort(d.Buffer.compare))),this.leaves.filter((t=>-1!==this.bufferIndexOf(e,t,this.sortLeaves)))):this.leaves}getLeaf(e){return e<0||e>this.leaves.length-1?d.Buffer.from([]):this.leaves[e]}getLeafIndex(e){e=this.bufferify(e);const t=this.getLeaves();for(let r=0;r<t.length;r++){if(t[r].equals(e))return r}return-1}getLeafCount(){return this.leaves.length}getHexLeaves(){return this.leaves.map((e=>this.bufferToHex(e)))}static marshalLeaves(e){return JSON.stringify(e.map((e=>x.bufferToHex(e))),null,2)}static unmarshalLeaves(e){let t=null;if("string"===typeof e)t=JSON.parse(e);else{if(!(e instanceof Object))throw new Error("Expected type of string or object");t=e}if(!t)return[];if(!Array.isArray(t))throw new Error("Expected JSON string to be array");return t.map(x.bufferify)}getLayers(){return this.layers}getHexLayers(){return this.layers.reduce(((e,t)=>(Array.isArray(t)?e.push(t.map((e=>this.bufferToHex(e)))):e.push(t),e)),[])}getLayersFlat(){const e=this.layers.reduce(((e,t)=>(Array.isArray(t)?e.unshift(...t):e.unshift(t),e)),[]);return e.unshift(d.Buffer.from([0])),e}getHexLayersFlat(){return this.getLayersFlat().map((e=>this.bufferToHex(e)))}getLayerCount(){return this.getLayers().length}getRoot(){return 0===this.layers.length?d.Buffer.from([]):this.layers[this.layers.length-1][0]||d.Buffer.from([])}getHexRoot(){return this.bufferToHex(this.getRoot())}getProof(e,t){if("undefined"===typeof e)throw new Error("leaf is required");e=this.bufferify(e);const r=[];if(!Number.isInteger(t)){t=-1;for(let r=0;r<this.leaves.length;r++)0===d.Buffer.compare(e,this.leaves[r])&&(t=r)}if(t<=-1)return[];for(let n=0;n<this.layers.length;n++){const e=this.layers[n],i=t%2,a=i?t-1:this.isBitcoinTree&&t===e.length-1&&n<this.layers.length-1?t:t+1;a<e.length&&r.push({position:i?"left":"right",data:e[a]}),t=t/2|0}return r}getHexProof(e,t){return this.getProof(e,t).map((e=>this.bufferToHex(e.data)))}getProofs(){const e=[];return this.getProofsDFS(this.layers.length-1,0,[],e),e}getProofsDFS(e,t,r,n){const i=t%2;if(-1===e)return void(i||n.push([...r].reverse()));if(t>=this.layers[e].length)return;const a=this.layers[e],s=i?t-1:t+1;let o=!1;s<a.length&&(o=!0,r.push({position:i?"left":"right",data:a[s]}));const l=2*t,u=2*t+1;this.getProofsDFS(e-1,l,r,n),this.getProofsDFS(e-1,u,r,n),o&&r.splice(r.length-1,1)}getHexProofs(){return this.getProofs().map((e=>this.bufferToHex(e.data)))}getPositionalHexProof(e,t){return this.getProof(e,t).map((e=>["left"===e.position?0:1,this.bufferToHex(e.data)]))}getProofIndices(e,t){const r=2**t;let n=new Set;for(const l of e){let e=r+l;for(;e>1;)n.add(1^e),e=e/2|0}const i=e.map((e=>r+e)),a=Array.from(n).sort(((e,t)=>e-t)).reverse();n=i.concat(a);const s=new Set,o=[];for(let l of n)if(!s.has(l))for(o.push(l);l>1&&(s.add(l),s.has(1^l));)l=l/2|0;return o.filter((t=>!e.includes(t-r)))}getProofIndicesForUnevenTree(e,t){const r=Math.ceil(Math.log2(t)),n=[];for(let s=0;s<r;s++){t%2!==0&&n.push({index:s,leavesCount:t}),t=Math.ceil(t/2)}const i=[];let a=e;for(let s=0;s<r;s++){let e=a.map((e=>e%2===0?e+1:e-1)).filter((e=>!a.includes(e)));const t=n.find((e=>{let{index:t}=e;return t===s}));t&&a.includes(t.leavesCount-1)&&(e=e.slice(0,-1)),i.push(e),a=[...new Set(a.map((e=>e%2===0?e/2:e%2===0?(e+1)/2:(e-1)/2)))]}return i}getMultiProof(e,t){this.complete||console.warn("Warning: For correct multiProofs it's strongly recommended to set complete: true"),t||(t=e,e=this.getLayersFlat());if(this.isUnevenTree()&&t.every(Number.isInteger))return this.getMultiProofForUnevenTree(t);if(!t.every(Number.isInteger)){let e=t;this.sortPairs&&(e=e.sort(d.Buffer.compare));let r=e.map((e=>this.bufferIndexOf(this.leaves,e,this.sortLeaves))).sort(((e,t)=>e===t?0:e>t?1:-1));if(!r.every((e=>-1!==e)))throw new Error("Element does not exist in Merkle tree");const n=[],i=[];let a=[];for(let t=0;t<this.layers.length;t++){const e=this.layers[t];for(let t=0;t<r.length;t++){const s=r[t],o=this.getPairNode(e,s);n.push(e[s]),o&&i.push(o),a.push(s/2|0)}r=a.filter(((e,t,r)=>r.indexOf(e)===t)),a=[]}return i.filter((e=>!n.includes(e)))}return this.getProofIndices(t,Math.log2(e.length/2|0)).map((t=>e[t]))}getMultiProofForUnevenTree(e,t){t||(t=e,e=this.getLayers());let r=[],n=t;for(const i of e){const e=[];for(const r of n){if(r%2===0){const t=r+1;if(!n.includes(t)&&i[t]){e.push(i[t]);continue}}const t=r-1;n.includes(t)||!i[t]||e.push(i[t])}r=r.concat(e);const t=new Set;for(const r of n)r%2!==0?r%2!==0?t.add((r-1)/2):t.add((r+1)/2):t.add(r/2);n=Array.from(t)}return r}getHexMultiProof(e,t){return this.getMultiProof(e,t).map((e=>this.bufferToHex(e)))}getProofFlags(e,t){if(!Array.isArray(e)||e.length<=0)throw new Error("Invalid Inputs!");let r;if(r=e.every(Number.isInteger)?[...e].sort(((e,t)=>e===t?0:e>t?1:-1)):e.map((e=>this.bufferIndexOf(this.leaves,e,this.sortLeaves))).sort(((e,t)=>e===t?0:e>t?1:-1)),!r.every((e=>-1!==e)))throw new Error("Element does not exist in Merkle tree");const n=t.map((e=>this.bufferify(e))),i=[],a=[];for(let s=0;s<this.layers.length;s++){const e=this.layers[s];r=r.reduce(((t,r)=>{if(!i.includes(e[r])){const t=this.getPairNode(e,r),s=n.includes(e[r])||n.includes(t);t&&a.push(!s),i.push(e[r]),i.push(t)}return t.push(r/2|0),t}),[])}return a}verify(e,t,r){let n=this.bufferify(t);if(r=this.bufferify(r),!Array.isArray(e)||!t||!r)return!1;for(let i=0;i<e.length;i++){const t=e[i];let r=null,a=null;if("string"===typeof t)r=this.bufferify(t),a=!0;else if(Array.isArray(t))a=0===t[0],r=this.bufferify(t[1]);else if(d.Buffer.isBuffer(t))r=t,a=!0;else{if(!(t instanceof Object))throw new Error("Expected node to be of type string or object");r=this.bufferify(t.data),a="left"===t.position}const s=[];this.isBitcoinTree?(s.push(y()(n)),s[a?"unshift":"push"](y()(r)),n=this.hashFn(this.concatenator(s)),n=y()(this.hashFn(n))):this.sortPairs?-1===d.Buffer.compare(n,r)?(s.push(n,r),n=this.hashFn(this.concatenator(s))):(s.push(r,n),n=this.hashFn(this.concatenator(s))):(s.push(n),s[a?"unshift":"push"](r),n=this.hashFn(this.concatenator(s)))}return 0===d.Buffer.compare(n,r)}verifyMultiProof(e,t,r,n,i){if(this.isUnevenTree())return this.verifyMultiProofForUnevenTree(e,t,r,n,i);const a=Math.ceil(Math.log2(n));e=this.bufferify(e),r=r.map((e=>this.bufferify(e))),i=i.map((e=>this.bufferify(e)));const s={};for(const[u,c]of this.zip(t,r))s[2**a+u]=c;for(const[u,c]of this.zip(this.getProofIndices(t,a),i))s[u]=c;let o=Object.keys(s).map((e=>Number(e))).sort(((e,t)=>e-t));o=o.slice(0,o.length-1);let l=0;for(;l<o.length;){const e=o[l];if(e>=2&&{}.hasOwnProperty.call(s,1^e)){let t=[s[e-e%2],s[e-e%2+1]];this.sortPairs&&(t=t.sort(d.Buffer.compare));const r=t[1]?this.hashFn(this.concatenator(t)):t[0];s[e/2|0]=r,o.push(e/2|0)}l+=1}return!t.length||{}.hasOwnProperty.call(s,1)&&s[1].equals(e)}verifyMultiProofWithFlags(e,t,r,n){e=this.bufferify(e),t=t.map(this.bufferify),r=r.map(this.bufferify);const i=t.length,a=n.length,s=[];let o=0,l=0,u=0;for(let c=0;c<a;c++){const e=[n[c]?o<i?t[o++]:s[l++]:r[u++],o<i?t[o++]:s[l++]].sort(d.Buffer.compare);s[c]=this.hashFn(this.concatenator(e))}return 0===d.Buffer.compare(s[a-1],e)}verifyMultiProofForUnevenTree(e,t,r,n,i){e=this.bufferify(e),r=r.map((e=>this.bufferify(e))),i=i.map((e=>this.bufferify(e)));const a=this.calculateRootForUnevenTree(t,r,n,i);return e.equals(a)}getDepth(){return this.getLayers().length-1}getLayersAsObject(){const e=this.getLayers().map((e=>e.map((e=>this.bufferToHex(e,!1))))),t=[];for(let r=0;r<e.length;r++){const n=[];for(let i=0;i<e[r].length;i++){const a={[e[r][i]]:null};if(t.length){a[e[r][i]]={};const n=t.shift(),s=Object.keys(n)[0];if(a[e[r][i]][s]=n[s],t.length){const n=t.shift(),s=Object.keys(n)[0];a[e[r][i]][s]=n[s]}}n.push(a)}t.push(...n)}return t[0]}resetTree(){this.leaves=[],this.layers=[]}getPairNode(e,t){const r=t%2===0?t+1:t-1;return r<e.length?e[r]:null}toTreeString(){const e=this.getLayersAsObject();return(0,g.asTree)(e,!0,!1)}toString(){return this.toTreeString()}isUnevenTree(e){const t=e?.length||this.getDepth();return!this.isPowOf2(t)}isPowOf2(e){return e&&!(e&e-1)}calculateRootForUnevenTree(e,t,r,n){const i=this.zip(e,t).sort(((e,t)=>{let[r]=e,[n]=t;return r-n})),a=i.map((e=>{let[t]=e;return t})),s=this.getProofIndicesForUnevenTree(a,r);let o=0;const l=[];for(let c=0;c<s.length;c++){const e=s[c],t=o;o+=e.length,l[c]=this.zip(e,n.slice(t,o))}const u=[i];for(let c=0;c<l.length;c++){const e=l[c].concat(u[c]).sort(((e,t)=>{let[r]=e,[n]=t;return r-n})).map((e=>{let[,t]=e;return t})),t=u[c].map((e=>{let[t]=e;return t})),r=[...new Set(t.map((e=>e%2===0?e/2:e%2===0?(e+1)/2:(e-1)/2)))],n=[];for(let i=0;i<r.length;i++){const t=r[i],a=e[2*i],s=e[2*i+1],o=s?this.hashFn(this.concatenator([a,s])):a;n.push([t,o])}u.push(n)}return u[u.length-1][0][1]}}var S=r(86407),T=r(1604),P=r(17736),k=r(57632),B=r(48764).Buffer;function C(e){return{startTimestamp:e.startTimestamp,maxClaimableSupply:e.maxClaimableSupply,supplyClaimed:e.supplyClaimed,merkleRoot:e.merkleRoot,pricePerToken:e.pricePerToken,currency:e.currency,quantityLimitPerTransaction:e.maxClaimablePerWallet,waitTimeInSecondsBetweenClaims:e.waitTimeInSecondsBetweenClaims||0}}function A(e){return{startTimestamp:e.startTimestamp,maxClaimableSupply:e.maxClaimableSupply,supplyClaimed:e.supplyClaimed,merkleRoot:e.merkleRoot,pricePerToken:e.pricePerToken,currency:e.currency,quantityLimitPerWallet:e.maxClaimablePerWallet,metadata:e.metadata||""}}function L(e,t){return"unlimited"===e?n.Bz:i.parseUnits(e,t)}async function O(e){const t=25e3,r=Array.from({length:Math.ceil(e.length/t)},((r,n)=>e.slice(n*t,n*t+t))),n=[],i=await Promise.all(r.map((e=>f.bM.parseAsync(e))));for(const a of i)n.push(...a);return n}let z=function(e){return e[e.V1=1]="V1",e[e.V2=2]="V2",e}({});class H{constructor(e,t,r,n,i){this.storage=e,this.shardNybbles=n,this.baseUri=t,this.originalEntriesUri=r,this.tokenDecimals=i,this.shards={},this.trees={}}static async fromUri(e,t){try{const r=await t.downloadJSON(e);if(r.isShardedMerkleTree)return H.fromShardedMerkleTreeInfo(r,t)}catch(r){return}}static async fromShardedMerkleTreeInfo(e,t){return new H(t,e.baseUri,e.originalEntriesUri,e.shardNybbles,e.tokenDecimals)}static hashEntry(e,t,r,n){switch(n){case z.V1:return a.keccak256(["address","uint256"],[e.address,L(e.maxClaimable,t)]);case z.V2:return a.keccak256(["address","uint256","uint256","address"],[e.address,L(e.maxClaimable,t),L(e.price||"unlimited",r),e.currencyAddress||s.d])}}static async fetchAndCacheDecimals(e,t,r){if(!r)return 18;let n=e[r];if(void 0===n){n=(await(0,h.f)(t,r)).decimals,e[r]=n}return n}static async buildAndUpload(e,t,r,n,i){let a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:2;const s=await O(e),l={};for(const o of s){const e=o.address.slice(2,2+a).toLowerCase();void 0===l[e]&&(l[e]=[]),l[e].push(o)}const u={},c=await Promise.all(Object.entries(l).map((async e=>{let[n,a]=e;return[n,new x(await Promise.all(a.map((async e=>{const n=await H.fetchAndCacheDecimals(u,r,e.currencyAddress);return H.hashEntry(e,t,n,i)}))),o.keccak256,{sort:!0}).getHexRoot()]}))),f=Object.fromEntries(c),h=new x(Object.values(f),o.keccak256,{sort:!0}),m=[];for(const[o,b]of Object.entries(l)){const e={proofs:h.getProof(f[o]).map((e=>"0x"+e.data.toString("hex"))),entries:b};m.push({data:JSON.stringify(e),name:`${o}.json`})}const d=await n.uploadBatch(m),p=d[0].slice(0,d[0].lastIndexOf("/")),y=await n.upload(s),g={merkleRoot:h.getHexRoot(),baseUri:p,originalEntriesUri:y,shardNybbles:a,tokenDecimals:t,isShardedMerkleTree:!0};return{shardedMerkleInfo:g,uri:await n.upload(g)}}async getProof(e,t,r){const n=e.slice(2,2+this.shardNybbles).toLowerCase();let i=this.shards[n];const a={};if(void 0===i)try{const e=this.baseUri.endsWith("/")?this.baseUri:`${this.baseUri}/`;i=this.shards[n]=await this.storage.downloadJSON(`${e}${n}.json`);const s=await Promise.all(i.entries.map((async e=>{const n=await H.fetchAndCacheDecimals(a,t,e.currencyAddress);return H.hashEntry(e,this.tokenDecimals,n,r)})));this.trees[n]=new x(s,o.keccak256,{sort:!0})}catch(h){return null}const s=i.entries.find((t=>t.address.toLowerCase()===e.toLowerCase()));if(!s)return null;const l=await H.fetchAndCacheDecimals(a,t,s.currencyAddress),u=H.hashEntry(s,this.tokenDecimals,l,r),c=this.trees[n].getProof(u).map((e=>"0x"+e.data.toString("hex")));return f.bN.parseAsync({...s,proof:c.concat(i.proofs)})}async getAllEntries(){try{return await this.storage.downloadJSON(this.originalEntriesUri)}catch(e){return console.warn("Could not fetch original snapshot entries",e),[]}}}async function I(e,t,r,n,i,a){if(!r)return null;const s=r[t];if(s){const r=await i.downloadJSON(s);if(r.isShardedMerkleTree&&r.merkleRoot===t){const t=await H.fromShardedMerkleTreeInfo(r,i);return await t.getProof(e,n,a)}const o=await f.bO.parseAsync(r);if(t===o.merkleRoot)return o.claims.find((t=>t.address.toLowerCase()===e.toLowerCase()))||null}return null}function N(e){return{startTimestamp:e.startTimestamp,maxClaimableSupply:e.maxClaimableSupply,supplyClaimed:e.supplyClaimed,merkleRoot:e.merkleRoot.toString(),pricePerToken:e.pricePerToken,currency:e.currency,maxClaimablePerWallet:e.quantityLimitPerTransaction,waitTimeInSecondsBetweenClaims:e.waitTimeInSecondsBetweenClaims}}function E(e){return{startTimestamp:e.startTimestamp,maxClaimableSupply:e.maxClaimableSupply,supplyClaimed:e.supplyClaimed,merkleRoot:e.merkleRoot.toString(),pricePerToken:e.pricePerToken,currency:e.currency,maxClaimablePerWallet:e.quantityLimitPerWallet,waitTimeInSecondsBetweenClaims:0,metadata:e.metadata}}async function M(e,t,n,a,s){const o=e.getSigner(),u=e.getProvider(),c=(await Promise.resolve().then(r.t.bind(r,30853,19))).default,h=new f.cs(o||u,t,c,e.options,e.storage),m=await e.getSignerAddress(),d=e.address,p=await h.read("allowance",[m,d]),y=l.O$.from(n).mul(l.O$.from(a)).div(i.parseUnits("1",s));p.lt(y)&&await h.sendTransaction("approve",[d,p.add(y)])}async function R(e,t,r,a,o,c,f,d,p){let y=L(r.maxClaimablePerWallet,o),g=[u.hexZeroPad([0],32)],b=r.price,w=r.currencyAddress;try{if(!r.merkleRootHash.toString().startsWith(s.d)){const t=await I(e,r.merkleRootHash.toString(),await a(),c.getProvider(),f,p);if(t)g=t.proof,y="unlimited"===t.maxClaimable?n.Bz:i.parseUnits(t.maxClaimable,o),b=void 0===t.price||"unlimited"===t.price?n.Bz:await(0,m.n)(c.getProvider(),t.price,t.currencyAddress||s.d),w=t.currencyAddress||s.d;else if(p===z.V1)throw new Error("No claim found for this address")}}catch(T){if("No claim found for this address"===T?.message)throw T;console.warn("failed to check claim condition merkle root hash, continuing anyways",T)}const v=await c.getCallOverrides()||{},x=b.toString()!==n.Bz.toString()?b:r.price,S=w!==s.d?w:r.currencyAddress;return x.gt(0)&&((0,h.i)(S)?v.value=l.O$.from(x).mul(t).div(i.parseUnits("1",o)):d&&await M(c,S,x,t,o)),{overrides:v,proofs:g,maxClaimable:y,price:x,currencyAddress:S,priceInProof:b,currencyAddressInProof:w}}const F=(()=>T.z.object({name:T.z.string(),symbol:T.z.string(),decimals:T.z.number()}))(),U=(()=>F.extend({value:f.b5,displayValue:T.z.string()}))(),D=(()=>T.z.object({name:T.z.string().optional()}).catchall(T.z.unknown()))(),j=(()=>T.z.object({startTime:S.S,currencyAddress:T.z.string().default(f.aV),price:f.cw.default(0),maxClaimableSupply:f.cA,maxClaimablePerWallet:f.cA,waitInSeconds:f.b6.default(0),merkleRootHash:f.cB.default(u.hexZeroPad([0],32)),snapshot:T.z.optional(f.bM).nullable(),metadata:D.optional()}))(),W=(()=>T.z.array(j))(),$=(()=>j.extend({availableSupply:f.cA,currentMintSupply:f.cA,currencyMetadata:U.default({value:l.O$.from("0"),displayValue:"0",symbol:"",decimals:18,name:""}),price:f.b5,waitInSeconds:f.b5,startTime:f.b5.transform((e=>new Date(1e3*e.toNumber()))),snapshot:f.bM.optional().nullable()}))();async function q(e,t,r,n,i){const a=[],s=await Promise.all(e.map((async e=>{if(e.snapshot&&e.snapshot.length>0){const s=await async function(e,t,r,n,i){const a=await O(e),s=a.map((e=>e.address));if(new Set(s).size<s.length)throw new f.s;const o=await H.buildAndUpload(a,t,r,n,i);return{merkleRoot:o.shardedMerkleInfo.merkleRoot,snapshotUri:o.uri}}(e.snapshot,t,r,n,i);a.push(s),e.merkleRootHash=s.merkleRoot}else e.merkleRootHash=u.hexZeroPad([0],32);return e})));return{inputsWithSnapshots:s,snapshotInfos:a}}async function V(e,t,r,n,i){const{inputsWithSnapshots:a,snapshotInfos:o}=await q(e,t,r,n,i),u=await W.parseAsync(a),c=(await Promise.all(u.map((e=>async function(e,t,r,n){const i=e.currencyAddress===s.d?f.aV:e.currencyAddress,a=L(e.maxClaimableSupply,t),o=L(e.maxClaimablePerWallet,t);let l;return e.metadata&&(l="string"===typeof e.metadata?e.metadata:await n.upload(e.metadata)),{startTimestamp:e.startTime,maxClaimableSupply:a,supplyClaimed:0,maxClaimablePerWallet:o,pricePerToken:await(0,m.n)(r,e.price,i),currency:i,merkleRoot:e.merkleRootHash.toString(),waitTimeInSecondsBetweenClaims:e.waitInSeconds||0,metadata:l}}(e,t,r,n))))).sort(((e,t)=>function(e,t){const r=l.O$.from(e),n=l.O$.from(t);return r.eq(n)?0:r.gt(n)?1:-1}(e.startTimestamp,t.startTimestamp)));return{snapshotInfos:o,sortedConditions:c}}async function J(e,t,r){if(!t)return null;const n=t[e];if(n){const t=await r.downloadJSON(n);if(t.isShardedMerkleTree&&t.merkleRoot===e){return(await H.fromUri(n,r))?.getAllEntries()||null}{const r=await f.bO.parseAsync(t);if(e===r.merkleRoot)return r.claims.map((e=>({address:e.address,maxClaimable:e.maxClaimable,price:e.price,currencyAddress:e.currencyAddress})))}}return null}function _(e,t){return e.toString()===n.Bz.toString()?"unlimited":i.formatUnits(e,t)}async function Z(e,t,r,n,i,a){const s=await(0,h.a)(r,e.currency,e.pricePerToken),o=_(e.maxClaimableSupply,t),u=_(e.maxClaimablePerWallet,t),c=_(l.O$.from(e.maxClaimableSupply).sub(e.supplyClaimed),t),f=_(e.supplyClaimed,t);let m;return e.metadata&&(m=await i.downloadJSON(e.metadata)),$.parseAsync({startTime:e.startTimestamp,maxClaimableSupply:o,maxClaimablePerWallet:u,currentMintSupply:f,availableSupply:c,waitInSeconds:e.waitTimeInSecondsBetweenClaims?.toString(),price:l.O$.from(e.pricePerToken),currency:e.currency,currencyAddress:e.currency,currencyMetadata:s,merkleRootHash:e.merkleRoot,snapshot:a?await J(e.merkleRoot,n,i):void 0,metadata:m})}async function Y(e,t,r){if(e>=r.length)throw Error(`Index out of bounds - got index: ${e} with ${r.length} conditions`);const n=r[e].currencyMetadata.decimals,a=r[e].price,s=i.formatUnits(a,n),o=await j.parseAsync({...r[e],price:s,...t}),l=await $.parseAsync({...o,price:a});return r.map(((t,r)=>{let a;a=r===e?l:t;const s=i.formatUnits(a.price,n);return{...a,price:s}}))}let K=function(e){return e.NotEnoughSupply="There is not enough supply to claim.",e.AddressNotAllowed="This address is not on the allowlist.",e.WaitBeforeNextClaimTransaction="Not enough time since last claim transaction. Please wait.",e.ClaimPhaseNotStarted="Claim phase has not started yet.",e.AlreadyClaimed="You have already claimed the token.",e.WrongPriceOrCurrency="Incorrect price or currency.",e.OverMaxClaimablePerWallet="Cannot claim more than maximum allowed quantity.",e.NotEnoughTokens="There are not enough tokens in the wallet to pay for the claim.",e.NoActiveClaimPhase="There is no active claim phase at the moment. Please check back in later.",e.NoClaimConditionSet="There is no claim condition set.",e.NoWallet="No wallet connected.",e.Unknown="No claim conditions found.",e}({});function G(e){if(void 0===e){const e=B.alloc(16);return(0,k.Z)({},e),u.hexlify(c.Y0(e.toString("hex")))}return u.hexlify(e)}const Q=(()=>T.z.object({to:f.b9.refine((e=>e.toLowerCase()!==s.d),{message:"Cannot create payload to mint to zero address"}),price:f.cw.default(0),currencyAddress:f.b8.default(f.aV),mintStartTime:S.S,mintEndTime:S.E,uid:T.z.string().optional().transform((e=>G(e))),primarySaleRecipient:f.b9.default(s.d)}))(),X=(()=>Q.extend({quantity:f.cw}))(),ee=(()=>X.extend({mintStartTime:f.b5,mintEndTime:f.b5}))(),te=(()=>Q.extend({metadata:P.N,royaltyRecipient:T.z.string().default(s.d),royaltyBps:f.cC.default(0)}))(),re=(()=>te.extend({metadata:P.N.default(""),uri:T.z.string(),royaltyBps:f.b5,mintStartTime:f.b5,mintEndTime:f.b5}))(),ne=(()=>te.extend({metadata:P.N.default(""),quantity:f.b6}))(),ie=(()=>ne.extend({tokenId:f.b6}))(),ae=(()=>re.extend({tokenId:f.b5,quantity:f.b5}))(),se=(()=>te.extend({metadata:P.N.default(""),quantity:f.b5.default(1)}))(),oe=(()=>re.extend({quantity:f.b5.default(1)}))(),le=[{name:"to",type:"address"},{name:"primarySaleRecipient",type:"address"},{name:"quantity",type:"uint256"},{name:"price",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],ue=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"uri",type:"string"},{name:"price",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],ce=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"tokenId",type:"uint256"},{name:"uri",type:"string"},{name:"quantity",type:"uint256"},{name:"pricePerToken",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],fe=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"uri",type:"string"},{name:"quantity",type:"uint256"},{name:"pricePerToken",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}]},56351:function(e,t,r){var n=r(48764).Buffer;e.exports=function(e){for(var t=new n(e.length),r=0,i=e.length-1;r<=i;++r,--i)t[r]=e[i],t[i]=e[r];return t}},99269:function(e){e.exports=function(){function e(e,t){var r=t?"\u2514":"\u251c";return r+=e?"\u2500 ":"\u2500\u2500\u2510"}function t(e,t){var r=[];for(var n in e)e.hasOwnProperty(n)&&(t&&"function"===typeof e[n]||r.push(n));return r}function r(n,i,a,s,o,l,u){var c,f,h="",m=0,d=s.slice(0);if(d.push([i,a])&&s.length>0&&(s.forEach((function(e,t){t>0&&(h+=(e[1]?" ":"\u2502")+"  "),f||e[0]!==i||(f=!0)})),h+=e(n,a)+n,o&&("object"!==typeof i||i instanceof Date)&&(h+=": "+i),f&&(h+=" (circular ref.)"),u(h)),!f&&"object"===typeof i){var p=t(i,l);p.forEach((function(e){c=++m===p.length,r(e,i[e],c,d,o,l,u)}))}}var n={asLines:function(e,t,n,i){r(".",e,!1,[],t,"function"!==typeof n&&n,i||n)},asTree:function(e,t,n){var i="";return r(".",e,!1,[],t,n,(function(e){i+=e+"\n"})),i}};return n}()}}]);