"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[8309],{2840:function(t,e,a){a.d(e,{D:function(){return w},F:function(){return d},I:function(){return c},a:function(){return p},b:function(){return l},c:function(){return f},f:function(){return u},g:function(){return y},u:function(){return h}});var r=a(17736),n=a(16441),o=a(2593),s=a(64146),i=a(48764).Buffer;const c=(()=>n.arrayify("0x80ac58cd"))(),p=(()=>n.arrayify("0xd9b67a26"))(),d={name:"Failed to load NFT metadata"};async function u(t,e,a){if(e.startsWith("data:application/json;base64")&&"undefined"!==typeof i){const a=e.split(",")[1],n=JSON.parse(i.from(a,"base64").toString("utf-8"));return r.a.parse({...n,id:o.O$.from(t).toString(),uri:e})}const s=e.replace("{id}",n.hexZeroPad(o.O$.from(t).toHexString(),32).slice(2));let c;try{c=await a.downloadJSON(s)}catch(p){const r=e.replace("{id}",o.O$.from(t).toString());try{c=await a.downloadJSON(r)}catch(u){console.warn(`failed to get token metadata: ${JSON.stringify({tokenId:t.toString(),tokenUri:e})} -- falling back to default metadata`),c=d}}return r.a.parse({...c,id:o.O$.from(t).toString(),uri:e})}async function f(t,e,n,i){let f;const l=(await a.e(4309).then(a.t.bind(a,84309,19))).default,h=new s.CH(t,l,e),[y,w]=await Promise.all([h.supportsInterface(c),h.supportsInterface(p)]);if(y){const r=(await Promise.resolve().then(a.t.bind(a,47073,19))).default,o=new s.CH(t,r,e);f=await o.tokenURI(n)}else{if(!w)throw Error("Contract must implement ERC 1155 or ERC 721.");{const r=(await Promise.resolve().then(a.t.bind(a,98289,19))).default,o=new s.CH(t,r,e);f=await o.uri(n)}}return f?u(n,f,i):r.a.parse({...d,id:o.O$.from(n).toString(),uri:""})}async function l(t,e){return"string"===typeof t?t:await e.upload(r.C.parse(t))}async function h(t,e,a,n){if(function(t){return void 0===t.find((t=>"string"!==typeof t))}(t))return t;if(function(t){return void 0===t.find((t=>"object"!==typeof t))}(t)){return await e.uploadBatch(t.map((t=>r.C.parse(t))),{rewriteFileNames:{fileStartNumber:a||0},onProgress:n?.onProgress})}throw new Error("NFT metadatas must all be of the same type (all URI or all NFTMetadataInput)")}function y(t){const e=t[0].substring(0,t[0].lastIndexOf("/"));for(let a=0;a<t.length;a++){const r=t[a].substring(0,t[a].lastIndexOf("/"));if(e!==r)throw new Error(`Can only create batches with the same base URI for every entry in the batch. Expected '${e}' but got '${r}'`)}return e.replace(/\/$/,"")+"/"}const w=100},88309:function(t,e,a){a.d(e,{C:function(){return g},D:function(){return m},a:function(){return W},c:function(){return I}});var r=a(21919),n=a(23437),o=a(99612),s=a(43277),i=a(29251),c=a(31886),p=a(84243),d=a(16441),u=a(2593),f=a(64146),l=a(17736),h=a(2840),y=a(93626),w=a(99979);class g{featureName=o.d5.name;constructor(t,e){this.contractWrapper=t,this.metadata=e}async getDefaultRoyaltyInfo(){const[t,e]=await this.contractWrapper.read("getDefaultRoyaltyInfo",[]);return o.bF.parseAsync({fee_recipient:t,seller_fee_basis_points:e})}async getTokenRoyaltyInfo(t){const[e,a]=await this.contractWrapper.read("getRoyaltyInfoForToken",[t]);return o.bF.parseAsync({fee_recipient:e,seller_fee_basis_points:a})}setDefaultRoyaltyInfo=(0,n.f)((async t=>{const e=await this.metadata.get(),a=await this.metadata.parseInputMetadata({...e,...t}),o=await this.metadata._parseAndUploadMetadata(a);if((0,r.h)("setContractURI",this.contractWrapper)){const t=new s.C(this.contractWrapper),e=[t.encode("setDefaultRoyaltyInfo",[a.fee_recipient,a.seller_fee_basis_points]),t.encode("setContractURI",[o])];return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[e],parse:t=>({receipt:t,data:()=>this.getDefaultRoyaltyInfo()})})}throw new Error("Updating royalties requires implementing ContractMetadata in your contract to support marketplaces like OpenSea.")}));setTokenRoyaltyInfo=(0,n.f)((async(t,e)=>{const a=o.bF.parse(e);return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setRoyaltyInfoForToken",args:[t,a.fee_recipient,a.seller_fee_basis_points],parse:t=>({receipt:t,data:()=>this.getDefaultRoyaltyInfo()})})}))}class m{constructor(t,e,a,r){this.featureName=a,this.nextTokenIdToMintFn=r,this.contractWrapper=t,this.storage=e}createDelayedRevealBatch=(0,n.f)((async(t,e,a,r)=>{if(!a)throw new Error("Password is required");const o=await this.storage.uploadBatch([l.C.parse(t)],{rewriteFileNames:{fileStartNumber:0}}),s=(0,h.g)(o),d=await this.nextTokenIdToMintFn(),u=await this.storage.uploadBatch(e.map((t=>l.C.parse(t))),{onProgress:r?.onProgress,rewriteFileNames:{fileStartNumber:d.toNumber()}}),f=(0,h.g)(u),y=await this.contractWrapper.read("getBaseURICount",[]),w=await this.hashDelayRevealPassword(y,a),g=await this.contractWrapper.read("encryptDecrypt",[i.Y0(f),w]);let m;if(await this.isLegacyContract())m=g;else{const t=await this.contractWrapper.getChainID(),e=c.keccak256(["bytes","bytes","uint256"],[i.Y0(f),w,t]);m=p.$.encode(["bytes","bytes32"],[g,e])}return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"lazyMint",args:[u.length,s.endsWith("/")?s:`${s}/`,m],parse:t=>{const e=this.contractWrapper.parseLogs("TokensLazyMinted",t?.logs),a=e[0].args.startTokenId,r=e[0].args.endTokenId,n=[];for(let o=a;o.lte(r);o=o.add(1))n.push({id:o,receipt:t});return n}})}));reveal=(0,n.f)((async(t,e)=>{if(!e)throw new Error("Password is required");const a=await this.hashDelayRevealPassword(t,e);try{const e=await this.contractWrapper.callStatic().reveal(t,a);if(!e.includes("://")||!e.endsWith("/"))throw new Error("invalid password")}catch(r){throw new Error("invalid password")}return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"reveal",args:[t,a]})}));async getBatchesToReveal(){const t=await this.contractWrapper.read("getBaseURICount",[]);if(t.isZero())return[];const e=Array.from(Array(t.toNumber()).keys()),a=await Promise.all(e.map((t=>{if((0,r.h)("getBatchIdAtIndex",this.contractWrapper))return this.contractWrapper.read("getBatchIdAtIndex",[t]);if((0,r.h)("baseURIIndices",this.contractWrapper))return this.contractWrapper.read("baseURIIndices",[t]);throw new Error("Contract does not have getBatchIdAtIndex or baseURIIndices.")}))),n=a.slice(0,a.length-1),o=await Promise.all(Array.from([0,...n]).map((t=>this.getNftMetadata(t.toString())))),s=await this.isLegacyContract(),i=(await Promise.all(Array.from([...a]).map((t=>s?this.getLegacyEncryptedData(t):this.contractWrapper.read("encryptedData",[t]))))).map((t=>{if(d.hexDataLength(t)>0){if(s)return t;return p.$.decode(["bytes","bytes32"],t)[0]}return t}));return o.map(((t,e)=>({batchId:u.O$.from(e),batchUri:t.uri,placeholderMetadata:t}))).filter(((t,e)=>d.hexDataLength(i[e])>0))}async hashDelayRevealPassword(t,e){const a=await this.contractWrapper.getChainID(),r=this.contractWrapper.address;return c.keccak256(["string","uint256","uint256","address"],[e,a,t,r])}async getNftMetadata(t){return(0,h.c)(this.contractWrapper.address,this.contractWrapper.getProvider(),t,this.storage)}async isLegacyContract(){if((0,r.h)("contractVersion",this.contractWrapper))try{return await this.contractWrapper.read("contractVersion",[])<=2}catch(t){return!1}return!1}async getLegacyEncryptedData(t){const e=(await a.e(4467).then(a.t.bind(a,14467,19))).default,r=new f.CH(this.contractWrapper.address,e,this.contractWrapper.getProvider()),n=await r.functions.encryptedBaseURI(t);return n.length>0?n[0]:"0x"}}async function I(t,e,a,r,n){let s={};const i=r||o.aV,c=(await(0,w.n)(t.getProvider(),e,i)).mul(a);return c.gt(0)&&(i===o.aV?s={value:c}:i!==o.aV&&n&&await(0,y.a)(t,i,c,a,0)),s}class W{featureName=o.d6.name;constructor(t){this.contractWrapper=t}async get(){return this.contractWrapper.read("owner",[])}set=(0,n.f)((async t=>{const e=await(0,o.aL)(t);return n.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setOwner",args:[e]})}))}}}]);